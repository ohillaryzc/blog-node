-- MySQL dump 10.13  Distrib 5.5.57, for Win64 (AMD64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.5.57

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `about`
--

DROP TABLE IF EXISTS `about`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `about` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  `motto` varchar(100) NOT NULL,
  `logo` varchar(20) NOT NULL,
  `subtitle` varchar(40) NOT NULL,
  `avatar_path` varchar(100) NOT NULL,
  `page` text NOT NULL,
  `position` varchar(50) NOT NULL,
  `address` varchar(20) NOT NULL,
  `introduction` varchar(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `about`
--

LOCK TABLES `about` WRITE;
/*!40000 ALTER TABLE `about` DISABLE KEYS */;
INSERT INTO `about` VALUES (1,'O丶Hillary','study english now!!!','O`HILLARY`S BLOG','take notes for my life','/public/img/2.jpg','<p>本站是<u style=\"color: rgb(230, 0, 0);\">记录学习</u>的<span class=\"ql-size-large\" style=\"background-color: rgb(255, 255, 0);\">个人博客</span>	，仅用于记录<u>学习</u>、<u>项目</u>中遇到的<span style=\"color: rgb(230, 0, 0);\">难题</span>和<span style=\"background-color: rgb(230, 0, 0); color: rgb(255, 255, 255);\">解决的办法</span>	，便于日后总结，所有言论仅仅是个人观点</p><p><br></p><p>----<span class=\"ql-size-large\"> </span><strong class=\"ql-size-large\"><em><u>办法总比困难多 ﻿</u></em></strong></p>','前端开发','广东 广州','IT小白 - 前端小白 - 热爱学习');
/*!40000 ALTER TABLE `about` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(100) NOT NULL,
  `description` text NOT NULL,
  `last_time` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' ON UPDATE CURRENT_TIMESTAMP,
  `add_time` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  `views` int(8) NOT NULL,
  `classify` varchar(20) NOT NULL,
  `content` text NOT NULL,
  `tag` varchar(30) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
  `type` varchar(4) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=291 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (6,'let、const 关键字','es6学习开始，let和const关键字为我们提供了很多便利，用起来很舒服，这篇文章主要介绍let、const的用法，与之前var关键字的区别，以及一些小细节、注意事项......','2019-02-18 09:13:02','2019-02-16 12:10:41',6,'1','<h1><a id=\"let__const_0\"></a>let 和 const</h1>\n<h2><a id=\"let_2\"></a>let</h2>\n<p>类似var<br />\n区别：</p>\n<ul>\n<li>var 没有块级作用域，let 具有块级作用域</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">  {\n    <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">2</span>\n  }\n  a <span class=\"hljs-comment\">// a is not defined 报错</span>\n  b <span class=\"hljs-comment\">// 2</span>\n</code></div></pre>\n<ul>\n<li>let 不存在变量提升<br />\nvar 声明的变量无论在那个位置，都会提前到该作用域最前面声明，值为 <code>undefined</code> ，let 不存在这种情况<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-built_in\">console</span>.log(i)\n<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-comment\">// undefined 变量提升</span>\n\n<span class=\"hljs-built_in\">console</span>.log(j)\n<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-comment\">// 报错</span>\n</code></div></pre>\n</li>\n</ul>\n<p>for 循环大括号属于块级作用域</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n  <span class=\"hljs-comment\">// ...</span>\n}\n<span class=\"hljs-built_in\">console</span>.log(i) <span class=\"hljs-comment\">// i uis not defined</span>\n\n<span class=\"hljs-keyword\">var</span> a = []\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n  a[i] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(i)\n  }\n}\na[<span class=\"hljs-number\">6</span>]() <span class=\"hljs-comment\">// 10</span>\n</code></div></pre>\n<p>var 声明的变量没有块级作用域，所有i 在全局，每循环一次，i都会变化一次，覆盖之前的值<br />\ni 始终都只有一个值，循环完之后就是最后那个值</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> a = []\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n  a[i] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(i)\n  }\n}\na[<span class=\"hljs-number\">6</span>]() <span class=\"hljs-comment\">// 6</span>\n</code></div></pre>\n<p>let 声明的变量有块级作用域，每循环一次，都会多一个i 变量，在不同的作用域里面，因为i被引用了，所有i的值一直存在内存中</p>\n<p>for 循环注意</p>\n<blockquote>\n<p>for设置循环变量的那一部分为一个父级作用域，循环体是他的一个子作用域</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; i++) {\n  <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-string\">\'abc\'</span>\n  <span class=\"hljs-built_in\">console</span>.log(i)\n}\n<span class=\"hljs-comment\">// 输出三次abc</span>\n</code></div></pre>\n<p>说明循环变量里的 i 和 循环体里面的 i 是在不同作用域的 i ，因为let声明重复的变量会报错</p>\n<blockquote>\n<p>VM211:1 Uncaught SyntaxError: Identifier ‘i’ has already been declared</p>\n</blockquote>\n<h2><a id=\"temporal_dead_zone_67\"></a>暂时性死区（temporal dead zone）</h2>\n<p>只要块级作用域内存在let，他声明的变量就会绑定该作用域，不受外部影响</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> temp = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n  temp = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// 报错</span>\n  <span class=\"hljs-keyword\">let</span> temp = <span class=\"hljs-number\">3</span>\n}\n</code></div></pre>\n<p>在 let 和 const 声明变量的作用域内，就会形成封闭区域，在声明这些变量之前使用就会报错<br />\n在没有 let 之前 typeof 运算符是百分之百安全的，永远不会报错，但是现在在暂时性死区内就不成立了</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">typeof</span> foo <span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-keyword\">var</span> foo = []\n\n<span class=\"hljs-keyword\">typeof</span> bar <span class=\"hljs-comment\">// 报错，let声明该变量在声明之前使用</span>\n<span class=\"hljs-keyword\">let</span> bar = {}\n</code></div></pre>\n<h2><a id=\"_86\"></a>不允许重复变量(在同一个作用域内，不允许两个相同的变量)</h2>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 报错</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 报错</span>\n}\n</code></div></pre>\n<h2><a id=\"_99\"></a>块级作用域</h2>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> n = <span class=\"hljs-number\">10</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">let</span> n = <span class=\"hljs-number\">5</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(n)\n}\nfn() <span class=\"hljs-comment\">// 10</span>\n</code></div></pre>\n<p>let有块级作用域，if条件语句外面不能读取到语句里面的let变量</p>\n<blockquote>\n<p>es6允许块级作用域的任意嵌套，外面的不能获取里面的，内层作用域可以定义外层作用域的同名变量。</p>\n</blockquote>\n<h2><a id=\"IIFE_113\"></a>IIFE</h2>\n<blockquote>\n<p>https://segmentfault.com/a/1190000003985390</p>\n</blockquote>\n<h2><a id=\"_116\"></a>块级作用域声明函数</h2>\n<ul>\n<li>es5<br />\nes5规定在块级作用域声明是非法的，但是浏览器没有遵守：</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'11\'</span>)\n}\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">false</span>) {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span> (<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'22\'</span>)\n    }\n  }\n  fn() <span class=\"hljs-comment\">// 22</span>\n})()\n\n<span class=\"hljs-comment\">// es5中函数声明会提升，上面代码相当于：</span>\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'22\'</span>)\n  }\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">false</span>) {}\n  fn()\n})()\n</code></div></pre>\n<p>-es6<br />\n允许在块级作用域内声明函数。<br />\n函数声明类似于var，即会提升到全局作用域或函数作用域的头部。<br />\n同时，函数声明还会提升到所在的块级作用域的头部。<br />\n<em>仅在es6浏览器中有效</em></p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'11\'</span>)\n}\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">false</span>) {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span> (<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'22\'</span>)\n    }\n  }\n  fn() <span class=\"hljs-comment\">// 报错</span>\n})()\n\n<span class=\"hljs-comment\">// 以上代码相当于：</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'11\'</span>)\n}\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> fn = <span class=\"hljs-literal\">undefined</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">false</span>) {\n    fn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\'22\'</span>)\n    }\n  }\n  fn() <span class=\"hljs-comment\">// fn is not a function报错</span>\n})()\n</code></div></pre>\n<h2><a id=\"const_174\"></a>const关键字</h2>\n<ul>\n<li>const声明一个常量，一旦声明，常量的值就不能改变<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">33</span>\na = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 报错</span>\n</code></div></pre>\n</li>\n<li>const声明必须赋值，不能等到之后赋值</li>\n<li>const与let一样只在声明的块级作用域内有效</li>\n<li>const不存在提升，同样存在<code>暂时性死区</code>，不能重复声明</li>\n</ul>\n<h3><a id=\"const_184\"></a>const本质</h3>\n<p>const实际上保证的不是变量值不能改动，而是变量指向的地址值不改动，对于简单数据类型，const保存的就是指向的内存地址，因此与常量一样，<br />\n对于复杂类型（对象，数组），const只保证指针不改变，数据结构改不改变就不完全不可控制了</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">const</span> obj = {<span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\'jack\'</span>}\nobj.sex = <span class=\"hljs-string\">\'men\'</span>\nobj.name = <span class=\"hljs-string\">\'bob\'</span> <span class=\"hljs-comment\">// 不报错</span>\n\nobj = {} <span class=\"hljs-comment\">// 报错</span>\n<span class=\"hljs-comment\">// 数组道理一样，可进行一系列操作，就是不能改变地址值</span>\n</code></div></pre>\n<p>要是想冻结一个对象，应该使用对象的冻结方法<code>Object.freeze({})</code><br />\n想要彻底冻结一个对象应该自己实现方法：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFreeze</span> (<span class=\"hljs-params\">obj</span>) </span>{\n  <span class=\"hljs-built_in\">Object</span>.freeze(obj)\n  <span class=\"hljs-built_in\">Object</span>.keys(obj).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> obj[key] === <span class=\"hljs-string\">\'object\'</span>) {\n      myFreeze(obj[key])\n    }\n  })\n}\n</code></div></pre>\n<h2><a id=\"es6_207\"></a>es6声明变量方式</h2>\n<ul>\n<li>var (es5)</li>\n<li>function (es5)</li>\n<li>let (es6)</li>\n<li>const (es6)</li>\n<li>import (es6)</li>\n<li>class (es6)<br />\n<em>一共六种</em></li>\n</ul>\n<h2><a id=\"_216\"></a>顶层对象</h2>\n<p>浏览器中指<code>window</code>，node环境中指<code>global</code></p>\n<h3><a id=\"window_218\"></a>window</h3>\n<p>es5中顶层对象与全局变量是一样的，属于顶层对象的属性</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-built_in\">window</span>.a = <span class=\"hljs-number\">1</span>\na = <span class=\"hljs-number\">4</span>\n<span class=\"hljs-built_in\">window</span>.a <span class=\"hljs-comment\">// 4</span>\n</code></div></pre>\n<p>这样容易造成混乱<br />\nes6中，var与function声明的变量是全局变量，let、const、class声明的变量不是全局变量，不属于顶层对象的属性</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-built_in\">window</span>.a <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-built_in\">window</span>.b <span class=\"hljs-comment\">// undefined</span>\n</code></div></pre>\n<h3><a id=\"global_233\"></a>global</h3>\n<p>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。<br />\n浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。<br />\nNode 里面，顶层对象是global，但其他环境都不支持。</p>\n','6,9,13',NULL),(7,'set&map数据结构','','2019-02-22 12:34:33','2019-02-18 02:12:46',11,'1','<h1><a id=\"set_and_map__0\"></a>set and map 数据结构</h1>\n<h2><a id=\"set_2\"></a>set</h2>\n<h3><a id=\"set__4\"></a>set 实例的属性和方法</h3>\n<h4><a id=\"_6\"></a>属性</h4>\n<ul>\n<li>new Set([]) 可接收一个数组做为参数</li>\n<li>Set.prototype.size 返回Set实例的成员总数</li>\n</ul>\n<h4><a id=\"_11\"></a>方法</h4>\n<ul>\n<li>add(value) 添加某个值返回Set结构本身</li>\n<li>delete(value) 删除，返回boolean表示是否删除成功</li>\n<li>has(value) 返回boolean，表示是否有该成员</li>\n<li>clear() 清除所有成员，void</li>\n</ul>\n<h4><a id=\"set_18\"></a>set和数组</h4>\n<p>set ==&gt; 数组</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>])\n<span class=\"hljs-keyword\">let</span> arr = <span class=\"hljs-built_in\">Array</span>.from(set) <span class=\"hljs-comment\">// [1, 2, 3, 4]</span>\n</code></div></pre>\n<p>因为set数据结构中不会出现重复的值，所有可以用来做数组去重</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-comment\">// 方法一</span>\n[...new <span class=\"hljs-built_in\">Set</span>(arr)]\n\n<span class=\"hljs-comment\">// 方法二</span>\n<span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>(arr))\n</code></div></pre>\n<h4><a id=\"_37\"></a>遍历操作</h4>\n<ul>\n<li>keys() ：由于set没有键名只有键值，所以keys()的返回值和values()的返回值一直</li>\n<li>values() = keys()</li>\n<li>entries() 返回一个数组，每个元素都是键值组成的数组，两个元素完全一样</li>\n<li>forEach() 与数组的该方法一致</li>\n</ul>\n<blockquote>\n<p>set集合与数组结合操作很容易找出两个数组的差集</p>\n<p>set与filter() 结合使用</p>\n</blockquote>\n<h4><a id=\"weakset_48\"></a>weakset</h4>\n<ul>\n<li>\n<p>weakset与set的区别：weakset里面只能存放对象</p>\n</li>\n<li>\n<p>weakset里面的对象都是弱引用，即垃圾回收器不会考虑该对象还存在weakset中</p>\n</li>\n<li>\n<p>weakset没有size属性，因此不能遍历</p>\n</li>\n</ul>\n<h3><a id=\"map_55\"></a>map</h3>\n<blockquote>\n<p>Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n</blockquote>\n<p>map的键可以是任意的类型，包括对象</p>\n<h4><a id=\"map_61\"></a>map()</h4>\n<p>map构造函数可以接收一个二维数组，数组里面的两个元素为键值</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> items = [\n    [<span class=\"hljs-string\">\'name\'</span>: <span class=\"hljs-string\">\'lzc\'</span>],\n    [<span class=\"hljs-string\">\'title\'</span>: <span class=\"hljs-string\">\'nice\'</span>]\n]\n<span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(items)\n\nmap.size <span class=\"hljs-comment\">// 2</span>\nmap.get(<span class=\"hljs-string\">\'title\'</span>) <span class=\"hljs-comment\">// nice</span>\n\n<span class=\"hljs-comment\">// 上面代码相当于</span>\nitems.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">[key, value]</span>) =&gt;</span> {\n    map.set(key, value)\n})\n\n</code></div></pre>\n<p>Map构造函数的参数不仅仅是数组，任何具有Iterator接口、且每个成员都是一个双元素的数组的数据结构都可以作为Map构造函数的参数，包括set，map</p>\n<p>当map构造函数参数是一个map时，就生成了新的对象</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([[], []])\n<span class=\"hljs-keyword\">let</span> newMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(map)\n\nmap === newMap <span class=\"hljs-comment\">// false</span>\n</code></div></pre>\n<p>map的键为对象时，对应的是对象的引用</p>\n<p>只有键名严格相等时，才能取到对应的值，NaN除外</p>\n','1,13,14',NULL),(8,'html文本代码测试','超文本标记语言，标准通用标记语言下的一个应用。是 网页制作必备的编程语言，“超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。超文本标记语言的结构包括“头”部分（英语：Head）、和“主体”部分（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。','2019-03-13 01:58:28','2019-02-18 02:28:35',25,'3','<h1><a id=\"HTML_0\"></a>测试HTML</h1>\n<p>超文本标记语言，<a href=\"https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073\" target=\"_blank\">标准通用标记语言</a>下的一个应用。是 网页制作必备的编程语言</p>\n<p><strong>“</strong><a href=\"https://baike.baidu.com/item/%E8%B6%85%E6%96%87%E6%9C%AC/2832422\" target=\"_blank\">超文本</a>**”**就是指页面内可以包含图片、<a href=\"https://baike.baidu.com/item/%E9%93%BE%E6%8E%A5/2665501\" target=\"_blank\">链接</a>，甚至音乐、<a href=\"https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/71525\" target=\"_blank\">程序</a>等非文字元素。</p>\n<p>超文本标记语言的结构包括**“**头”部分（英语：Head）、和“主体”部分（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的<a href=\"https://baike.baidu.com/item/%E5%85%B7%E4%BD%93/4577821\" target=\"_blank\">具体</a>内容。</p>\n<h2><a id=\"_8\"></a>由来</h2>\n<p><a href=\"https://baike.baidu.com/item/%E4%B8%87%E7%BB%B4%E7%BD%91\" target=\"_blank\">万维网</a>（world wide web）上的一个<a href=\"https://baike.baidu.com/item/%E8%B6%85%E5%AA%92%E4%BD%93\" target=\"_blank\">超媒体</a>文档称之为一个<a href=\"https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2\" target=\"_blank\">页面</a>（<a href=\"https://baike.baidu.com/item/%E5%A4%96%E8%AF%AD\" target=\"_blank\">外语</a>：page）。作为一个组织或者个人在<a href=\"https://baike.baidu.com/item/%E4%B8%87%E7%BB%B4%E7%BD%91\" target=\"_blank\">万维网</a>上放置开始点的<a href=\"https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2\" target=\"_blank\">页面</a>称为<a href=\"https://baike.baidu.com/item/%E4%B8%BB%E9%A1%B5\" target=\"_blank\">主页</a>（外语：Homepage）或首页，主页中通常包括有指向其他相关页面或其他节点的<a href=\"https://baike.baidu.com/item/%E6%8C%87%E9%92%88\" target=\"_blank\">指针</a>（<a href=\"https://baike.baidu.com/item/%E8%B6%85%E7%BA%A7%E9%93%BE%E6%8E%A5\" target=\"_blank\">超级链接</a>），所谓<a href=\"https://baike.baidu.com/item/%E8%B6%85%E7%BA%A7%E9%93%BE%E6%8E%A5\" target=\"_blank\">超级链接</a>，就是一种<a href=\"https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E5%99%A8\" target=\"_blank\">统一资源定位器</a>（Uniform Resource Locator，<a href=\"https://baike.baidu.com/item/%E5%A4%96%E8%AF%AD\" target=\"_blank\">外语</a><a href=\"https://baike.baidu.com/item/%E7%BC%A9%E5%86%99\" target=\"_blank\">缩写</a>：<a href=\"https://baike.baidu.com/item/URL\" target=\"_blank\">URL</a>）指针，通过激活（点击）它，可使<a href=\"https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8\" target=\"_blank\">浏览器</a>方便地获取新的网页。这也是HTML获得广泛应用的最重要的原因之一。在逻辑上将视为一个整体的一系列<a href=\"https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2\" target=\"_blank\">页面</a>的有机集合称为<a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%AB%99\" target=\"_blank\">网站</a>（<a href=\"https://baike.baidu.com/item/Website\" target=\"_blank\">Website</a>或Site）。超级文本标记语言（英文缩写：HTML）是为“<a href=\"https://baike.baidu.com/item/%E7%BD%91%E9%A1%B5\" target=\"_blank\">网页</a>创建和其它可在<a href=\"https://baike.baidu.com/item/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8\" target=\"_blank\">网页浏览器</a>中看到的信息”设计的一种<a href=\"https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80\" target=\"_blank\">标记语言</a>。</p>\n<p>网页的本质就是超级文本标记语言，通过结合使用其他的<a href=\"https://baike.baidu.com/item/Web%E6%8A%80%E6%9C%AF\" target=\"_blank\">Web技术</a>（如：<a href=\"https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80\" target=\"_blank\">脚本语言</a>、<a href=\"https://baike.baidu.com/item/%E5%85%AC%E5%85%B1%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3\" target=\"_blank\">公共网关接口</a>、<a href=\"https://baike.baidu.com/item/%E7%BB%84%E4%BB%B6\" target=\"_blank\">组件</a>等），可以创造出功能强大的网页。因而，超级文本标记语言是万维网（<a href=\"https://baike.baidu.com/item/Web\" target=\"_blank\">Web</a>）编程的基础，也就是说<a href=\"https://baike.baidu.com/item/%E4%B8%87%E7%BB%B4%E7%BD%91\" target=\"_blank\">万维网</a>是建立在超文本基础之上的。超级文本标记语言之所以称为超文本标记<a href=\"https://baike.baidu.com/item/%E8%AF%AD%E8%A8%80\" target=\"_blank\">语言</a>，是因为文本中包含了所谓“<a href=\"https://baike.baidu.com/item/%E8%B6%85%E7%BA%A7%E9%93%BE%E6%8E%A5\" target=\"_blank\">超级链接</a>”点。 [1]</p>\n<h2><a id=\"_14\"></a>示例</h2>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>{{block \'title\'}}index{{/block}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"stylesheet\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/public/css/base.css\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"stylesheet\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/public/css/index.css\"</span>&gt;</span>\n    {{block \'style\'}}\n    {{/block}}\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"wrap\"</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- 头部 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"header\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"logo\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>O`HILLARY`S BLOG<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">P</span>&gt;</span>take notes for my life<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">P</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"search\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"search\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"close-search\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"searchKey\"</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"输入你想要的分类、标签、内容检索\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span>&gt;</span>search<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"nav\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"nav-item\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"search-btn\"</span>&gt;</span>search<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"nav-item\"</span>&gt;</span>Blog<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"nav-item hover-down\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>分类<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n                <span class=\"hljs-comment\">&lt;!-- 向上箭头 --&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"arrow\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"down\"</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"down-content\"</span>&gt;</span>\n                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"down-item\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"javascript:;\"</span>&gt;</span>vue<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"down-item\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"javascript:;\"</span>&gt;</span>node<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"down-item\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"javascript:;\"</span>&gt;</span>jQuery<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"down-item\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"javascript:;\"</span>&gt;</span>javascript<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"nav-item\"</span>&gt;</span>关于<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n    {{block \'content\'}}\n    {{/block}}\n\n    <span class=\"hljs-comment\">&lt;!-- 尾部 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"footer\"</span>&gt;</span>Copyright © 2019-2019 O`HILLARY`S BLOG<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n    <span class=\"hljs-comment\">&lt;!-- back to top --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"toTop hidden\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"toTop\"</span>&gt;</span>to top<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/public/js/jquery-3.3.1.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/public/js/common.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n{{block \'script\'}}\n{{/block}}\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></div></pre>\n','13,7',NULL),(9,' 变量解构赋值(es6学习)','解构赋值语法是一个 Javascript 表达式，这使得可以将值从数组或属性从对象提取到不同的变量中。','2019-03-12 10:46:36','2019-02-18 09:48:04',10,'1','<h1><a id=\"_0\"></a>变量解构赋值</h1>\n<h2><a id=\"_1\"></a>数组</h2>\n<h3><a id=\"_2\"></a>普通解构</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> [a, b, c] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\na <span class=\"hljs-comment\">// 1</span>\nb <span class=\"hljs-comment\">// 2</span>\nc <span class=\"hljs-comment\">// 3</span>\n</code></div></pre>\n<h3><a id=\"_9\"></a>嵌套解构</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> [foo, [[bar], baz]] = [<span class=\"hljs-number\">1</span>, [[<span class=\"hljs-number\">2</span>], <span class=\"hljs-number\">3</span>]];\nfoo <span class=\"hljs-comment\">// 1</span>\nbar <span class=\"hljs-comment\">// 2</span>\nbaz <span class=\"hljs-comment\">// 3</span>\n\n<span class=\"hljs-keyword\">let</span> [ , , third] = [<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>, <span class=\"hljs-string\">\"baz\"</span>];\nthird <span class=\"hljs-comment\">// \"baz\"</span>\n\n<span class=\"hljs-keyword\">let</span> [x, , y] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\nx <span class=\"hljs-comment\">// 1</span>\ny <span class=\"hljs-comment\">// 3</span>\n\n<span class=\"hljs-keyword\">let</span> [head, ...tail] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\nhead <span class=\"hljs-comment\">// 1</span>\ntail <span class=\"hljs-comment\">// [2, 3, 4]</span>\n\n<span class=\"hljs-keyword\">let</span> [x, y, ...z] = [<span class=\"hljs-string\">\'a\'</span>];\nx <span class=\"hljs-comment\">// \"a\"</span>\ny <span class=\"hljs-comment\">// undefined</span>\nz <span class=\"hljs-comment\">// []</span>\n</code></div></pre>\n<h3><a id=\"_32\"></a>不完全解构</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> [x, y] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\nx <span class=\"hljs-comment\">// 1</span>\ny <span class=\"hljs-comment\">// 2</span>\n\n<span class=\"hljs-keyword\">let</span> [a, [b], d] = [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>], <span class=\"hljs-number\">4</span>];\na <span class=\"hljs-comment\">// 1</span>\nb <span class=\"hljs-comment\">// 2</span>\nd <span class=\"hljs-comment\">// 4</span>\n</code></div></pre>\n<h3><a id=\"_43\"></a>解构不成功</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> [foo] = [];\n<span class=\"hljs-keyword\">let</span> [bar, foo] = [<span class=\"hljs-number\">1</span>];\n\nfoo <span class=\"hljs-comment\">// undefined</span>\n</code></div></pre>\n<h3><a id=\"_50\"></a>默认值</h3>\n<p>解构赋值允许指定默认值。</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> [x = <span class=\"hljs-literal\">true</span>] = []\nx <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-keyword\">let</span> [y = <span class=\"hljs-literal\">false</span>] = [<span class=\"hljs-number\">1</span>]\ny <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-comment\">// 默认值只在数组成员严格围殴undefined下有效</span>\n</code></div></pre>\n<p>默认值是表达式时，表达式是惰性的，<em>即在右边赋值数组为undefined情况下对应左边位置表达式才会执行</em><br />\n默认值可以是变量，但是此变量必须已经声明</p>\n<h2><a id=\"_62\"></a>对象解构赋值</h2>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> {<span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">\'变量名\'</span>, ...} = obj\n<span class=\"hljs-comment\">// key为obj的key，后面接要声明的变量名</span>\n</code></div></pre>\n<p>其他与数组相似</p>\n<h2><a id=\"_68\"></a>字符串解构赋值</h2>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">const</span> [a, b, c, d, e] = <span class=\"hljs-string\">\'hello\'</span>;\na <span class=\"hljs-comment\">// \"h\"</span>\nb <span class=\"hljs-comment\">// \"e\"</span>\nc <span class=\"hljs-comment\">// \"l\"</span>\nd <span class=\"hljs-comment\">// \"l\"</span>\ne <span class=\"hljs-comment\">// \"o\"</span>\n</code></div></pre>\n<h2><a id=\"_78\"></a>用途</h2>\n<h3><a id=\"_79\"></a>交换变量的值</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-number\">2</span>\n[x, y] = [y, x]\n</code></div></pre>\n<h3><a id=\"_85\"></a>取出函数返回的多个值</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n}\n<span class=\"hljs-keyword\">let</span> [a, b, c] = fn()\n</code></div></pre>\n<h3><a id=\"_92\"></a>函数参数的定义</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span> (<span class=\"hljs-params\">[a, b]</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(a, b)\n}\nfn([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]) <span class=\"hljs-comment\">// 1 2</span>\n</code></div></pre>\n<h3><a id=\"JSON_99\"></a>JSON数据</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> jsonData = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\'jack\'</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-string\">\'18\'</span>,\n    <span class=\"hljs-attr\">sex</span>: <span class=\"hljs-string\">\'men\'</span>\n}\n<span class=\"hljs-keyword\">let</span> {name, age, sex} = jsonData\n<span class=\"hljs-built_in\">console</span>.log(name, age, sex) <span class=\"hljs-comment\">// jack 18 man</span>\n</code></div></pre>\n<h3><a id=\"_113\"></a>函数参数的默认值</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">fn ({\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\'bar\'</span>\n} = {}){\n    <span class=\"hljs-comment\">// 前面的对象里面的值表示默认值，后面的对象表示传递进来的参数，只有在后面对象对应key的值为undefined时，默认值才生效</span>\n}\n</code></div></pre>\n<h3><a id=\"map_126\"></a>遍历map结构数据</h3>\n<ul>\n<li>\n<p>键值一起取</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">let</span> mapData = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()\nmapData.set(<span class=\"hljs-string\">\'one\'</span>, <span class=\"hljs-number\">1</span>)\nmapData.set(<span class=\"hljs-string\">\'tow\'</span>, <span class=\"hljs-number\">2</span>)\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> mapData) {\n    <span class=\"hljs-built_in\">console</span>.log(key + <span class=\"hljs-string\">\'is\'</span> + value)\n}\n<span class=\"hljs-comment\">// one is 1 </span>\n<span class=\"hljs-comment\">// tow is 2</span>\n</code></div></pre>\n</li>\n<li>\n<p>键值分开取</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [key] <span class=\"hljs-keyword\">of</span> mapData) {\n    <span class=\"hljs-comment\">// 得到键</span>\n}\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> [, value] <span class=\"hljs-keyword\">of</span> mapData) {\n    <span class=\"hljs-comment\">// 得到值</span>\n}\n</code></div></pre>\n</li>\n</ul>\n<h3><a id=\"_154\"></a>模块引入</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> {moudelA, moudelB} <span class=\"hljs-keyword\">from</span> JSUtils\n</code></div></pre>\n','9,13',NULL),(10,'字符串的扩展和数值的扩展','强大的es6提供了很多便捷的字符串操作和数值操作的扩展，如：ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。等......','2019-08-05 09:35:35','2019-02-18 09:51:21',11,'1','<h1><a id=\"_0\"></a>字符串的扩展和数值的扩展</h1>\n<h2><a id=\"_2\"></a>查找一个字符串是否包含另一个字符串</h2>\n<ul>\n<li>\n<p>indexOf (es5)</p>\n</li>\n<li>\n<p>es6新增三种方法</p>\n<ul>\n<li>\n<p>includes(str, index)</p>\n<p>返回布尔值，表示是否找到了参数字符串。</p>\n<p>第二个参数表示从index位置开始寻找，index表示字符，而不是下标</p>\n</li>\n<li>\n<p>startsWith(str, index)</p>\n<p>返回布尔值，表示参数字符串是否在原字符串的头部。</p>\n<p>第二个参数表示从index位置开始寻找，index表示字符，而不是下标</p>\n</li>\n<li>\n<p>endWith(str, index)</p>\n<p>返回布尔值，表示参数字符串是否在原字符串的尾部。</p>\n<p>第二个参数表示从前index个字符里面找</p>\n</li>\n</ul>\n</li>\n<li>\n<p>repeat()方法返回一个新字符串，表示将原字符串重复n次</p>\n<p>参数如果是小数会取整</p>\n<p>如果是负数或者infinity会报错</p>\n<p>0~-1和NaN等同于0</p>\n<p>参数如果是字符串会先转化为数字</p>\n</li>\n<li>\n<p>padStart、padEnd方法用于补全字符串</p>\n<p>padStart从前面补齐</p>\n<p>padEnd从后面补齐</p>\n<p>如果原字符串超过指定长度，补全不生效</p>\n</li>\n<li>\n<p>Number</p>\n<ul>\n<li>\n<p>isFinite方法判断一个数值是否为无穷</p>\n<p>Number.isFinite(12) // true</p>\n<p>Number.isFinite(NaN) // false</p>\n<p>Number.isFinite(‘34’) // false 注意：在es5中返回true，因为es5该方法会先调用Number（）转换为数值再判断</p>\n<p>…</p>\n<p>只要不是数值类型，isFinite一律返回false</p>\n</li>\n<li>\n<p>isNaN方法用来检查一个值是否为NaN</p>\n<p>Number.isNaN(12) // false</p>\n<p>Number.isNaN(NaN) // true</p>\n<p>Number.isNaN(‘11’) // false</p>\n<p>Number.isNaN(true / 22) // true</p>\n<p>…</p>\n<p>只有参数类型为NaN才返回true，其余都返回false</p>\n</li>\n<li>\n<p>parseInt、parseFloat</p>\n<p>es6将这两个全局方法移至Number对象上，目的是为了减少全局方法，更加模块化</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-built_in\">parseInt</span> === <span class=\"hljs-built_in\">Number</span>.parseInt <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-built_in\">parseFloat</span> === <span class=\"hljs-built_in\">Number</span>.parseFloat <span class=\"hljs-comment\">// true</span>\n</code></div></pre>\n</li>\n<li>\n<p>isInteger方法用来判断一个数是否为整数</p>\n<p>Number.isInteger(22) // true</p>\n<p>Number.isInteger(22.2) // false</p>\n<p>由于js浮点数与整数存储方式是一样的，所以：</p>\n<p>Number.isInteger(22.0) // true</p>\n<p>注意：该方法用于判断精度低的数值有效，对于高精度的数值，该方法不适应，可能会误判</p>\n</li>\n<li>\n<p>Math.trunc()该方法用于返回一个数值的整数部分，去除小数</p>\n<p>Math.trunc(22.2) // 22</p>\n<p>Math.trunc(-22.3) // 22</p>\n<p>对于非数值类型，该方法内部先用Number方法转换为数值，再返回结果</p>\n<p>Math.trunc(‘22.3’) // 22</p>\n<p>Math.trunc(false) // 0</p>\n<p>对于无法转换的值或者空值，该方法返回NaN</p>\n<p>对于没有该方法的环境可以这样部署：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-built_in\">Math</span>.trunc = <span class=\"hljs-built_in\">Math</span>.trunc || <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">num</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> num &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-built_in\">Math</span>.floor(num) : <span class=\"hljs-built_in\">Math</span>.ceil(num)\n}\n</code></div></pre>\n</li>\n<li>\n<p>Math.sign方法是用于区分正数、负数、0、其他值</p>\n<p>正数返回 1</p>\n<p>负数返回-1</p>\n<p>0 返回0</p>\n<p>其他值返回NaN</p>\n<p>该方法先Number方法转换，再判断</p>\n</li>\n<li>\n<p>Math.cbrt方法返回一个数的立方根</p>\n<p>该方法内部先Number转换，再计算</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-built_in\">Math</span>.cbrt = <span class=\"hljs-built_in\">Math</span>.cbrt || <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">num</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-built_in\">Math</span>.prw(<span class=\"hljs-built_in\">Math</span>.abs(num), <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">3</span>)\n    <span class=\"hljs-keyword\">return</span> num &gt; <span class=\"hljs-number\">0</span> ? y : -y\n}\n</code></div></pre>\n</li>\n<li></li>\n</ul>\n</li>\n</ul>\n','13,9',NULL),(11,'md文件转HTML标签','这篇文章是自己瞎鼓捣的，并不是很好的方法，用到了marked，highlight.js npm包，以后持续更新，敬请关注......','2019-06-26 07:29:38','2019-02-18 09:55:45',11,'1','<h1><a id=\"mdhtmlmdToHTML_0\"></a>.md文件转html标签（mdToHTML）</h1>\n<h3><a id=\"_2\"></a>思路</h3>\n<ul>\n<li>后台提供文件选择入口，用户选择.md文件</li>\n<li>读取.md文件内容，用 <a href=\"https://marked.js.org\" target=\"_blank\">marked</a> 工具库把文件内容转化为html标签</li>\n<li>使用 <a href=\"https://highlightjs.org/\" target=\"_blank\">highlight.js</a> 将代码部分，也就是code、pre标签里面的内容部分挂上类名称，存入db</li>\n<li>前台访问取出数据，页面引入/node_modules/highlight.js/style/*.css 选择一个你想要的样式，可在<a href=\"https://highlightjs.org/\" target=\"_blank\">官网</a> 预览效果</li>\n</ul>\n<h3><a id=\"highlightjs__9\"></a>highlight.js 使用小细节</h3>\n<ul>\n<li>该工具包适用于浏览器客户端，如果在node环境下使用会报错，原因是该工具包里面有部分DOM监听事件，比如 <code>addEventListener(\'load\', () =&gt; {...})</code> ，而node环境中不存在DOM和BOM，自然报错。</li>\n<li>如需在node环境下解决该问题：官网中有一句这样的代码<code>&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;</code> 我们只需要在require引入highlight之后，不调用实例的<code>initHighlightingOnLoad()</code> 方法，就可以了，虽然这样工具包的大部分方法都没用了，其实我们用这个工具包的原因就是让code、pre标签有类名，这样你可以直接使用工具包提供的css，也可以自己定制css，就达到了我们美化代码块的目的；当然，如果有其他更好的办法，可以不用理会上面这些，还可以偷偷告诉我…</li>\n</ul>\n<h3><a id=\"_14\"></a>核心代码</h3>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-comment\">// 引入转换工具包</span>\n<span class=\"hljs-keyword\">let</span> marked = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'marked\'</span>)\n<span class=\"hljs-comment\">// 引入类挂载包</span>\n<span class=\"hljs-keyword\">let</span> hljs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'highlight.js\'</span>)\n<span class=\"hljs-comment\">// hljs.initHighlightingOnLoad() 如果在node服务端环境无需调用此方法</span>\n\n<span class=\"hljs-comment\">/**\n* 开始配置转换选项\n*/</span>\nmarked.setOptions({\n    <span class=\"hljs-attr\">highlight</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">code, lang</span>) </span>{\n        <span class=\"hljs-comment\">// 这里用到的api可以在官网找到，可以去看看（我看完之后再补充）</span>\n        <span class=\"hljs-keyword\">if</span> (lang &amp;&amp; hljs.getLanguage(lang)) {\n            <span class=\"hljs-keyword\">return</span> hljs.highlight(lang, code, <span class=\"hljs-literal\">true</span>).value\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> hljs.highlightAuto(code).value\n        }\n    }\n})\n\n<span class=\"hljs-comment\">// data是读取到的.md文件内容，这个方法返回的就是代码块已经挂载好了类名的html标签了</span>\nmarked(data.toString())\n</code></div></pre>\n<p>end…</p>\n','13',NULL),(12,'vue项目笔记','','2019-07-08 03:03:46','2019-02-27 12:49:18',6,'1','<h1><a id=\"vue_0\"></a>vue项目笔记</h1>\n<ul>\n<li>\n<p>Vue.set方法</p>\n<p>set方法只能改变在data里面声明的属性影响视图</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-comment\">// 视图</span>\n&lt;template&gt;{{ spuForm.sortWeight }}&lt;<span class=\"hljs-regexp\">/template&gt;\n\n/</span><span class=\"hljs-regexp\">/ 数据\ndata () {\n    return {\n        spuForm: {\n        	/</span><span class=\"hljs-regexp\">/ 里面的值异步填充\n        }\n    }\n},\n    \n/</span><span class=\"hljs-regexp\">/ 方法\nmethods: {\n    setSortWeight () {\n        /</span><span class=\"hljs-regexp\">/ 该方法改变spuForm内的值\n        this.$set(this.spuForm, \'sortWeight\', newValue) /</span><span class=\"hljs-regexp\">/ 视图不发生改变，但是spuForm里面的数据已经发生改变\n    }	\n}\n</span></code></div></pre>\n<p>如果spuForm里面初始化了sortWeight：</p>\n<p><code>this.$set</code> 和 <code>this.spuForm.sortWeight</code> 直接赋值都有效</p>\n</li>\n</ul>\n','6',NULL),(13,'nx-admin 一个Vue自动化管理系统','nx-admin 是一个开源的管理系统前端集成方案，它基于 vue 和 element。学习了它的源码，理解了原理，使用vue做一般基本的后台管理系统不会有太大的问题；它使用了最新的前端技术栈，内置了i18国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。最大程度上帮助个人，企业节省时间成本和费用开支。','2019-07-10 08:55:30','2019-03-12 06:40:08',24,'2','<h1><a id=\"nxadmin_Vue_0\"></a>nx-admin 一个Vue自动化管理系统</h1>\n<h2><a id=\"_2\"></a>简介</h2>\n<p>nx-admin是一个后台管理系统，基于vue和element，内置了很多具体的业务需求，包括有i18国际化解决方案、动态权限路由、图表数据可视化、富文本编辑器等，对我来说这是一套后台管理系统的模板比较合适，或许怎么使用这个库是其次的，我们主要来看他的源码，这就像 <strong>”鱼“</strong> 和 <strong>”渔“</strong> 的道理，只要明白的怎么实现该系统的原理，一通百通。</p>\n<ul>\n<li><a href=\"https://github.com/mgbq/nx-admin\" target=\"_blank\">github地址</a></li>\n<li><a href=\"https://mgbq.github.io/vue-permission\" target=\"_blank\">线上演示地址</a></li>\n</ul>\n<h2><a id=\"_9\"></a>计划&amp;目标</h2>\n<p>nx-admin提供了很多的功能，最最值得学习的我认为有以下几个：</p>\n<ul>\n<li>动态菜单(权限控制)</li>\n<li>vuex</li>\n<li>…</li>\n</ul>\n<h2><a id=\"_17\"></a>开始</h2>\n<h3><a id=\"_19\"></a>目录结构</h3>\n<p>|-- build		(webpack打包配置)<br />\n|-- config	(webpack运行打包配置)<br />\n|-- github<br />\n|-- src		核心<br />\n​	|-- api	项目所有网络请求<br />\n​	|-- assets 静态文件<br />\n​	|-- components	封装的组件(比较细小的组件：backToTop按钮、全屏按钮…)<br />\n​	|-- config	项目配置(开发环境，生产环境…)<br />\n​	|-- const		网站全局数据<br />\n​	|-- directive<br />\n​	|-- filters	vue过滤器<br />\n​	|-- global	全局主题样式相关<br />\n​	|-- icons 	导出所有svg图标<br />\n​	|-- lang 		国际化相关<br />\n​	|-- mock		模拟网络请求(main.js入口文件中引入，自动拦截Ajax请求，返回数据)<br />\n​	|-- router 	路由相关<br />\n​	|-- store		vuex状态管理<br />\n​	|-- style 		scss样式<br />\n​	|-- utils 		提取出来的工具方法<br />\n​	|-- vendor	excel表格、zip压缩文件功能相关<br />\n​	|-- views		大模块组件，我们所看到的页面<br />\n|-- static		静态文件</p>\n<h3><a id=\"addRouters_44\"></a>动态路由(addRouters)</h3>\n<p>核心文件</p>\n<ul>\n<li>src/router/index.js	基础文件，所有页面路由信息</li>\n<li>src/permission.js	   路由拦截</li>\n<li>src/store/modules/permission.js    路由表保存</li>\n</ul>\n<h4><a id=\"_routerindexjs_52\"></a>基础文件 /router/index.js</h4>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-comment\">// index.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> constantRouterMap = [\n    <span class=\"hljs-comment\">// 不需要权限就可以访问的页面的路由信息</span>\n]\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">new</span> Router({\n    <span class=\"hljs-attr\">routers</span>: constantRouterMap <span class=\"hljs-comment\">// 直接挂载不需要权限的页面</span>\n})\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> asyncRouterMap = [\n    <span class=\"hljs-comment\">// 存放需要权限访问页面，路由元信息 meta 对象中的 roles 表示可以访问本页面的角色</span>\n]\n</code></div></pre>\n<h4><a id=\"_srcpermissionjs_69\"></a>路由拦截 src/permission.js</h4>\n<p>这个文件我们看他的结构，主要是 router.beforeEach() 路由跳转之前做的一些条件判断</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">router.beforeEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> {\n    <span class=\"hljs-comment\">// 路由跳转即触发，第一次进入网站，也就是登录页面也会触发，即这时候不存在token</span>\n    <span class=\"hljs-comment\">// 用户登录成功之后，commit提交状态，保存token，再跳转：this.$router.push({ path: \'/dashboard/dashboard\' })，再次触发beforeEach方法，这时有token，进入if</span>\n    <span class=\"hljs-keyword\">if</span> (hasToKen) {\n        <span class=\"hljs-comment\">// 有token 已经登录</span>\n        <span class=\"hljs-comment\">// token是保存在cookie里面的，用户登录之后会保存token在cookie和vuex里面</span>\n        <span class=\"hljs-keyword\">if</span> (isLock) {\n            <span class=\"hljs-comment\">// 页面已经锁住，无论用户想跳转到哪个页面都重定向到lock页面</span>\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (toLogin) {\n            <span class=\"hljs-comment\">// 已经登录再跳转到login，重定向到首页</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 跳转到正常页面，首次登录跳转到首页，这时vuex中还没有用户信息</span>\n            <span class=\"hljs-keyword\">if</span> (roles === <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-comment\">// vuex中没有用户信息</span>\n                <span class=\"hljs-comment\">// 通过dispatch方法触发GetInfo获取用户信息</span>\n                <span class=\"hljs-comment\">// 保存用户信息 commit(\'SET_ROLES\', data.roles)</span>\n                <span class=\"hljs-comment\">// 获取用户角色之后，再次使用dispatch方法调用GenerateRoutes方法生成对应用户角色的路由表，保存再vuex中，此时首页还没有渲染，也就是侧边菜单栏还没有出来，有了路由表，我们就可以动态渲染出侧边菜单栏了</span>\n                <span class=\"hljs-comment\">// 根据用户角色，调用addRouters方法，加入用户可访问的页面</span>\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-comment\">// 动态改变权限的附加需求...</span>\n                <span class=\"hljs-comment\">// 切换admin，editor，路由跳转的时候需要检测router.mate.roles 与用户角色是否匹配，如果不匹配就跳转到401页面，无访问权限</span>\n            }\n        }\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 没有token</span>\n        <span class=\"hljs-keyword\">if</span> (inWhiteList) {\n            <span class=\"hljs-comment\">// 在不重定向白名单里面，即不用登录也能访问页面的路由path</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 不在白名单里面，没有登录不能访问，跳转到login页面，让用户登录</span>\n        }\n    }\n})\n</code></div></pre>\n<p>路由拦截逻辑结构大概就是这样，其中最核心的是生成路由表的方法GenerateRoutes，这个方法在vuex保存路由表的逻辑里面，也就是下一节…</p>\n<h4><a id=\"_storemodulespermissionjs_110\"></a>路由表生成和保存 store/modules/permission.js</h4>\n<p>这个文件，我们按顺序解读</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-comment\">// 首先，引入了基础文件，也就是所有的路由信息，游客页面和权限页面都有</span>\n<span class=\"hljs-keyword\">import</span> { asyncRouterMap, constantRouterMap } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'@/router\'</span> <span class=\"hljs-comment\">// 变量结构赋值</span>\n</code></div></pre>\n<p>声明两个方法</p>\n<ul>\n<li>hasPermission 判断该具体的一项路由规则是否匹配role，如果匹配放回true，否则返回false；<strong>注意：</strong> 如果这项路由规则没有meta 路由元信息，也返回true；这是防止在一个一级菜单下面有多个二级菜单，这些二级菜单有的是权限页面有的不是，不是权限页面的就不带meta 或者 meta.roles = undefind</li>\n<li>filterAsyncRouter 递归过滤异步路由表，返回符合用户角色权限的路由表；该方法接收两个参数，路由表(数组)、用户角色(数组)，遍历路由表，调用hasPermission方法，把遍历的路由项和用户角色数组传进去，如果路由项包含子路由，递归调用，过滤完成就生成了权限路由表；(真香警告！！！算法真好用…)</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-comment\">// 这里把hasPermission 方法和filterAsyncRouter 方法整合，更好理解，当然代码不美观...</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">filterAsyncRouter</span> (<span class=\"hljs-params\">routerArray, roles</span>) </span>{\n    <span class=\"hljs-comment\">// Array.prototype.filter 方法过滤数组，返回符合条件的项组成的新数组，不会改变原数组</span>\n    <span class=\"hljs-keyword\">const</span> addRouters = routerArray.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> {\n        <span class=\"hljs-comment\">// 判断当前遍历到的路由项是否有mate 或者 mate.roles</span>\n        <span class=\"hljs-keyword\">if</span> (route.mate &amp;&amp; route.mate.roles) {\n            <span class=\"hljs-comment\">// 是权限路由，判断用户角色能不能访问</span>\n            <span class=\"hljs-comment\">// Array.prototype.some 方法判断数组中是否有满足条件的项，有一项即以上放回true</span>\n            <span class=\"hljs-comment\">// 循环用户角色，判断是否存在当前路由项可以访问的角色数组中</span>\n            <span class=\"hljs-keyword\">if</span> (roles.some(<span class=\"hljs-function\"><span class=\"hljs-params\">role</span> =&gt;</span> { route.mate.roles.indexOf(role) &gt;= <span class=\"hljs-number\">0</span> })) {\n                <span class=\"hljs-comment\">// 存在，再次判断，当前路由项有没有子路由，递归调用</span>\n                <span class=\"hljs-keyword\">if</span> (route.children &amp;&amp; route.children.length) {\n                    <span class=\"hljs-comment\">// 存在子路由，把子路由当作第一个参数</span>\n                    router.children = filterAsyncRouter (router.children, roles)\n                }\n                <span class=\"hljs-comment\">// 忽略上一步判断子路由，确定当前路由项已匹配用户角色，返回true</span>\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-comment\">// 没有匹配成功，返回false</span>\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n            }\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 不是权限路由，可能是一个一级菜单下面二级菜单既有权限页面也有游客页面</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n        }\n    })\n    <span class=\"hljs-comment\">// 遍历完成，返回得到的权限路由</span>\n    <span class=\"hljs-keyword\">return</span> addRouters\n}\n\n<span class=\"hljs-comment\">// permission</span>\n{\n    <span class=\"hljs-attr\">state</span>: {\n        <span class=\"hljs-attr\">routers</span>: constantRouterMap; <span class=\"hljs-comment\">// 用户完整路由表，初始化为不用权限路由项</span>\n        addRouters: [] <span class=\"hljs-comment\">// 根据用户角色异步添加的路由项</span>\n    },\n    <span class=\"hljs-attr\">mutations</span>: {\n        <span class=\"hljs-comment\">// commit 修改state；commit(\'SET_ROUTERS\', params)</span>\n        SET_ROUTERS: <span class=\"hljs-function\">(<span class=\"hljs-params\">state, routers</span>) =&gt;</span> {\n            state.addRouters = routers <span class=\"hljs-comment\">// 修改异步添加路由项的状态</span>\n            <span class=\"hljs-comment\">// 往完整路由添加权限路由，添加之前完整路由就是不用权限的路由</span>\n            state.routers = constantRouterMap.concat(routers)\n        }\n	},\n    <span class=\"hljs-attr\">actions</span>: {\n        <span class=\"hljs-comment\">// 核心方法</span>\n        GenerateRoutes ({ commit }, data) {\n            <span class=\"hljs-comment\">// data就是获取用户信息之后传过来的用户角色数组</span>\n            <span class=\"hljs-keyword\">if</span> (admin) {\n                <span class=\"hljs-comment\">// 如果用户是管理员，最大权限，addRouters 就是全部异步路由</span>\n                addRouter = asyncRouterMap\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-comment\">// 用户不是管理员，调用filterAsyncRouter ，把全部异步路由项和用户角色数组传进去，得到addRouters</span>\n                addRouters = filterAsyncRouter(asyncRouterMap, roles)\n            }\n            <span class=\"hljs-comment\">// 最后commit 改变状态，得到完整路由表</span>\n            commit(<span class=\"hljs-string\">\'SET_ROUTERS\'</span>, addRouters)\n        }\n    }\n}\n</code></div></pre>\n<h4><a id=\"_187\"></a>权限路由总结</h4>\n<p>这里过一遍实现流程</p>\n<ol>\n<li>定义同步路由表，即登录之后即可访问页面；定义异步路由表，即权限页面</li>\n<li>用户登录成功，保存token，跳转首页，获取用户信息，这时页面还未渲染</li>\n<li>获取到了用户角色，通过递归算法过滤比对用户角色对应的可以访问的权限页面，得到完整路由表，保存起来，首页再根据路由表渲染菜单</li>\n</ol>\n<h4><a id=\"_195\"></a>菜单渲染小细节</h4>\n<p>核心文件 <strong>src/views/layout/components/Sidebar/SidebarItem</strong></p>\n<p>父组件调用核心组件的时候把路由表传递过来了：</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- permission_routers是从vuex中获取的 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sidebar-item</span> <span class=\"hljs-attr\">:routes</span>=<span class=\"hljs-string\">\"permission_routers\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sidebar-item</span>&gt;</span>\n</code></div></pre>\n<p>页面结构</p>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-comment\">&lt;!-- 首先判断当前路由项是不是要显示的 --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- 没有子路由，即对应一个页面 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\'\'</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 有子路由 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-submenu</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n	<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\'title\'</span>&gt;</span>一级菜单标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- v-for遍历出二级菜单 --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\'\'</span>&gt;</span>\n    	<span class=\"hljs-comment\">&lt;!-- 判断该二级菜单下面是否还有三级菜单，如果有调用组件本身，把该二级菜单用数组包裹再传入组件，可以理解为组件的递归引用 --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sidebar-item</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\'hasChildren\'</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sidebar-item</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">v-else</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-submenu</span>&gt;</span>\n</code></div></pre>\n','2,13,9',NULL),(39,'一级标题ss','描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字','2019-07-10 09:41:14','2019-07-10 08:17:28',1,'1','<p>描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字描述文字</p>\n','1,2,5',NULL),(195,'canvas转base64/jpeg时，透明区域变成黑色背景的解决方案','\n\n            <h2>问题：png图片转jpeg时，透明区域被填充成黑色</h2>\n<p>在用canvas将png图片转jpeg时，发现透明区域被填充成黑色。</p>\n<p>代码如下：</p>\n<pre><code><p>Canvas：</p>\n<canvas id=\"canvas\" style=\"border: 1px solid #ccc;\"></canvas>\n<br>\n<p>Base64转码后的图片：</p>\n</code></pre>…\n        ','2019-07-10 08:59:00','0000-00-00 00:00:00',1,'1','\n\n            <h2><a id=\"_4\"></a>问题：png图片转jpeg时，透明区域被填充成黑色</h2>\n<p>在用canvas将png图片转jpeg时，发现透明区域被填充成黑色。</p>\n<p>代码如下：</p>\n<pre><code><p>Canvas：</p>\n<canvas id=\"canvas\" style=\"border: 1px solid #ccc;\"></canvas>\n<br>\n<p>Base64转码后的图片：</p>\n<div id=\"base64Img\"></div>\n\n<script type=\"text/javascript\">\n    var base64Img = document.getElementById(\"base64Img\"),\n        canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\");\n\n    // 创建新图片\n    var img = new Image();\n    img.src = \"1.png\";\n\n    img.addEventListener(\"load\", function() {\n        // 绘制图片到canvas上\n        canvas.width = img.width;\n        canvas.height = img.height;\n\n        context.drawImage(img, 0, 0);\n\n        getBase64(canvas, function(dataUrl) {\n            // 展示base64位的图片\n            var newImg = document.createElement(\"img\");\n                newImg.src = dataUrl;\n\n            base64Img.appendChild(newImg);\n        });\n    }, false);\n\n    // 获取canvas的base64图片的dataURL（图片格式为image/jpeg）\n    function getBase64(canvas, callback) {\n        var dataURL = canvas.toDataURL(\"image/jpeg\");\n\n        if(typeof callback !== undefined) {\n            callback(dataURL);\n        }\n    }\n</script>\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/87nbf0h7k9c3f9rsi6cf3kt4/image_1auqahabtgfskk6sh8mihml312.png\" alt=\"image_1auqahabtgfskk6sh8mihml312.png-54.9kB\"></p>\n<p>为什么canvas会png的透明区域转成黑色呢？</p>\n<p><strong>canvas转换成jpeg之前移除alpha通道，所以透明区域被填充成了黑色。</strong></p>\n<p>但是，我们希望的是，canvas可以将png的透明区域填充成白色。</p>\n<p>那么怎么将canvas中的透明区域填充成白色呢？</p>\n<p>以下是我实践过的两种解决方案，希望对你有帮助。</p>\n<h2><a id=\"_5\"></a>解决方案一：将透明的pixel设成白色</h2>\n<p>因为png图片的背景都是透明的，所以我们可以寻找透明的pixel，然后将其全部设置成白色，核心代码如下：</p>\n<pre><code>// 将canvas的透明背景设置成白色\nvar imageData = context.getImageData(0, 0, canvas.width, canvas.height);\nfor(var i = 0; i < imageData.data.length; i += 4) {\n    // 当该像素是透明的，则设置成白色\n    if(imageData.data[i + 3] == 0) {\n        imageData.data[i] = 255;\n        imageData.data[i + 1] = 255;\n        imageData.data[i + 2] = 255;\n        imageData.data[i + 3] = 255; \n    }\n}\ncontext.putImageData(imageData, 0, 0);\n</code></pre>\n<p>完整代码如下：</p>\n<pre><code><p>Canvas：</p>\n<canvas id=\"canvas\" style=\"border: 1px solid #ccc;\"></canvas>\n<br>\n<p>Base64转码后的图片：</p>\n<div id=\"base64Img\"></div>\n\n<script type=\"text/javascript\">\n    var base64Img = document.getElementById(\"base64Img\"),\n        canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\");\n\n    // 创建新图片\n    var img = new Image();\n    img.src = \"1.png\";\n\n    img.addEventListener(\"load\", function() {\n        // 绘制图片到canvas上\n        canvas.width = img.width;\n        canvas.height = img.height;\n\n        context.drawImage(img, 0, 0);\n\n        // 将canvas的透明背景设置成白色\n        var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n        for(var i = 0; i < imageData.data.length; i += 4) {\n            // 当该像素是透明的，则设置成白色\n            if(imageData.data[i + 3] == 0) {\n                imageData.data[i] = 255;\n                imageData.data[i + 1] = 255;\n                imageData.data[i + 2] = 255;\n                imageData.data[i + 3] = 255; \n            }\n        }\n        context.putImageData(imageData, 0, 0);\n\n        // 展示base64位的图片\n        getBase64(canvas, function(dataUrl) {\n            var newImg = document.createElement(\"img\");\n                newImg.src = dataUrl;\n\n            base64Img.appendChild(newImg);\n        });\n    }, false);\n\n    // 获取canvas的base64图片的dataURL（图片格式为image/jpeg）\n    function getBase64(canvas, callback) {\n        var dataURL = canvas.toDataURL(\"image/jpeg\");\n\n        if(typeof callback !== undefined) {\n            callback(dataURL);\n        }\n    }\n</script>\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/9d9zgfld1e0gfct8bascn5ox/image_1auqau6jo18t3ffd15mr1h92s491f.png\" alt=\"image_1auqau6jo18t3ffd15mr1h92s491f.png-63.3kB\"></p>\n<p>缺点显而易见。当png图片上存在半透明区域时，会将其填充为黑色。这是我们不希望的。</p>\n<h2><a id=\"_6\"></a>解决方案二：在canvas绘制前填充白色背景</h2>\n<p>核心代码如下：</p>\n<pre><code>// 在canvas绘制前填充白色背景\ncontext.fillStyle = \"#fff\";\ncontext.fillRect(0, 0, canvas.width, canvas.height);\n</code></pre>\n<p>完整代码如下：</p>\n<pre><code><p>Canvas：</p>\n<canvas id=\"canvas\" style=\"border: 1px solid #ccc;\"></canvas>\n<br>\n<p>Base64转码后的图片：</p>\n<div id=\"base64Img\"></div>\n\n<script type=\"text/javascript\">\n    var base64Img = document.getElementById(\"base64Img\"),\n        canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\");\n\n    // 创建新图片\n    var img = new Image();\n    img.src = \"1.png\";\n\n    img.addEventListener(\"load\", function() {\n        // 绘制图片到canvas上\n        canvas.width = img.width;\n        canvas.height = img.height;\n\n        // 在canvas绘制前填充白色背景\n        context.fillStyle = \"#fff\";\n        context.fillRect(0, 0, canvas.width, canvas.height);\n\n        context.drawImage(img, 0, 0);\n\n        // 展示base64位的图片\n        getBase64(canvas, function(dataUrl) {\n            var newImg = document.createElement(\"img\");\n                newImg.src = dataUrl;\n\n            base64Img.appendChild(newImg);\n        });\n    }, false);\n\n    // 获取canvas的base64图片的dataURL（图片格式为image/jpeg）\n    function getBase64(canvas, callback) {\n        var dataURL = canvas.toDataURL(\"image/jpeg\");\n\n        if(typeof callback !== undefined) {\n            callback(dataURL);\n        }\n    }\n</script>\n</code></pre>\n<p>效果如下：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/xrnuwk5e3da0mmj2rui0mlso/image_1auqbl0ogbai71dted1ui3gcv1s.png\" alt=\"image_1auqbl0ogbai71dted1ui3gcv1s.png-59kB\"></p>\n<p>Perfect！</p>\n<p>显然，在canvas绘制前填充白色背景这种方法，不仅简单，而且对png图片的半透明区域填充难看的黑色块。<strong>推荐这种解决方案。</strong></p>\n<p>另：canvas.toDataURL()方法不允许处理跨域图片。否则会报错。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/1096\">http://www.dengzhr.com/frontend/html/1096</a></div>\n\n        ','2','1'),(196,'JavaScript中的函数节流','\n\n            <h2>一. 背景</h2>\n<p>在一些场景下，函数有可能会被频繁地调用，而这些函数本身占用的内存或计算较大时，就可能造成大的性能问题。譬如以下场景：</p>\n<ul>\n<li>window.onresize事件。window.onresize事件在浏览器窗口大小改变时被触发，而且浏览器每改变1px，该事件就被触发一次，触发</li></ul>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 背景</h2>\n<p>在一些场景下，函数有可能会被频繁地调用，而这些函数本身占用的内存或计算较大时，就可能造成大的性能问题。譬如以下场景：</p>\n<ul>\n<li>window.onresize事件。window.onresize事件在浏览器窗口大小改变时被触发，而且浏览器每改变1px，该事件就被触发一次，触发的频率非常的高。如果在window.onresize事件中涉及到一些DOM节点相关的操作时，而DOM操作往往是非常耗内存的，这时浏览器有可能出现卡顿甚至崩溃的情况。</li>\n<li>mousemove事件。如果给一个div元素上绑定了mousemove事件，当在该div上移动鼠标时，也会频频触发该mousemove事件函数。</li>\n<li>window.onscroll事件。window.onscroll事件会在页面滚动时被触发，而且页面每滚动1px都会触发一次，触发的频率也非常高。</li>\n<li>change事件。用户在input和textarea元素中每次改变value值都会触发change事件。当用户输入较快时，而change事件函数可能涉及到DOM操作等耗内存的操作时，则可能导致卡顿问题。</li>\n<li>… …</li>\n</ul>\n<p>而实际上，我们并不需要那么频繁地触发这些事件函数，只要能确保比较流畅的用户体验即可。</p>\n<p>譬如拖拽浏览器窗口改变其大小时，window.onresize事件函数可能被触发了100次，而实际上我们只需要3、4次就可以达到比较流畅的用户体验。这就需要我们使用函数节流，按时间段来忽略一些事件请求，这个可以借助setTimeout函数来实现。</p>\n<p>所以，函数节流需要做的是<strong>降低触发回调的频率</strong>。</p>\n<h2><a id=\"_5\"></a>二. 函数节流的原理</h2>\n<p>函数节流的原理是，<strong>将即将被执行的函数用setTimeout延迟一段时间后才执行</strong>。如果该次言辞执行还没有完成，则忽略接下来调用该函数的请求。</p>\n<h2><a id=\"_6\"></a>三. 函数节流的代码实现</h2>\n<pre><code>/*\n * 节流函数\n * @param {Function} fn 需要进行节流的函数\n * @param {Int} delay 函数执行的时间间隔。默认值为500\n */\nvar throttle = function(fn, delay) {\n    var _self = fn, // 保存需要被延迟执行的函数引用\n        timer = null, // 定时器\n        firstTime = true; // 是否是第一次调用\n\n    return function() {\n        var args = arguments,\n            _this = this,\n            delay = delay || 500;\n\n            // 如果是第一次调用，不需要延迟执行\n            if(firstTime) {\n                _self.apply(_this, args);\n                firstTime = false;\n                return;\n            }\n\n            if(timer) {\n                return false;\n            }\n\n            // 延迟一段时间执行\n            timer = setTimeout(function() {\n                // 清除调原来的定时器\n                clearTimeout(timer);\n                timer = null;\n\n                _self.apply(_this, args);\n            }, delay);\n    };\n}\n</code></pre>\n<pre><code>/* =============== 客户端调用 =============== */\nwindow.onresize = throttle(function() {\n    console.log(\"Window is resizeing.\");\n}, 200);\n</code></pre>\n<h2><a id=\"_7\"></a>四. 总结</h2>\n<p>函数节流适合于需要频繁调用，但又在一定的时间内必须要执行逻辑的场景。</p>\n<p>巧用函数节流方式能够显著得提高页面性能以及交互体验，而函数的节流频率还有待在实际项目中多调试才能获得最优值。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1166\">http://www.dengzhr.com/js/1166</a></div>\n\n        ','2','1'),(197,'【实战】HTML5摄像头拍照组件的封装','\n\n            <p>摄像头调用主要使用了navigator.getUserMedia()函数。为了将摄像头的画像实时展现，可以将录像数据流导入到video或者canvas中。在展示的时候，建议使用video作为视频流容易，因为canvas绘画视频帧时存在一定的卡顿。<br>\n在像素数据分析和将画像转成图片，则应将视频流导到canvas中，使用canvas API中进行数据提取。</p>\n<p>在这里，我使用了一个隐藏�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>摄像头调用主要使用了navigator.getUserMedia()函数。为了将摄像头的画像实时展现，可以将录像数据流导入到video或者canvas中。在展示的时候，建议使用video作为视频流容易，因为canvas绘画视频帧时存在一定的卡顿。<br>\n在像素数据分析和将画像转成图片，则应将视频流导到canvas中，使用canvas API中进行数据提取。</p>\n<p>在这里，我使用了一个隐藏起来的canvas，对视频流的关键帧数据进行收集。</p>\n<p>详看以下代码：</p>\n<p>组件代码：</p>\n<pre><code>/**\n * 组件：调用摄像头拍摄的构造函数\n * @params {Object} options 参数如下：\n *         video  {DOM} video元素\n *         width  {Number} 画布宽度\n *         height  {Number} 画布高度\n *         onShoot  {Function} 录像回调函数\n *         onError  {Function} error回调函数\n * 调用：\n *     Camera.create(options);\n */\nfunction Camera(options) {\n    this.video = options.video;\n    this.width = options.width || 640;\n    this.height = options.height || 480;\n    this.onError = options.onError;\n    this.onShoot = options.onShoot;\n}\n\nCamera.prototype = {\n    init: function() {\n        navigator.getUserMedia = navigator.getUserMedia ||\n            navigator.webkitGetUserMedia ||\n            navigator.mozGetUserMedia ||\n            navigator.msGetUserMedia;//获取媒体对象\n        window.requestAnimFrame = (function(){\n          return  window.requestAnimationFrame       ||\n                  window.webkitRequestAnimationFrame ||\n                  window.mozRequestAnimationFrame    ||\n                  function( callback ){\n                    window.setTimeout(callback, 1000 / 60);\n                  };\n        })();\n        this.video.autoplay = \'ture\';\n        this.canvasDom = document.createElement(\'canvas\');\n        this.canvasDom.width = this.width;\n        this.canvasDom.height = this.height;\n        this.canvasDom.style.display = \'none\';\n        document.querySelector(\'body\').appendChild(this.canvasDom);\n    },\n\n    // 检查摄像头是否可用\n    canCameraUse: function() {\n        return (navigator.getUserMedia && window.URL);\n    },\n\n    // 获取录像流到video中\n    shoot: function() {\n        var self = this;\n        var video = self.video;\n        if(self.canCameraUse) {\n            navigator.getUserMedia(\n                {video:true},\n                function (stream) {\n                    video.src = URL.createObjectURL(stream);\n                    video.play();\n                    video.addEventListener(\'error\', function(error) {\n                        stream.stop();\n                        self.onError && self.onError(error);\n                    }, false);\n                },\n                function (error) {\n                    self.onError && self.onError(error);\n                }\n            );\n        }\n    },\n\n    // 将录像绘制到canvas\n    drawVideo: function() {\n        var canvasDom = this.canvasDom;\n        var ctx = canvasDom.getContext(\'2d\');\n        ctx.fillStyle = \"#000000\";\n        ctx.fillRect(0, 0, canvasDom.width, canvasDom.height);\n        ctx.drawImage(this.video, 0, 0, canvasDom.width, canvasDom.height);\n    },\n\n    // 录像事件绑定\n    addShootEvent: function() {\n        var self = this;\n        var video = self.video;\n        // 正在录像\n        video.addEventListener(\'play\', function() {\n            function animation() {\n                self.drawVideo();\n                self.onShoot && self.onShoot();\n                window.requestAnimationFrame(animation);\n            }\n        }, false);\n    },\n\n    // 将录像成图片\n    snapshot: function(cb, imageType) {\n        var self = this;\n        var video = self.video;\n        var canvas = self.canvasDom;\n        var ctx = canvas.getContext(\'2d\');\n        imageType = imageType || \'png\';\n        imageSrc = canvas.toDataURL(\'image/\' + imageType);\n        cb && cb(imageSrc);\n    },\n\n    // 开始录像\n    play: function() {\n        this.video.play();\n    },\n\n    // 停止录像\n    pause: function() {\n        this.video.pause();\n    },\n\n    render: function() {\n        this.init();\n        this.shoot();\n        this.drawVideo();\n        this.addShootEvent();\n    }\n};\n\nCamera.create = function(options) {\n    var camera = new Camera(options);\n    camera.render();\n    return camera;\n};\n</code></pre>\n<p>调用：</p>\n<pre><code><!-- HTML -->\n<video id=\'video\'></video>\n<div>\n    <button id=\'shootBtn\'>拍照</button>\n</div>\n<div id=\'imageBox\'></div>\n\n\n<!-- JS -->\n<script>\n    var camera = Camera.create({\n        video: document.querySelector(\'#video\'),\n        width: 640,\n        height: 480,\n        onError: function(error) {\n            alert(error);\n        }\n    });\n\n    // 拍照\n    document.querySelector(\'#shootBtn\').addEventListener(\'click\', function() {\n        camera.snapshot(function(imageUrl) {\n            var imageBox = document.querySelector(\'#imageBox\');\n            var image = imageBox.querySelector(\'img\');\n            if(!image) {\n                var image = document.createElement(\'img\');\n                image.src = imageUrl;\n                document.querySelector(\'#imageBox\').appendChild(image);\n            } else {\n                image.src = imageUrl;\n            }\n        });\n    }, false);\n</script>\n</code></pre>\n<p>效果如下：</p>\n<p><iframe height=\"300\" scrolling=\"no\" title=\"qrEzmV\" src=\"//codepen.io/dengzhirong8344/embed/qrEzmV/?height=300&theme-id=15300&default-tab=result&embed-version=2\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong8344/pen/qrEzmV/\'>qrEzmV</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong8344\'>@dengzhirong8344</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/1335\">http://www.dengzhr.com/frontend/html/1335</a></div>\n\n        ','2','1'),(198,'原生JS：无刷新表单的兼容性封装（IE6+）','\n\n            <p>在做form表单提交的时候，都会遇到一个非常尴尬的事情：<strong>就是浏览器默认的submit功能竟然会刷新当前页面，并跳转至action链接</strong>。</p>\n<p>这(“▔□▔) Σ<(=~д~=!)> (~▽~”) (~_~|||) – … …</p>\n<p>一般来说，这个action链接都是处理表单并返回一些文本信息的Controller函数，以空白�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在做form表单提交的时候，都会遇到一个非常尴尬的事情：<strong>就是浏览器默认的submit功能竟然会刷新当前页面，并跳转至action链接</strong>。</p>\n<p>这(“▔□▔) Σ<(=~д~=!)> (~▽~”) (~_~|||) – … …</p>\n<p>一般来说，这个action链接都是处理表单并返回一些文本信息的Controller函数，以空白页面居多。如果这个action链接需要以POST请求访问的话，浏览器窗口很可能还会提示服务器错误信息。显然，这不是我们想要的。</p>\n<p>我们大多时候想要的是<strong>无刷新的表单提交</strong>。</p>\n<p>一想到无刷新提交，一般想法是<strong>用Ajax请求模拟表单提交</strong>。如果遇到文件上传的话，可以考虑使用FormData来封装数据。想想就觉得完美。</p>\n<p>用Ajax请求模拟时，要注意是否上传文件。如果上传文件的话，注意请求的Content-Type要设置为<strong>“mutipart/form-data”</strong>。用jQuery的写法如下：</p>\n<pre><code>var formData = new FormData($(\"#form\")[0]);\n$.ajax({\n    url: formUrl,\n    method: \"POST\",\n    cache: false, // 禁用缓存\n    contentType: false, // 防止自动转换content-type为默认的\"application/x-www-form-urlencoded\"\n    processData: false, // 防止自动转换FormData数据\n    data: formData,\n    success: function(data) {\n        // 表单提交成功后的操作\n    }\n});\n</code></pre>\n<p>然而，很不幸的是，FormData是HTML5的新特性，兼容性不好，IE系列浏览器只能支持IE10+。</p>\n<p>其实，无刷新表单提交还有一种很hack的做法：<strong>将form提交后的结果在target指定的iframe里执行。即将form的target属性指向iframe</strong>。具体如下：</p>\n<pre><code><form name=\"form1\" id=\"form1\" method=\"post\" action=\"/test\" target=\"ajaxForm\">\n    <input type=\"file\" name=\"avatar\">\n    <input type=\"submit\" value=\"提交\">\n</form>\n<iframe id=\"ajaxForm\" src=\"about:blank\" style=\"display: none\"></iframe>\n</code></pre>\n<p>将form提交后的结果在target指定的iframe里执行，这种实现方式的兼容性很好，基本没有什么兼容性问题。然而，<code><iframe></code>元素的Web安全性向来为人所诟病，而且在页面里引入了新标签，似乎并不怎么优雅。</p>\n<p>为了能实现IE6+的兼容性，我选择的做法是<strong>优雅降级</strong>，具体如下：</p>\n<blockquote><p>对于支持FormData方法的浏览器，使用<strong>Ajax请求模拟表单提交</strong>； 对于不支持FormData方法的浏览器，则<strong>将form提交后的结果在target指定的iframe里执行</strong>。</p></blockquote>\n<p>封装后的代码如下：（原生JS实现）</p>\n<pre><code>var util = util || {};\n\nutil = {\n    /* ajax请求函数封装 */\n    ajax: function(options) {\n        var __this = this,\n            url = options.url || \"\",\n            method = options.method || \"get\",\n            data = options.data || \"\",\n            dataType = options.dataType || \"text\",\n            successCallback = options.success || new Function(),\n            errorCallback = options.error || new Function();\n        method = method.toUpperCase();\n\n        if(method == \'GET\' && data) {\n            // 拼接query字符串\n            var queryStr = \"\",\n                index = 0;\n            for(var i in data) {\n                queryStr += i + \"=\" + data[i];\n                if(index <= __this.getObjectlength(data) - 1) {\n                    queryStr += \"&\";\n                }\n                index++;\n            }\n            url += (url.indexOf(\'?\') == -1 ? \'?\' : \'&\') + queryStr;\n            data = null;\n        }\n\n        var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\'Microsoft.XMLHTTP\');\n\n        xhr.onreadystatechange = function() {\n            if(xhr.readyState == 4) {\n                var status = xhr.status;\n                if(status >= 200 && status < 300) {\n                    var data = xhr.responseText;\n                    successCallback(data);\n                } else {\n                    errorCallback(xhr);\n                }\n            } else {\n                errorCallback(xhr);\n            }\n        };\n\n        xhr.open(method, url, true);\n\n        if(method === \'POST\'){\n            // 设置content-type\n            var contentType;\n            switch(dataType) {\n                case \"json\":\n                    contentType = \"application/json\";\n                case \"form\":\n                    contentType = \"mutipart/form-data\";\n                default:\n                    contentType = \"application/x-www-form-urlencoded\";\n            }\n            xhr.setRequestHeader(\'Content-type\', contentType);\n        }\n\n        xhr.send(data);\n        return xhr;\n    },\n\n    /* 获取对象长度 */\n    getObjectlength: function(obj) {\n        var len = 0;\n        for(var i in obj) {\n            len++;\n        }\n        return len;\n    }\n};\n\n/* 无刷新提交表单组件 */\nvar AjaxForm = function(form_dom) {\n    this.form_dom = form_dom;\n};\nAjaxForm.ajaxFormCache = []; // 无刷新提交的表单的记录数组\nAjaxForm.prototype = {\n    // 通过ajax请求\n    submitByAjax: function() {\n        var form_dom = this.form_dom,\n            url = form_dom.getAttribute(\"action\"),\n            formData = new FormData(form_dom);\n        util.ajax({\n            url: url,\n            method: \"post\",\n            data: formData,\n            success: function(data) {\n                console.log(\"data: \" + data);\n            }\n        });\n    },\n\n    // 通过将请求指向iframe\n    submitByIframe: function() {\n        var form_dom = this.form_dom,\n            body_dom = document.getElementsByTagName(\"body\")[0],\n            iframe = document.createElement(\"iframe\"),\n            formName = \"ajaxForm\" + AjaxForm.ajaxFormCache.length;\n\n        iframe.setAttribute(\"name\", formName);\n        iframe.setAttribute(\"src\", \"about:blank\");\n        iframe.style.display = \"none\";\n\n        AjaxForm.ajaxFormCache.push(formName);\n\n        body_dom.appendChild(iframe);\n        form_dom.setAttribute(\"target\", formName);\n    },\n\n    init: function() {\n        var __this = this;\n        if(window.FormData) {\n            this.form_dom.addEventListener(\"submit\", function(e) {\n                var event = e || window.event;\n                event.preventDefault || event.preventDefault();\n                __this.submitByAjax();\n                return false;\n            });\n        } else {\n            this.submitByIframe();\n        }\n    }\n};\n\nAjaxForm.init = function(form_dom) {\n    // 创建无刷新表单实例\n    var ajaxForm = new AjaxForm(form_dom);\n    ajaxForm.init();\n    return ajaxForm;\n};\n</code></pre>\n<p>调用实例：</p>\n<p>html：</p>\n<pre><code><form name=\"form1\" id=\"form1\" method=\"post\" action=\"/test\">\n    <input type=\"text\" name=\"username\" value=\"dzr\">\n    <input type=\"file\" name=\"avatar\">\n    <input type=\"submit\" value=\"提交\">\n</form>\n\n<form name=\"form2\" id=\"form2\" method=\"post\" action=\"/test\">\n    <input type=\"text\" name=\"username\" value=\"dzr\">\n    <input type=\"file\" name=\"avatar\">\n    <input type=\"submit\" value=\"提交\">\n</form>\n</code></pre>\n<p>JavaScript：</p>\n<pre><code>var form1 = document.getElementById(\"form1\"),\n    form2 = document.getElementById(\"form2\");\nAjaxForm.init(form1);\nAjaxForm.init(form2);\n</code></pre>\n<p>好的。搞掂。</p>\n<p>亲测可完美兼容IE6+ ~ o(≥v≤)o~</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/1207\">http://www.dengzhr.com/frontend/html/1207</a></div>\n\n        ','2','1'),(199,'【实战】捣鼓一只自定义的video组件(目前只能在Mobile中使用)','\n\n            <p>这是一只只能在Mobile下使用的Video自定义组件。</p>\n<p>为什么只能在Mobile下使用？。。。因为我将鼠标事件都换成了Touch事件。。。等我有空了再添加兼容手势库吧。</p>\n<p>Talk is cheak, show you the code. 直接上代码：</p>\n<h3>JS组件代码：</h3>\n<pre><code>/**\n * video插件Mobile版（只兼容mobile）\n * @params: options对象，属性如下：\n *     ele   {String/jQuery DOM/Javascript</code></pre>…\n        ','2019-07-10 09:01:47','0000-00-00 00:00:00',1,'1','\n\n            <p>这是一只只能在Mobile下使用的Video自定义组件。</p>\n<p>为什么只能在Mobile下使用？。。。因为我将鼠标事件都换成了Touch事件。。。等我有空了再添加兼容手势库吧。</p>\n<p>Talk is cheak, show you the code. 直接上代码：</p>\n<h3><a id=\"_4\"></a>JS组件代码：</h3>\n<pre><code>/**\n * video插件Mobile版（只兼容mobile）\n * @params: options对象，属性如下：\n *     ele   {String/jQuery DOM/Javascript DOM}   video元素（可直接在该元素中定义<video>标签的原生属性，加上\'data-\'前缀）(必选填\n *     controls    {Boolean}    是否带controls\n *     autoplay    {Boolean}    是否自动播放\n *     src    {String}    视频资源地址\n *     preload    {String}    是否预载资源\n\n * @return: \n *    1) 当options.ele仅有一个DOM时，返回new Video()对象；\n *    2) 当options.ele有多个DOM时，返回[new Video(), ...]数组。\n * \n *    备注： new Video()对象的具体属性和方法可以查看以下代码。\n\n * @使用方法：\n *    JS：    Video.create(options);\n *    HTML:    <div class=\"video-box\" data-autoplay=\'true\' data-control=\'true\' data-preload=\'auto\' data-src=\'\'></div>\n */\nvar Video = function(options) {\n    this.videoBox = $(options.ele);\n    this.options = options;\n};\n\nVideo.prototype = {\n    constructor: Video,\n    // 构建DOM\n    init: function() {\n        // 设置videoBox样式\n        this.videoBox.css({position: \'relative\', \'overflow\': \'hidden\'});\n\n        this.video.volume = 1;\n        this.setSlidebarProgress(\'.slidebar-volume\', 1);\n        this.isHideControl = false;\n        this.hideControlTimer = null;\n        this.isPlaying = false;\n        // 自动播放\n        if(this.isAutoPlay === \'true\' || this.hasControl == \'false\') {\n            this.play();\n        } else {\n            this.showControl();\n        }\n    },\n    // duration change\n    durationChange: function() {\n        var _this = this;\n        this.video.addEventListener(\'durationchange\', function() {\n            _this.setProgressTime(_this.video.currentTime, _this.video.duration);\n            _this.setVideoSize();\n        }, false);\n    },\n    // 设置video的宽高\n    setVideoSize: function() {\n        var videoBox = this.videoBox;\n        var videoBoxWidth = videoBox.width();\n        var videoHeight = this.video.videoHeight;\n        var videoWidth = this.video.videoWidth;\n        var videoBoxHeight = videoBoxWidth / videoWidth * videoHeight;\n        videoBox.height(videoBoxHeight);\n    },\n    // 创建video DOM\n    createVideoDom: function() {\n        var _this = this;\n        var videoBox = this.videoBox;\n        var options = this.options;\n        this.hasControl = options.controls || videoBox.attr(\'data-control\');\n        this.isAutoPlay = options.autoplay || videoBox.attr(\'data-autoplay\');\n        this.src = options.src || videoBox.attr(\'data-src\');\n        this.preload = options.preload || videoBox.attr(\'data-preload\');\n        var videoAttr = {\n            src: _this.src,\n            \'webkit-playsinline\': true,\n            playsinline: true,\n            preload: _this.preload\n        };\n        var videoDom = $(\'<video></video>\').attr(videoAttr);\n        this.videoBox.append(videoDom);\n\n        this.video = this.videoBox.find(\'video\')[0];\n    },\n    // 创建control DOM\n    createControlDom: function() {\n        var controlDom = \'<div class=\"video-control\">\'\n                            + \'<div class=\"btn-play video-btn\"></div>\'\n                            + \'<span class=\"text-time\"></span>\'\n                            + \'<div class=\"slidebar slidebar-progress\">\'\n                                + \'<div class=\"btn-thumb\"></div>\'\n                                + \'<div class=\"line-runway\"></div>\'\n                            + \'</div>\'\n                            + \'<div class=\"btn-muted video-btn\"></div>\'\n                            + \'<div class=\"slidebar slidebar-volume\">\'\n                                + \'<div class=\"btn-thumb\"></div>\'\n                                + \'<div class=\"line-runway\"></div>\'\n                            + \'</div>\'\n                            + \'<div class=\"btn-fullpage video-btn\"></div>\'\n                        + \'</div>\';\n\n        this.videoBox.append(controlDom);\n    },\n    // 播放\n    play: function() {\n        if(this.video.paused) {\n            var _this = this;\n            this.video.play();\n            this.isPlaying = true;\n            this.videoBox.find(\'.btn-play\').addClass(\'active\');\n        }\n    },\n    // 暂停\n    pause: function() {\n        if(!this.video.paused) {\n            this.video.pause();\n            this.isPlaying = false;\n            this.videoBox.find(\'.btn-play\').removeClass(\'active\');\n        }\n    },\n    // 显示controls\n    showControl: function(isShowAlways) {\n        var _this = this;\n        if(this.hasControl !==\'false\') {\n            this.isHideControl = false;\n            this.videoBox.find(\'.video-control\').addClass(\'active\');\n        }\n\n        if(_this.hideControlTimer) {\n            clearTimeout(_this.hideControlTimer);\n            _this.hideControlTimer = null;\n        }\n        if(!isShowAlways && this.isPlaying) {\n            this.hideControlTimer = setTimeout(function() {\n                _this.hideControl();\n            }, 2000);\n        }\n    },\n    hideControl: function() {\n        this.isHideControl = true;\n        this.videoBox.find(\'.video-control\').removeClass(\'active\');\n    },\n    // video点击事件绑定\n    videoClickHandler: function() {\n        var _this = this;\n        this.video.addEventListener(\'touchstart\', function() {\n            _this.showControl();\n        }, false);\n\n        this.videoBox.on(\'touchmove\', \'.video-control\', function() {\n            _this.showControl();\n        });\n    },\n    // 播放与暂停事件切换\n    playPause: function() {\n        if(this.video.paused) {\n            this.play();\n        } else {\n            this.pause();\n        }\n    },\n    // 切换静音模式\n    toggleMuted: function() {\n        var _this = this;\n        var video = this.video;\n        this.video.muted = !video.muted;\n        var ratio = 0;\n        var mutedBtn = this.videoBox.find(\'.btn-muted\');\n        if(this.video.muted) {\n            ratio = 0;\n            mutedBtn.addClass(\'active\');\n        } else {\n            var ratio = _this.video.volume || 0;\n            mutedBtn.removeClass(\'active\');\n        }\n        this.setSlidebarProgress(\'.slidebar-volume\', ratio);\n    },\n    // 设置视频播放时间\n    setProgressTime: function(currentTime, duration) {\n        var textTimeDom = this.videoBox.find(\'.text-time\');\n        var duration = duration || this.video.duration;\n        var currentTime = currentTime || 0;\n        var timeString = this.formatTime(currentTime) + \'/\' + this.formatTime(duration);\n        textTimeDom.html(timeString);\n    },\n    // 时间格式化： 00:00\n    formatTime: function(second) {\n        var timeString = \'\';\n        var min = Math.floor(second / 60) || 0;\n        var sec = Math.floor(second % 60) || 0;\n        min = min >= 10 ? min :  \'0\' + min;\n        sec = sec >= 10 ? sec :  \'0\' + sec;\n        timeString = min + \':\' + sec;\n        return timeString;\n    },\n    // 正在播放的事件绑定\n    playing: function() {\n        var _this = this;\n        this.video.addEventListener(\'timeupdate\', function() {\n            var ratio = _this.video.currentTime / _this.video.duration || 0;\n            _this.setSlidebarProgress(\'.slidebar-progress\', ratio);\n            _this.setProgressTime(_this.video.currentTime);\n        }, false);\n    },\n    // slide滑动事件绑定\n    bindEventToSlide: function(slidebarClassName, callbackOpt) {\n        var _this = this;\n        var isTouchStart = false;\n        var slidebar = this.videoBox.find(slidebarClassName);\n        var slidebarThumb = slidebar.find(\'.btn-thumb\');\n        var slidebarThumbWidth = slidebarThumb.width();\n        var slidebarWidth = slidebar.width();\n        var slidebarOffsetLeft = slidebar.offset().left;\n        var ratio;\n        var touchstartCb = callbackOpt.touchstart;\n        var touchmoveCb = callbackOpt.touchmove;\n        var touchendCb = callbackOpt.touchend;\n        var clickCb = callbackOpt.click;\n\n        this.videoBox.on(\'touchstart\', slidebarClassName + \' .btn-thumb\', function(e) {\n            e.preventDefault();\n            // e.stopPropagation();\n            isTouchStart = true;\n            slidebarThumb.addClass(\'active\');\n            if(typeof touchstartCb == \'function\') {\n                touchstartCb();\n            }\n        }).on(\'touchmove\', slidebarClassName + \' .btn-thumb\', function(e) {\n            e.preventDefault();\n            // e.stopPropagation();\n            if(isTouchStart) {\n                var curTouchX = e.touches[0].pageX;\n                ratio = (curTouchX - slidebarOffsetLeft - slidebarThumbWidth / 2) / slidebarWidth;\n                if(ratio >= 1) {\n                    ratio = 1;\n                } else if(ratio <= 0) {\n                    ratio = 0;\n                }\n                _this.setSlidebarProgress(slidebarClassName, ratio);\n\n                if(typeof touchmoveCb == \'function\') {\n                    touchmoveCb(ratio);\n                }\n            }\n        }).on(\'touchend\', slidebarClassName + \' .btn-thumb\', function(e) {\n            e.preventDefault();\n            // e.stopPropagation();\n            if(isTouchStart) {\n                isTouchStart = false;\n                slidebarThumb.removeClass(\'active\');\n\n                if(typeof touchendCb == \'function\') {\n                    touchendCb(ratio);\n                    _this.showControl();\n                }\n            }\n        }).on(\'touchstart\', slidebarClassName, function(e) {\n            e.preventDefault();\n            // e.stopPropagation();\n            var curTouchX = e.touches[0].pageX;\n            ratio = (curTouchX - slidebarOffsetLeft - slidebarThumbWidth / 2) / slidebarWidth;\n            if(ratio >= 1) {\n                ratio = 1;\n            } else if(ratio <= 0) {\n                ratio = 0;\n            }\n            _this.setSlidebarProgress(slidebarClassName, ratio);\n\n            if(typeof clickCb == \'function\') {\n                clickCb(ratio);\n            } else if(touchmoveCb == \'function\') {\n                touchmoveCb(ratio);\n            }\n        });\n    },\n    // 设置进度条显示\n    setSlidebarProgress: function(slidebarClassName, ratio) {\n        var slidebar = this.videoBox.find(slidebarClassName);\n        var slidebarThumb = slidebar.find(\'.btn-thumb\');\n        var slidebarRunway = slidebar.find(\'.line-runway\');\n        var slidebarThumbWidth = slidebarThumb.width();\n        var slidebarWidth = slidebar.width();\n        var slidebarWidthRatio = (slidebarWidth - slidebarThumbWidth / 2) / slidebarWidth;\n\n        var percent = Math.ceil(ratio * slidebarWidthRatio * 100) + \'%\';\n        slidebarThumb.css(\'left\', percent);\n        slidebarRunway.width(percent);\n    },\n    // 播放进度条事件绑定\n    bindEventToProgressSlidebar: function() {\n        var _this = this;\n        this.bindEventToSlide(\'.slidebar-progress\', {\n            touchmove: function(ratio) {\n                _this.video.currentTime = _this.video.duration * ratio || 0;\n                _this.pause();\n            },\n            touchend: function(ratio) {\n                _this.play();\n            },\n            click: function(ratio) {\n                _this.video.currentTime = _this.video.duration * ratio || 0;\n                _this.play();\n            }\n        });\n    },\n    // 音量进度条事件绑定\n    bindEventToVolumeSlidebar: function() {\n        var _this = this;\n        this.bindEventToSlide(\'.slidebar-volume\', {\n            touchmove: function(ratio) {\n                _this.video.volume = ratio || 0;\n            },\n            click: function(ratio) {\n                _this.video.volume = ratio || 0;\n            }\n        });\n    },\n    // 音量变化事件监听\n    volumeChange: function() {\n        var _this = this;\n        var mutedBtn = this.videoBox.find(\'.btn-muted\');\n        this.video.addEventListener(\'volumechange\', function() {\n            if(_this.video.volume == 0 || _this.video.muted) {\n                mutedBtn.addClass(\'active\');\n            } else {\n                mutedBtn.removeClass(\'active\');\n            }\n        }, false);\n    },\n    // 切换全屏\n    toggleFullPage: function() {\n        this.requestFullscreen(this.video);\n    },\n    requestFullscreen: function(element) {\n        if(element.requestFullScreen) {  \n            element.requestFullScreen();\n        } else if(element.mozRequestFullScreen) {  \n            element.mozRequestFullScreen();  \n        } else if(element.webkitRequestFullScreen) {  \n            element.webkitRequestFullScreen();  \n        }\n    },\n    // 创建DOM\n    createDom: function() {\n        this.createVideoDom();\n        this.createControlDom();\n    },\n    // 绑定事件到control\n    bindEventToControl: function() {\n        var _this = this;\n        // 播放 / 暂停\n        this.videoBox.on(\'touchstart\', \'.btn-play\', function(e) {\n            e.stopPropagation();\n            e.preventDefault();\n            _this.playPause();\n            if(_this.isPlaying) {\n                _this.showControl();\n            } else {\n                _this.showControl(true);\n            }\n        });\n\n        // 静音\n        this.videoBox.on(\'touchstart\', \'.btn-muted\', function() {\n            _this.toggleMuted();\n        });\n\n        // 全屏\n        this.videoBox.on(\'touchstart\', \'.btn-fullpage\', function() {\n            _this.toggleFullPage();\n        });\n\n        this.durationChange(); // 总时间 change\n        this.volumeChange(); // 音量 change\n        this.bindEventToProgressSlidebar(); // 进度条slide change\n        this.bindEventToVolumeSlidebar(); // 音量slide change\n        this.videoClickHandler(); // video点击事件\n        this.playing(); // 正在播放的事件监听\n    },\n    render: function() {\n        this.createDom();\n        this.init();\n        this.bindEventToControl();\n    }\n};\n\n// 创建Video对象\nVideo.create = function(options) {\n    var ele = $(options.ele);\n    if(ele.length == 1) {\n        var video = new Video(options);\n        video.render();\n        return video;\n    } else if (ele.length > 1) {\n        // 当ele为多元素时，遍历创建多个变量\n        var videoArr = [];\n        ele.each(function(index, element) {\n            var video = new Video(options);\n            video.videoBox = $(element);\n            video.render();\n            videoArr.push(video);\n        });\n        return videoArr;\n    }\n};\n</code></pre>\n<h3><a id=\"_5\"></a>HTML代码：</h3>\n<pre><code><div class=\"video-box\" data-autoplay=\'true\' data-control=\'true\' data-preload=\'auto\' data-src=\'https://nie.res.netease.com/r/video/20161223/56db4506-c848-452d-8168-34eed9f84f32.mp4\'></div>\n</code></pre>\n<h3><a id=\"_6\"></a>JS使用代码：</h3>\n<pre><code>Video.create({\n    ele: \'.video-box\'\n});\n</code></pre>\n<h3><a id=\"_7\"></a>CSS代码：</h3>\n<pre><code>video { display: inline-block; width: 100%;}\n.video-control { position: absolute; display: -webkit-flex; display: flexbox; display: flex; height: 16px; width: 100%; left: 0; bottom: -1px; padding: 7px 1px; background: rgba(240, 240, 240, 1); opacity: 0; transform: translateY(40px); transition: all .5s;}\n.video-control.active {opacity: 1; transform: translateY(0);}\n.video-control .text-time {width: 65px; margin: 0 5px; font-size: 12px; line-height: 18px; color: #666666;}\n.video-control .video-btn { display: inline-block; width: 16px; height: 16px; background: url(sprites-video.png) no-repeat;}\n.video-control .btn-play { margin-left: 10px; background-position: 0 -32px;}\n.video-control .btn-play.active { background-position: 0 -16px;}\n.video-control .btn-muted {margin-left: 10px; background-position: 0 -64px;}\n.video-control .btn-muted.active {background-position: 0 -48px;}\n.video-control .btn-fullpage {margin: 0 10px; background-position: 0 0;}\n.video-control .slidebar-progress {flex: 3;}\n.video-control .slidebar-volume {flex: 1;}\n.video-control .slidebar {position: relative; display: inline-block; margin: 7px 10px; height: 2px; background: rgba(66, 133, 244, .5); border-radius: 1px;}\n.video-control .slidebar .btn-thumb {position: absolute; width: 12px; height: 12px; top: 50%; margin-top: -6px; border-radius: 50%; background: #4285f4; z-index: 2;}\n.video-control .slidebar .btn-thumb.active {transform: scale3d(1.4, 1.4, 1);}\n.video-control .slidebar .line-runway {position: absolute; width: 0; height: 2px; background: #4285f4; border-radius: 1px; z-index: 1;}\n</code></pre>\n<h3><a id=\"_8\"></a>效果：</h3>\n<p><iframe style=\"width: 100%;\" title=\"oBLPbr\" src=\"//codepen.io/dengzhirong8344/embed/oBLPbr/?height=300&theme-id=15300&default-tab=js,result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong8344/pen/oBLPbr/\">oBLPbr</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong8344\">@dengzhirong8344</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1275\">http://www.dengzhr.com/js/1275</a></div>\n\n        ','2','1'),(200,'使用隐藏iframe进行表单跨域提交的方法封装','\n\n            <h2>事起缘由：</h2>\n<p>最近被表单跨域POST提交挤爆了头，特别是要上传大文件时，JSONP就不管用了，FormData的ajax提交虽能提交大文件可惜还是存在跨域报错，各种折磨，坑死姐姐了！</p>\n<p>奈何后台不会为此专门设置CORS，早有耳闻复杂的iframe可以实现无刷新表单提交，只是就不想去碰。闻说<a href=\"https://github.com/jquery-form/form\">ajaxForm</a>也有无刷新表单提交的功效，于是前往尝…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>事起缘由：</h2>\n<p>最近被表单跨域POST提交挤爆了头，特别是要上传大文件时，JSONP就不管用了，FormData的ajax提交虽能提交大文件可惜还是存在跨域报错，各种折磨，坑死姐姐了！</p>\n<p>奈何后台不会为此专门设置CORS，早有耳闻复杂的iframe可以实现无刷新表单提交，只是就不想去碰。闻说<a href=\"https://github.com/jquery-form/form\">ajaxForm</a>也有无刷新表单提交的功效，于是前往尝试，奈何该报跨域错误的还是报了，并没啥卵用(。。。也有可能是我姿势不对→<em>→ →</em>→ →_→。。。)。</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/9wnh7x3y5wwc4kb9hxhz1qpz/timg.gif\" alt=\"timg.gif-43kB\"></p>\n<p>好吧，我决定一次性了解隐藏iframe实现的跨域表单提交原理，顺便封装个公用组件，方便以后快速使用。</p>\n<h2><a id=\"_5\"></a>原理：</h2>\n<p>既然已经明确跨域的POST请求不能使用ajax异步提交，那我们只好放弃了ajax这条路。</p>\n<p>幸好天无绝人之路，跨域的POST请求是可以使用form表单直接提交，但是这样页面也会跟着刷新，并且返回的数据竟然在新窗口打开。这就尴尬了。所以我们想要做的，就是怎样让form表单既能按浏览器默认方式提交，但是却又不会刷新整个页面。</p>\n<p>怎样让表单提交无刷新？江湖流传的做法是：把form提交到本域的一个空iframe中，让服务器处理完后跳转到同域下的空白页里，并给这个空白页添加返回后的数据。甚好，这样确实无刷新提交了。</p>\n<p>只是，怎么让 API接口页A 与 本域的空白页B 之间的请求不跨域呢？</p>\n<p>如果A和B属于相同大域，设置两边的document.domain为相同的父域名就OK了；如果是完全不同的两个域，也有许多现成的解决方案，例如经典的window.name。当然也可以使用几乎所有现代浏览器（IE8+）都支持用window.postMessage实现不同iFrame的数据通讯。</p>\n<p>在这里，我先做A、B属于同一域的情况。其他类似的自己举一反三吧~~</p>\n<p>那我们的返回数据要怎么取回来呢？</p>\n<p>当数据接口A 在B空白页面加载数据请求时，会将返回的数据存放在url中，通过解析url的query就能取回返回的数据啦~</p>\n<p>通过监听隐藏iframe的onload事件，就可以触发父页面的callback函数啦~</p>\n<p>原理如下图所示：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/596126-97989834eda1fd93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"此处输入图片的描述\"></p>\n<p><em>备注：图片来源<a href=\"http://www.jianshu.com/p/4773501f1adf\">http://www.jianshu.com/p/4773501f1adf</a></em></p>\n<h2><a id=\"_6\"></a>组件代码：</h2>\n<pre><code>/* \n * 使用隐藏的iframe发送表单提交\n * options参数说明：\n        url: api接口地址\n        blankUrl:  当前域下blank.html页面的url地址\n        form:  form表单DOM\n        type:  请求method\n        formId:  form表单ID\n        iframeId:  隐藏iframe 的id\n        success:  表单提交成功后的回调函数，参数为返回的data数据\n        error:  表单提交失败后的回调函数\n */\nvar SubmitByIframe = function(options) {\n    this.options = options;\n    this.url = options.url;\n    this.blankUrl = options.blankUrl || \'blank.html\';\n    this.$form = $(options.form);\n    this.type = options.type || \'POST\';\n    this.formId = options.formId || options.form;\n    this.iframeId = options.iframeId || \'hidden_iframe\';\n    this.contentType = options.contentType || \'multipart/form-data\';\n    this.success = options.success;\n    this.error = options.error;\n}\nSubmitByIframe.prototype = {\n    init: function() {\n        var self = this;\n        // 创建并插入隐藏的iframe\n        var iframeStr = \'<iframe id=\"\' + self.iframeId + \'\" name=\"\' + self.iframeId + \'\" src=\"\' + self.blankUrl + \'\" style=\"display:none\"></iframe>\';\n        $(\'body\').append(iframeStr);\n\n        // form表单属性初始化\n        self.$form.attr({\n            target: self.iframeId,\n            enctype: self.contentType,\n            id: self.formId,\n            method: self.type\n        });\n        var hiddenUrlInput = \'<input type=\"hidden\" name=\"url\"/>\';\n        self.$form.append(hiddenUrlInput);\n    },\n\n    getUrlValue: function(s){\n        if (s.search(/#/)>0){\n            s = s.slice(0,s.search(/#/));\n        }\n        var r = {};\n        if (s.search(/\\?/)<0){\n            return r;\n        }\n        var p = s.slice(s.search(/\\?/)+1).split(\'&\');\n        for(var i=0,j=p.length; i<j; i++){\n            var tmp = p[i].split(\'=\');\n            r[tmp[0]] = tmp[1];\n        }\n        return r;\n    },\n\n    bindSubmit: function() {\n        var self = this;\n        $(self.iframeId).unbind(\'load\').unbind(\'errorupdate\');\n        $(\'body\').on(\'load\', self.iframeId, function() {\n            try{\n                var res = self.getUrlValue($(self.iframeId).prop(\'contentWindow\').location.href);\n                if(res) {\n                    self.success && self.success(res);\n                } else {\n                    self.error && self.error();\n                }\n            }catch(err){\n                self.error && self.error();\n            }\n        })\n        .on(\'errorupdate\', self.iframeId, function() {\n            self.error && self.error();\n        });\n    },\n\n    submit: function() {\n        this.bindSubmit();\n        this.$form.attr(\'action\', this.url).submit();\n    },\n\n    render: function() {\n        this.init();\n    }\n};\n\nSubmitByIframe.create = function(options) {\n    var formSubmit = new SubmitByIframe(options);\n    formSubmit.render();\n    return formSubmit;\n};\n</code></pre>\n<h2><a id=\"_7\"></a>blank.html页面的代码：</h2>\n<pre><code><html>\n<head>\n    <title>B页面</title>\n</head>\n<body>\n    <div>B页面</div>\n    <script>        \n        try{\n            //这里将document.domain设置成api接口的domain\n            document.domain = \"example.com\";\n        }\n    </script>\n</body>\n</html>\n</code></pre>\n<h2><a id=\"_8\"></a>方法调用：</h2>\n<pre><code><form id=\'form\'></form>\n</code></pre>\n<pre><code>var apiUrl = \'aa.example.com/api/aaa\';\nvar submitForm = SubmitByIframe.create({\n    url: apiUrl,\n    blankUrl: \'blank.html\',\n    form: $(\'#form\'),\n    formId: \'#form\',\n    type: \'POST\',\n    iframeId: \'#hidden_iframe\',\n    contentType: \'multipart/form-data\',\n    success: function(res) {\n        console.log(res);\n    },\n    error: function() {\n        alert(\'error\');\n    }\n});\nsubmitForm.submit();\n</code></pre>\n<p>结果简直完美，可以愉快地使用POST请求，还能上传特大的文件，而且页面无刷新。</p>\n<p>撒花，撒花~~~</p>\n<p><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1488539327517&di=52bedbc264753a183c856474077c9bbd&imgtype=0&src=http://chesb.bjcnc.scs.sohucs.com/27de17da07124cb586d6b08955ebdff2.gif\" alt=\"此处输入图片的描述\"></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1346\">http://www.dengzhr.com/js/1346</a></div>\n\n        ','2','1'),(201,'JS工具函数封装：使用隐藏iframe实现跨域表单提交','\n\n            <p>关于iframe的原理，之前写的一篇文章里面有提及到。<a href=\"http://www.dengzhr.com/js/1346\">使用隐藏iframe进行表单跨域提交的方法封装</a>。这里就不再赘余了，有兴趣的<a href=\"http://www.dengzhr.com/js/1346\">点击链接查看</a>。但是这篇文章封装的JS工具库有些不够通用，所有特地重构了一遍代码，方便以后的直接使用。</p>\n<p>github地址：<a href=\"https://github.com/dengzhirong/fakeAjax\">https://github.com/dengzhirong/fakeAjax</a>。</p>\n<p>工具库代码重构后如下：</p>\n<pre><code>/* \n * 使用隐藏的iframe发送表单提交\n * Author:</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>关于iframe的原理，之前写的一篇文章里面有提及到。<a href=\"http://www.dengzhr.com/js/1346\">使用隐藏iframe进行表单跨域提交的方法封装</a>。这里就不再赘余了，有兴趣的<a href=\"http://www.dengzhr.com/js/1346\">点击链接查看</a>。但是这篇文章封装的JS工具库有些不够通用，所有特地重构了一遍代码，方便以后的直接使用。</p>\n<p>github地址：<a href=\"https://github.com/dengzhirong/fakeAjax\">https://github.com/dengzhirong/fakeAjax</a>。</p>\n<p>工具库代码重构后如下：</p>\n<pre><code>/* \n * 使用隐藏的iframe发送表单提交\n * Author: 邓智容\n * Created: 2017-06-19,  Last-Modified: 2017-06-19\n * 依赖 jQuery或者 Zepto\n * \n *\n * options参数说明：\n        url     : api接口地址 （必填）\n        type    : 请求method（选填。默认值为get）\n        data    : 发送的data对象。（选填。默认为空）\n\n        blank   : 当前域下blank.html页面的url地址 （选填。默认值为当前页面路径下的blank.html。填写的是绝对路径）\n        form    : form表单DOM （选填。需要提交的form表单DOM）\n\n        success : 表单提交成功后的回调函数，参数为返回的data数据\n        error   : 表单提交失败后的回调函数\n\n * 使用示例：\n        var submitByIframe = PostByIframe.create({\n            url: \'http://example.com/api\',\n            type: \'post\',\n            data: {\n                    a: 12,\n                    b: 32\n                },\n            blank: \'http://example.com/blamk.html\',\n            success: function(res) {\n                console.log(res);\n            },\n            error: function() {\n                alert(\'服务器错误！\');\n            }\n        });\n\n        // 发送请求\n        submitByIframe.submit();\n\n * 注意事项：\n        1. 一定要有blank.html，且空白页内设置的document.domain 与 当前页的document.domain 一致；\n        2. 当前页一定要设置 document.domain；\n        3. 当前组件跨域只适合父域名相同的跨域接口间的访问；\n        4. 依赖jQuery或者Zepto，可兼容到IE7；\n */\n var PostByIframe = (function(window, document, $) {\n    var PostByIframe = function(options) {\n        options = options || {};\n        this.options = options;\n        this.data = options.data || {};\n        this.url = options.url;\n        this.type = options.type || \'GET\';\n        this.$form = options.form ? $(options.form) : null;\n\n        this.success = options.success;\n        this.error = options.error;\n\n        this.formId = \'trick_post_form_\' + this.index;\n        this.iframeId = \'trick_post_hidden_iframe_\' + this.index;\n\n        this.blankUrl = options.blank\n                        ? options.blank\n                        : window.location.href.split(/#|\\?/)[0].substring(0, window.location.href.lastIndexOf(\'/\') + 1) + \'blank.html\';\n    }\n\n    PostByIframe.prototype = {\n        formatIframeHtml: function() {\n            var iframeHtml = \'<iframe id=\"\' + this.iframeId + \'\" name=\"\' + this.iframeId + \'\" src=\"\' + this.blankUrl + \'\" style=\"display:none\"></iframe>\';\n            return iframeHtml;\n        },\n\n        formatFormHtml: function() {\n            var self = this;\n            var formHtml = \'\',\n                inputHtml = \'\',\n                data = this.data;\n\n            formHtml += \'<form\'\n                            + \' target=\' + self.iframeId\n                            + \' method=\' + self.type\n                            + \' id=\' + self.formId\n                            + \' enctype=multipart/form-data\'\n                            + \' style=\"display: none\"\'\n                        + \'>\';\n\n            inputHtml += \'<input type=\"hidden\" name=\"url\" value=\"\' + self.blankUrl + \'\"/>\';\n            for(var key in data) {\n                inputHtml += \'<input type=\"hidden\" name=\"\' + key + \'\" value=\"\' + data[key] + \'\"/>\';\n            }\n\n            formHtml += inputHtml;\n            formHtml += \'</form>\';\n\n            return formHtml;\n        },\n\n        init: function(cb) {\n            var self = this;\n\n            // 插入隐藏的iframe和form\n            var $body = $(\'body\'),\n                iframeHtml = self.formatIframeHtml();\n            $body.append(iframeHtml);\n            self.$iframe = $(\'#\' + self.iframeId);\n\n            if(!self.$form) {\n                var formHtml = self.formatFormHtml();\n                $body.append(formHtml);\n                self.$form = $(\'#\' + self.formId);\n            }\n\n            self.$iframe.unbind(\'load\').on(\'load\', function() {\n                cb && cb();\n            });\n        },\n\n        // 从iframe的返回参数中获取返回值\n        getUrlValue: function(s){\n            if (s.search(/#/) > 0) {\n                s = s.slice(0, s.search(/#/));\n            }\n            var r = {};\n            if (s.search(/\\?/) < 0) {\n                return r;\n            }\n            var p = s.slice(s.search(/\\?/) + 1).split(\'&\');\n            for (var i = 0, j = p.length; i < j; i++) {\n                var tmp = p[i].split(\'=\');\n                r[tmp[0]] = tmp[1];\n            }\n            return r;\n        },\n\n        // 绑定iframe的加载，获取加载返回值\n        bindSubmit: function() {\n            var self = this;\n            var $iframe = self.$iframe;\n            $iframe.unbind(\'load\').on(\'load\', function() {\n                try{\n                    var href = $iframe.prop(\'contentWindow\').location.href;\n                    var res = self.getUrlValue(href);\n                    if(res) {\n                        self.success && self.success(res);\n                    } else {\n                        self.error && self.error();\n                    }\n                }catch(err){\n                    self.error && self.error();\n                }\n            });\n        },\n\n        // 提交表单\n        submit: function() {\n            var self = this;\n            if(!self.isInited) {\n                self.init(function() {\n                    self.isInited = true;\n                    self.bindSubmit();\n                    self.submitForm();\n                });\n            } else {\n                self.submitForm();\n            }\n        },\n\n        submitForm: function() {\n            this.$form.attr(\'action\', this.url).submit();\n        }\n    };\n\n    PostByIframe.count = 0;\n\n    PostByIframe.create = function(options) {\n        var formSubmit = new PostByIframe(options);\n        formSubmit.index = PostByIframe.count;\n        PostByIframe.count++;\n\n        return formSubmit;\n    };\n\n\n    return PostByIframe;\n\n })(window, document, $);\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1424\">http://www.dengzhr.com/js/1424</a></div>\n\n        ','2','1'),(202,'获取DOM元素的兼容函数库封装（兼容至IE6）','\n\n            <p>缘由：虽然jQuery的DOM操作兼容性的封装简直堪称完美，而且IE8+浏览器也能使用强大的document.querySelector，然而。。。</p>\n<p>然而却还有一些网页并不引用jQuery，而且还希望能兼容至IE6，真是太尴尬了。。。</p>\n<p>所以封装获取DOM元素的方法库，备不时之需，权当练手。</p>\n<p>直接上代码：</p>\n<pre><code>var domUtil = {\n    // 获取DOM元素\n    get: function(query) {\n        var _this = this;</code></pre>…\n        ','2019-07-10 08:59:27','0000-00-00 00:00:00',1,'1','\n\n            <p>缘由：虽然jQuery的DOM操作兼容性的封装简直堪称完美，而且IE8+浏览器也能使用强大的document.querySelector，然而。。。</p>\n<p>然而却还有一些网页并不引用jQuery，而且还希望能兼容至IE6，真是太尴尬了。。。</p>\n<p>所以封装获取DOM元素的方法库，备不时之需，权当练手。</p>\n<p>直接上代码：</p>\n<pre><code>var domUtil = {\n    // 获取DOM元素\n    get: function(query) {\n        var _this = this;\n        if(document.querySelector) {\n            return document.querySelector(query);\n        } else {\n            var elements = document;\n            var queryStrArray = query.split(/ +/);\n            for(var i = 0; i < queryStrArray.length; i++) {\n                var domName = queryStrArray[i];\n                elements = _this.getElementsOfParentNode(domName, elements);\n            }\n            if(elements.length == 1) {\n                return elements[0];\n            } else {\n                return elements;\n            }\n        }\n    },\n    // 获取DOM元素\n    getElementsOfParentNode: function(domName, parentNode) {\n        var _this = this;\n        parentNode = parentNode || document;\n        domName = domName.trim();\n        var regExps = {\n            id: /^#/,\n            class: /^/\n        };\n        if(regExps.id.test(domName)) {\n            domName = domName.replace(/^\\#/g, \"\");\n            return parentNode.getElementById(domName);\n        } else if(regExps.class.test(domName)) {\n            domName = domName.replace(/^./g, \"\");\n            return _this.getElementsByClassName(domName, parentNode);\n        } else {\n            return parentNode.getElementsByTagName(domName);\n        }\n    },\n    // 获取class元素的兼容方法\n    getElementsByClassName: function(className, parentNode) {\n        if(parentNode.getElementsByClassName){\n            return parentNode.getElementsByClassName(className);\n        } else {\n            className = className.replace(/^ +| +$/g,\"\");\n            var classArray = className.split(/ +/);\n            var eles = parentNode.getElementsByTagName(\"*\");\n            for(var i = 0;i < classArray.length; i++){\n                var classEles = [];\n                var reg = new RegExp(\"(^| )\" + classArray[i] + \"( |$)\");\n                for(var j = 0;j < eles.length; j++){\n                    var ele = eles[j];\n                    if(reg.test(ele.className)){\n                        classEles.push(ele);\n                    }\n                }\n                eles = classEles;\n            }\n            return eles;\n        }\n    }\n};\n</code></pre>\n<p>使用：</p>\n<pre><code>domUtil(\'body\'); // <body>\ndomUtil(\'body .yourClassName\'); // <body>中的.yourClassName元素\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1331\">http://www.dengzhr.com/js/1331</a></div>\n\n        ','2','1'),(203,'设计模式笔记（五）：JavaScript中的装饰者模式','\n\n            <h2>一. 装饰者模式的定义</h2>\n<blockquote><p>装饰者模式的定义：动态地给一个对象添加额外的职责，而不会影响从这个类派生的其他对象。</p></blockquote>\n<h2>二. 装饰者模式的实现</h2>\n<p>装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态添加职责。</p>\n<p>在JavaScript的实际实现中，可以将本体对象放到装饰者对象中，这些对象以一条链的方式进…</p>\n        ','2019-07-10 08:59:38','0000-00-00 00:00:00',1,'1','\n\n            <h2><a id=\"_4\"></a>一. 装饰者模式的定义</h2>\n<blockquote><p>装饰者模式的定义：动态地给一个对象添加额外的职责，而不会影响从这个类派生的其他对象。</p></blockquote>\n<h2><a id=\"_5\"></a>二. 装饰者模式的实现</h2>\n<p>装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态添加职责。</p>\n<p>在JavaScript的实际实现中，可以将本体对象放到装饰者对象中，这些对象以一条链的方式进行引用，形成一个聚合对象。本体对象和装饰者对象都拥有相同的接口，当请求到达链中的装饰者对象，这个装饰者对象会执行自身，随后将请求转发给本体对象。</p>\n<h3><a id=\"_6\"></a>2.1 通过对象覆写来实现装饰者模式</h3>\n<p>代码如下：</p>\n<pre><code>/* =============== 本体对象 =============== */\nvar Person = function() {};\nPerson.prototype.work = function() {\n    console.log(\"工作\");\n};\n\n/* =============== 装饰者对象 =============== */\n/*\n * 装饰者对象：程序员\n */\nvar ProgramerDecorator = function(person) {\n    this.person = person;\n};\nProgramerDecorator.prototype.work = function() {\n    this.person.work(); // 执行本体对象的方法\n\n    // 执行装饰者对象自身的方法\n    console.log(\"写程序\");\n};\n\n/*\n * 装饰者对象：厨师\n */\nvar ChiefDecorator = function(person) {\n    this.person = person;\n};\nChiefDecorator.prototype.work = function() {\n    this.person.work(); // 执行本体对象的方法\n\n    // 执行装饰者对象自身的方法\n    console.log(\"炒菜\");\n};\n\n/* =============== 客户端调用 =============== */\nvar person = new Person();\nperson = new ProgramerDecorator(person);\n\nperson.work(); // 分别输出：工作、写程序\n</code></pre>\n<p>因为装饰者和它所装饰的本体对象拥有一致的接口，所以他们对使用该对象的用户来说是透明的。被装饰的本体对象也并不需要了解它是否曾被装饰过。这种透明性使我们可以递归地嵌套任意多个装饰者对象。例如：</p>\n<pre><code>/* =============== 客户端调用 =============== */\nvar person = new Person();\nperson = new ProgramerDecorator(person);\nperson = new ChiefDecorator(person);\n\nperson.work(); // 分别输出：工作、写程序、炒菜\n</code></pre>\n<p>装饰者模式将本体对象嵌入到装饰者对象中，实际相当于本体对象被装饰者对象包装起来，形成一条包装链。请求随着这条链依次传递到所有对象，每个对象都有处理这个请求的机会。</p>\n<h3><a id=\"_7\"></a>2.2 改良版：使用构造函数的静态属性实现装饰者模式</h3>\n<p>上面的装饰者模式通过重写对象来实现。但是这样会有一个很大的问题：会导致原型链的丢失。使得最开始的Person类中的其他方法和属性可能丢失。</p>\n<p>下面我们使用构造函数的静态属性来实现装饰者模式，使原型链得以延续。代码如下：</p>\n<pre><code>/* =============== 本体对象 =============== */\nvar Person = function() {};\nPerson.prototype.work = function() {\n    console.log(\"工作\");\n};\n\n// 装饰者对象的调用继承实现\nPerson.prototype.decorate = function(decorator) {\n    var F = function() {},\n        overrides = this.constructor.decorators[decorator],\n        i,\n        newObj;\n    F.prototype = this;\n    newObj = new F();\n    newObj.super = F.prototype;\n\n    for(i in overrides) {\n        if(overrides.hasOwnProperty(i)) {\n            newObj[i] = overrides[i];\n        }\n    }\n    return newObj;\n};\n\n/* =============== 装饰者对象 =============== */\nPerson.decorators = {};\n\n/*\n * 装饰者对象：程序员\n */\nPerson.decorators.programer = {\n    work: function() {\n        this.super.work();\n        console.log(\"写程序\");\n    }\n};\n\n/*\n * 装饰者对象：厨师\n */\nPerson.decorators.chief = {\n    work: function() {\n        this.super.work();\n        console.log(\"炒菜\");\n    }\n};\n\n/* =============== 客户端调用 =============== */\nvar person = new Person();\nperson = person.decorate(\"programer\");\nperson = person.decorate(\"chief\");\n\nperson.work(); // 分别输出：工作、写程序、炒菜\n</code></pre>\n<p>这样，新装饰的对象newObj将继承目前所有用的对象（无论是原始对象，还是已经添加了最后的装饰者的对象），以便于子对象可以访问父对象。</p>\n<h3><a id=\"_8\"></a>2.3 进化版：使用列表实现装饰者模式</h3>\n<p>通过将装饰者对象包装到列表中，可以考虑不需要使用继承，利用JavaScript的动态性质，来实现装饰者模式。代码如下：</p>\n<pre><code>/* =============== 本体对象 =============== */\nvar Person = function() {\n    this.decorators_list = []; // 装饰者对象列表\n};\nPerson.prototype.work = function() {\n    console.log(\"工作\"); // 本体对象方法\n\n    this.renderDecorator(\"work\"); // 渲染装饰者对象方法\n};\n\n// 装饰者对象列表动态添加\nPerson.prototype.decorate = function(decorator) {\n    this.decorators_list.push(decorator);\n};\n\n// 遍历装饰者对象列表，并渲染装饰者对象的对应方法\nPerson.prototype.renderDecorator = function(method) {\n    var decoratorsList = this.decorators_list,\n        decorators = this.constructor.decorators,\n        len = decoratorsList.length;\n\n    for(var i = 0; i < len; i++) {\n        (function(i) {\n            var name = decoratorsList[i],\n            decorator = decorators[name];\n            if(typeof decorator[method] == \"function\") {\n                decorator[method]();\n            }\n        })(i);\n    }\n};\n\n/* =============== 装饰者对象 =============== */\nPerson.decorators = {};\n\n/*\n * 装饰者对象：程序员\n */\nPerson.decorators.programer = {\n    work: function() {\n        console.log(\"写程序\");\n    }\n};\n\n/*\n * 装饰者对象：厨师\n */\nPerson.decorators.chief = {\n    work: function() {\n        console.log(\"炒菜\");\n    }\n};\n\n/* =============== 客户端调用 =============== */\nvar person = new Person();\nperson.decorate(\"programer\");\nperson.decorate(\"chief\");\n\nperson.work(); // 分别输出：工作、写程序、炒菜\n</code></pre>\n<p>通过decorators_list列表来存储装饰者对象，等到调用方法时，才去遍历该装饰者对象列表中的装饰方法。这样的实现更简单，并且也不涉及继承。</p>\n<h2><a id=\"_9\"></a>三. 装饰者模式与代理模式的异同点</h2>\n<p>装饰者模式和代理模式很相像，都描述了怎样为对象提供一定程度上的间接引用，他们的实现部分都保留了对另一个对象的引用，并且向那个对象发送请求。</p>\n<p>代理模式和装饰者模式的最重要的区别在于他们的意图和设计目的：</p>\n<ul>\n<li>代理模式的目的是，当直接访问本体不方便时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对他的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用是为对象动态添加职责。</li>\n<li>代理模式强调的是（代理与本体对象之间的关系），并且这种关系一开始就被可以确定。而装饰者模式用于一开始不能确定对象的全部功能时。</li>\n<li>代理模式通常只有一层代理-本体的引用。而装饰者模式经常会形成一条长长的装饰链。</li>\n</ul>\n<h2><a id=\"_10\"></a>四. 总结</h2>\n<p>装饰者模式在实际开发中很有用，特别是在框架开发中。我们希望框架提供的是一些稳定而方便移植的功能，那些个性化的功能可以在框架之外动态装饰上去。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1157\">http://www.dengzhr.com/js/1157</a></div>\n\n        ','2','1'),(204,'JS工具库封装：Video转换成Canvas','\n\n            <p>在PC端，IE9+浏览器对原生视频的支持还是很不错的，然而一到了移动端就会各种兼容性的坑爹问题。</p>\n<p>在移动端，各大浏览器厂商对视频会植入许多他们自定义的交互方式（如默认全屏播放、视频不能初始化播放、窗口置顶等等），更坑爹的是这些被植入的交互还无法去掉。移动端的视频行内自动播放看起来确实很棘手。</p>\n<p>目前主流有两种方法处理移动端的视频播放问题：</p>\n<p>一种是改设计和说服需求方，�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在PC端，IE9+浏览器对原生视频的支持还是很不错的，然而一到了移动端就会各种兼容性的坑爹问题。</p>\n<p>在移动端，各大浏览器厂商对视频会植入许多他们自定义的交互方式（如默认全屏播放、视频不能初始化播放、窗口置顶等等），更坑爹的是这些被植入的交互还无法去掉。移动端的视频行内自动播放看起来确实很棘手。</p>\n<p>目前主流有两种方法处理移动端的视频播放问题：</p>\n<p>一种是改设计和说服需求方，即使视频不能自动播放或者置顶也不影响页面展示的主要体验；</p>\n<p>另一种便是使用canvas来替代video。</p>\n<p>看起来，canvas像是完美的，没有浏览器厂商任性的植入属性，任由开发者打扮。但是经我们测试后，其实有些低端的Android手机可能会出现卡顿和动画变糊的情况。如果不考虑一些低端手机，还是很值得实践的。</p>\n<p>video转canvas的主要原理，是将视频播放的每一帧都绘制到一个canvas中，这样这个canvas连起来看便像是视频动画了。</p>\n<p>为了方便日常开发使用，特意稍微封装了一下video转canvas的工具库，具体代码如下：</p>\n<pre><code>/*\n * video视频转成canvas（兼容至IE8+）\n * Author: Zijor   Created On: 2017-06-25\n * \n *  使用方法：\n *      var videoCanvas = new VideoToCanvas(videoDom);\n *\n *  对象的属性：\n *      暂无。\n *\n *  对象的方法：\n *      play       播放视频\n *      pause      暂停视频\n *      playPause  播放或暂停视频\n *      change(src) 切换视频。参数src为切换的视频地址\n */\nvar VideoToCanvas = (function(window, document) {\n  function VideoToCanvas(videoElement) {\n    if(!videoElement) {return;}\n\n    var canvas = document.createElement(\'canvas\');\n    canvas.width = videoElement.offsetWidth;\n    canvas.height = videoElement.offsetHeight;\n    ctx = canvas.getContext(\'2d\');\n\n    var newVideo = videoElement.cloneNode(false);\n\n    var timer = null;\n\n    var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||\n                                window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\n    var cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;\n\n    function drawCanvas() {\n      ctx.drawImage(newVideo, 0, 0, canvas.width, canvas.height);\n      timer = requestAnimationFrame(drawCanvas);\n    }\n\n    function stopDrawing() {\n      cancelAnimationFrame(timer);\n    }\n\n    newVideo.addEventListener(\'play\', function() {\n      drawCanvas();\n    },false);\n    newVideo.addEventListener(\'pause\', stopDrawing, false);\n    newVideo.addEventListener(\'ended\', stopDrawing, false);\n\n    videoElement.parentNode.replaceChild(canvas, video);\n\n    this.play = function() {\n      newVideo.play();\n    };\n\n    this.pause = function() {\n      newVideo.pause();\n    };\n\n    this.playPause = function() {\n      if(newVideo.paused) {\n        this.play();\n      } else {\n        this.pause();\n      }\n    };\n\n    this.change = function(src) {\n      if(!src) {return;}\n      newVideo.src = src;\n    };\n\n    this.drawFrame = drawCanvas;\n  }\n\n  return VideoToCanvas;\n\n})(window, document);\n</code></pre>\n<p>使用：</p>\n<pre><code><video id=\"video\" controls loop width=\'300\' autoplay webkit-playsinline=\"true\" src=\'http://www.w3school.com.cn/example/html5/mov_bbb.mp4\'></video>\n\n<script>\nvar video = document.getElementById(\'video\');\nnew VideoToCanvas(video);\n</script>\n</code></pre>\n<p>demo如下：</p>\n<p><iframe style=\"width: 100%;\" title=\"YQrNgq\" src=\"//codepen.io/dengzhirong8344/embed/YQrNgq/?height=300&theme-id=15300&default-tab=result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"https://codepen.io/dengzhirong8344/pen/YQrNgq/\">YQrNgq</a> by dengzhirong (<a href=\"https://codepen.io/dengzhirong8344\">@dengzhirong8344</a>) on <a href=\"https://codepen.io\">CodePen</a>.</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1430\">http://www.dengzhr.com/js/1430</a></div>\n\n        ','2','1'),(205,'【实战】用原生JavaScript封装一个hash路由组件','\n\n            <p>事起缘由：最近做了不少的活动页面，其中一些页面需要用到单页面的技术做切换。<strong>因为常用，所以考虑封装。</strong></p>\n<p>虽然市面上有不少路由库，但是如果为了这么简单的一个小功能就去引入一个庞大的库，显然是不优雅的。最优雅的方式是亲手撸一个～(•‾̑⌣‾̑•)～</p>\n<p>还好几十行代码就能搞得掂。</p>\n<h2>组件代码：</h2>\n<pre><code>/**\n * 路由配置组件\n * 方法：\n        @method set(_hash, callback)  # 配置路由信息，�</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>事起缘由：最近做了不少的活动页面，其中一些页面需要用到单页面的技术做切换。<strong>因为常用，所以考虑封装。</strong></p>\n<p>虽然市面上有不少路由库，但是如果为了这么简单的一个小功能就去引入一个庞大的库，显然是不优雅的。最优雅的方式是亲手撸一个～(•‾̑⌣‾̑•)～</p>\n<p>还好几十行代码就能搞得掂。</p>\n<h2><a id=\"_4\"></a>组件代码：</h2>\n<pre><code>/**\n * 路由配置组件\n * 方法：\n        @method set(_hash, callback)  # 配置路由信息，参数分别是路由hash、回调函数\n        @method bindhashChange(callback)  # 监听hash路由变化，回调函数的参数为change后的hash\n * 实例化方法：\n        var router = Router.init();\n */\nfunction Router() {\n    this.hash = window.location.hash.substring(1);\n}\nRouter.prototype = {\n    // 设置路由\n    set: function(_hash, callback) {\n        var _this = this;\n        checkRouter(_this.hash);\n        _this.bindhashChange(function(__hash) {\n            checkRouter(__hash);\n        });\n\n        function checkRouter(__hash) {\n            if(_hash == __hash) {\n                if(typeof callback == \"function\") {\n                    callback();\n                }\n            }\n        }\n    },\n    // hashChange事件监听\n    bindhashChange: function(callback) {\n        var _this = this;\n        if ((\'onhashchange\' in window) && ((typeof document.documentMode === \'undefined\') || window.documentMode == 8)) {\n            _this.addEvent(window, \"hashchange\", function() {\n                _this.hash = window.location.hash.substring(1);\n                if(typeof callback == \"function\") {\n                    callback(_this.hash);\n                }\n            });\n        } else {\n            setInterval(function () {\n                var ischanged = _this.hash != window.location.hash.substring(1);\n                if (ischanged) {\n                    _this.hash = window.location.hash.substring(1);\n                    if(typeof callback == \"function\") {\n                        callback(_this.hash);\n                    }\n                }\n            }, 150);\n        }\n    },\n    // 事件绑定函数兼容\n    addEvent: function(ele, eventType, callback) {\n        if(ele.addEventListener) {\n            return ele.addEventListener(eventType, callback, false);\n        }else if(ele.attachEvent) {\n            return ele.attachEvent(eventType, callback);\n        }else {\n            return ele[\"on\" + eventType] = callback;\n        }\n    }\n};\n// 实例化\nRouter.init = function() {\n    var router = new Router();\n    return router;\n};\n</code></pre>\n<h2><a id=\"_5\"></a>使用实例：</h2>\n<p>HTML代码：</p>\n<pre><code><a class=\"btn\" href=\"#green\">turn green</a>\n<a class=\"btn\" href=\"#red\">turn red</a>\n<a class=\"btn\" href=\"#brown\">turn brown</a>\n</code></pre>\n<p>JS代码：</p>\n<pre><code>var body = document.getElementsByTagName(\"body\")[0];\n\nvar router = Router.init();\nrouter.set(\"green\", function() {\n    body.style.background = \"#3ac593\";\n});\nrouter.set(\"red\", function() {\n    body.style.background = \"#d05560\";\n});\nrouter.set(\"brown\", function() {\n    body.style.background = \"#bd6c3c\";\n});\n</code></pre>\n<h2><a id=\"_6\"></a>活生生的Demo：</h2>\n<p><iframe style=\"width: 100%;\" title=\"woEvQa\" src=\"//codepen.io/dengzhirong8344/embed/woEvQa/?height=646&theme-id=15300&default-tab=js,result&embed-version=2\" width=\"300\" height=\"646\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong8344/pen/woEvQa/\">woEvQa</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong8344\">@dengzhirong8344</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1241\">http://www.dengzhr.com/js/1241</a></div>\n\n        ','2','1'),(206,'设计模式笔记（一）：JavaScript中的单例模式','\n\n            <p>单例模式是一种常见的模式，如果<strong>希望系统中一个类只有一个实例</strong>，那么单例模式是最好的解决方案。</p>\n<h2>一. 单例模式的定义</h2>\n<blockquote><p>单例模式的定义：<strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</strong></p></blockquote>\n<h2>二. 单例模式的实现原理</h2>\n<blockquote><p><strong>用一个变量来标志当前是否已经为某个类创建过对象。如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。</strong></p></blockquote>\n<h2>三. 单例模式的优点</h2>\n<p>单例模式的优点有：</p>\n<blockquote>\n<ul>\n<li>内存中只有一个对象，节省内存空间；</li>\n<li>避免频繁�</li></ul></blockquote>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>单例模式是一种常见的模式，如果<strong>希望系统中一个类只有一个实例</strong>，那么单例模式是最好的解决方案。</p>\n<h2><a id=\"_4\"></a>一. 单例模式的定义</h2>\n<blockquote><p>单例模式的定义：<strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</strong></p></blockquote>\n<h2><a id=\"_5\"></a>二. 单例模式的实现原理</h2>\n<blockquote><p><strong>用一个变量来标志当前是否已经为某个类创建过对象。如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。</strong></p></blockquote>\n<h2><a id=\"_6\"></a>三. 单例模式的优点</h2>\n<p>单例模式的优点有：</p>\n<blockquote>\n<ul>\n<li>内存中只有一个对象，节省内存空间；</li>\n<li>避免频繁销毁对象，提高性能；</li>\n<li>避免共享资源多重占用；</li>\n<li>可以全局访问。</li>\n</ul>\n</blockquote>\n<h2><a id=\"_7\"></a>四. 单例模式的实现方法</h2>\n<p>单例模式的核心是确保只有一个实例，并提供全局访问。因此，单例模式的实现都是围绕着如何确保实例的唯一性，因此需要用一个变量来标志当前是否已经为某个类创建过实例对象。</p>\n<p>实现方法主要有以下四种：</p>\n<blockquote>\n<ul>\n<li>方法一： 可以<strong>使用全局变量来存储该实例</strong>。但是全局变量容易被覆写。</li>\n<li>方法二： 可以<strong>在构造函数的静态属性中缓存该实例</strong>。缺点是构造函数的静态属性是公开可访问的属性，在外部容易被覆写。</li>\n<li>方法三: 可以<strong>将该实例包装在闭包中</strong>。这样可以保证该实例的私有性并保证该实例不会被构造函数之外的代码所修改。其代价是带来额外的闭包开销。</li>\n<li>方法四：可以<strong>重写构造函数</strong>。</li>\n</ul>\n</blockquote>\n<p>这四种方法的具体实现如下：</p>\n<h3><a id=\"_8\"></a>4.1 使用全局变量保存单例</h3>\n<pre><code>var instance;\n\nfunction Cat() {\n    if(typeof instance === \"object\") {\n        return instance;\n    }\n\n    // Cat构造函数方法 ... ...\n\n    instance = this;\n}\n\n/*============== 测试代码 ===============*/\nvar cat1 = new Cat();\nvar cat2 = new Cat();\n\nconsole.log(cat1 === cat2); // true\n</code></pre>\n<p>使用全局变量来存储该实例对象是有风险的，不推荐使用这种方法。因为全局变量可以被任何人覆盖，容易被覆写，而使该实例对象丢失，从而导致意外事件。</p>\n<p>应尽量减少全局变量的使用。即使需要，也应把它的污染降到最低。例如采用命名空间、使用闭包封装私有变量等方法，将全局变量带来的命名污染尽量降低。</p>\n<h3><a id=\"_9\"></a>4.2 在构造函数的静态属性中缓存实例</h3>\n<pre><code>function Cat() {\n    if(typeof Cat.instance === \"object\") {\n        return Cat.instance;\n    }\n\n    // Cat构造函数方法 ... ...\n\n    // 使用构造函数的静态属性来缓存实例\n    Cat.instance = this;\n}\n\n/*============== 测试代码 ===============*/\nvar cat1 = new Cat();\nvar cat2 = new Cat();\n\nconsole.log(cat1 === cat2); // true\n</code></pre>\n<p>这是一个非常直接的解决方法，其唯一的缺点在于构造函数的静态instance属性是公开的。一旦其他代码无意间修改了该属性，则有可能导致意外发生。</p>\n<h3><a id=\"_10\"></a>4.3 使用闭包创建对象</h3>\n<pre><code>var Cat = (function() {\n    var instance,\n        _this = this;\n\n    return function() {\n        if(typeof instance !== \"object\") {\n            // Cat构造函数方法 ... ...\n            instance = _this;\n        }\n        return instance;\n    }\n})();\n\n/*============== 测试代码 ===============*/\nvar cat1 = new Cat();\nvar cat2 = new Cat();\n\nconsole.log(cat1 === cat2); // true\n</code></pre>\n<h3><a id=\"_11\"></a>4.4 重写构造函数</h3>\n<pre><code>function Cat() {\n    var instance = this;\n\n    // Cat构造函数方法 ... ...\n\n    // 重写构造函数\n    Cat = function() {\n        return instance;\n    }\n}\n\n/*============== 测试代码 ===============*/\nvar cat1 = new Cat();\nvar cat2 = new Cat();\nconsole.log(cat1 === cat2); // true\n</code></pre>\n<p>这种模式的缺点，主要在于重写构造函数中，构造函数会丢失所有在初始定义和重定义时刻之间添加到它里面的属性。</p>\n<p>在上述代码中，在重写构造函数后，任何添加到Cat()的原型中的对象都不会存在指向由原始构造函数所创建的实例的指针。如下：</p>\n<pre><code>/*============== 测试代码 ===============*/\n// 向原型中添加属性\nCat.prototype.color = \"white\";\n\nvar cat1 = new Cat();\n\n// 创建初始化对象后，再次向该原型添加属性\nCat.prototype.age = \"1\";\n\nvar cat2 = new Cat();\n\nconsole.log(cat1 === cat2); // true\nconsole.log(cat1.color); // white\nconsole.log(cat2.color); // white\nconsole.log(cat1.age); // undefined\nconsole.log(cat2.age); // undefined\nconsole.log(cat1.constructor === Cat); // false\nconsole.log(cat2.constructor === Cat); // false\n</code></pre>\n<p>cat1.constructor不再与Cat()构造函数相同，是因为cat1.constructor指向了原始的构造函数，而不是重新定义的那个构造函数。所以在重写构造函数后，任何添加到Cat()的原型中的对象都不会存在指向由原始构造函数所创建的实例的指针。</p>\n<p>如果希望在重写构造函数后，使原型中的对象指向原始构造函数，可以做以下调整：</p>\n<pre><code>function Cat() {\n    var instance = this;\n\n    // 重写构造函数\n    Cat = function() {\n        return instance;\n    }\n\n    // 保留原型属性\n    Cat.prototype = this;\n    // 创建实例\n    instance = new Cat();\n    // 重置构造函数指针\n    instance.contructor = Cat;\n\n    // Cat构造函数方法 ... ...\n\n    return instance;\n}\n\n/*============== 测试代码 ===============*/\n// 向原型中添加属性\nCat.prototype.color = \"white\";\n\nvar cat1 = new Cat();\n\n// 创建初始化对象后，再次向该原型添加属性\nCat.prototype.age = \"1\";\n\nvar cat2 = new Cat();\n\nconsole.log(cat1 === cat2); // true\nconsole.log(cat1.color); // white\nconsole.log(cat2.color); // white\nconsole.log(cat1.age); // 1\nconsole.log(cat2.age); // 1\n</code></pre>\n<h2><a id=\"_12\"></a>五. 单例模式的优化与实际应用</h2>\n<h3><a id=\"_13\"></a>5.1 使用闭包封装构造函数和实例</h3>\n<p>将构造函数和实例封装在几时执行函数中，这样在第一次调用构造函数时，它会创建一个对象，并且使得私有instance指向该对象。从第二次调用之后，该构造函数仅返回该私有变量。这样不仅可以避免全局变量污染，也可以实现单例。</p>\n<pre><code>var Cat;\n(function() {\n    var instance;\n\n    Cat = function() {\n        if(instance) {\n            return instance;\n        }\n\n        // 使用构造函数的静态属性来缓存实例\n        instance = this;\n\n        // Cat构造函数的功能实现 ... ...\n        // ... ...\n    };\n})();\n\n/*============== 测试代码 ===============*/\nvar cat1 = new Cat();\nvar cat2 = new Cat();\nconsole.log(cat1 === cat2); // true\n</code></pre>\n<h3><a id=\"_14\"></a>5.2 用代理实现单例模式</h3>\n<p>可以引入代理类，在代理中实现一个类只能初始化一个实例。</p>\n<pre><code>function Cat() {\n    // Cat构造函数方法 ... ...\n}\n\nvar ProxyCat = (function() {\n    var instance;\n    return function() {\n        if(typeof instance !== \"object\") {\n            instance = new Cat();\n        }\n        return instance;\n    }\n})();\n\n/*============== 测试代码 ===============*/\nvar cat1 = new ProxyCat();\nvar cat2 = new ProxyCat();\n\nconsole.log(cat1 === cat2); // true\n</code></pre>\n<p>引入代理类的方式，跟之前不同的是，把负责管理单类的逻辑移到了代理类中。这样Cat就变成了一个普通的类。</p>\n<h3><a id=\"_15\"></a>5.3 通用的惰性单例</h3>\n<p>将管理单例的逻辑从原来的代码中抽离出来，并将这些逻辑封装在getSingle函数内部，创建对象的方法fn被当成参数动态传入getSingle函数：</p>\n<pre><code>var getSingle = function(fn) {\n    var result;\n    return function() {\n        return result || (result = fn.apply(this, arguments));\n    }\n}\n</code></pre>\n<p>备注：该代码摘抄自《JavaScript设计模式与开发实践》第四章 P68。</p>\n<p>这样，Cat的单例模式代码可以改写为：</p>\n<pre><code>function Cat() {\n    // Cat构造函数方法 ... ...\n}\n\nvar createCat = getSingle(Cat);\n\n/*============== 测试代码 ===============*/\nvar cat1 = createCat();\nvar cat2 = createCat();\n\nconsole.log(cat1 === cat2); // true\n</code></pre>\n<p>在这个例子中，把创建实例对象的职责和管理单例的职责分别放在两个方法中，这两个方法可以独立变化而互不影响，并实现了创建唯一实例对象的功能。推荐使用。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1125\">http://www.dengzhr.com/js/1125</a></div>\n\n        ','2','1'),(207,'理解Function.prototype.bind()方法','\n\n            <h2>一. bind的语法</h2>\n<p>bind 是 ES5 中新增的一个方法，可以改变函数内部的this指向。</p>\n<h3>1.1 定义</h3>\n<p>bind()的定义如下：</p>\n<blockquote><p>The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when</p></blockquote>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. bind的语法</h2>\n<p>bind 是 ES5 中新增的一个方法，可以改变函数内部的this指向。</p>\n<h3><a id=\"_5\"></a>1.1 定义</h3>\n<p>bind()的定义如下：</p>\n<blockquote><p>The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.</p></blockquote>\n<p>bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。</p>\n<h3><a id=\"_6\"></a>1.2 原理</h3>\n<p>可以用如下代码模拟bind()的原理：</p>\n<pre><code>Function.prototype.bind = function(context) {\n    var self = this; // 保存原函数\n    return function() { // 返回一个新函数\n        return self.apply(context, arguments); // 执行新函数时，将传入的上下文context作为新函数的this\n    }\n}\n</code></pre>\n<h3><a id=\"_7\"></a>1.3 语法</h3>\n<pre><code>Function.prototype.bind(thisArg[, arg1[, arg2[, ...]]])\n</code></pre>\n<h2><a id=\"_8\"></a>二. bind的应用场景</h2>\n<h3><a id=\"_9\"></a>2.1 实现对象继承</h3>\n<pre><code>var A = function(name) {\n    this.name = name;\n}\n\nvar B = function() {\n    A.bind(this, arguments)();\n}\n\nB.prototype.getName = function() {\n    return this.name;\n}\n\nvar b = new B(\"hello\");\nconsole.log(b.getName()); // \"hello\"\n</code></pre>\n<h2><a id=\"_10\"></a>2.2 事件处理</h2>\n<pre><code>var paint = {\n    color: \"red\",\n    count: 0,\n    updateCount: function() {\n        this.count++;\n        console.log(this.count);\n    }\n};\n\n// 事件处理函数绑定的错误方法：\ndocument.querySelector(\'button\')\n    .addEventListener(\'click\', paint.updateCount); // paint.updateCount函数的this指向变成了该DOM对象\n\n// 事件处理函数绑定的正确方法：\ndocument.querySelector(\'button\')\n    .addEventListener(\'click\', paint.updateCount.bind(paint)); // paint.updateCount函数的this指向变成了paint\n</code></pre>\n<h3><a id=\"_11\"></a>2.3 时间间隔函数</h3>\n<pre><code>var notify = {\n    text: \"Hello World！\",\n    beforeRender: function() {\n        alert(this.text);\n    },\n    render: function() {\n\n        // 错误方法：\n        setTimeout(this.beforeRender, 0); // undefined\n\n        // 正确方法：\n        setTimeout(this.beforeRender.bind(this), 0); // \"Hello World！\"\n    }\n};\n\nnotify.render();\n</code></pre>\n<h3><a id=\"_12\"></a>2.4 借用Array的原生方法</h3>\n<pre><code>var a = {};\nArray.prototype.push.bind(a, \"hello\", \"world\")();\n\nconsole.log(a); // \"hello\", \"world\"\n</code></pre>\n<h2><a id=\"_13\"></a>三. bind()方法的浏览器兼容性</h2>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/5ukd40jgl45u1e2oodr4ia8n/image_1aunhl06kh9p16k81rv81tl1g9em.png\" alt=\"image_1aunhl06kh9p16k81rv81tl1g9em.png-77.8kB\"></p>\n<p>详细的浏览器兼容性可查看：<a href=\"http://kangax.github.io/compat-table/es5/#test-Function.prototype.bind\">http://kangax.github.io/compat-table/es5/#test-Function.prototype.bind</a></p>\n<h2><a id=\"_14\"></a>四. bind()的兼容性写法</h2>\n<pre><code>if (!Function.prototype.bind) {\n    Function.prototype.bind = function() {\n        var self = this, // 保存原函数\n            context = [].shift.call(arguments), // 需要绑定的this上下文\n            args = [].slice.call(arguments); // 剩余的参数转成数组\n        return function() { // 返回一个新函数\n            // 执行新函数时，将传入的上下文context作为新函数的this\n            // 并且组合两次分别传入的参数，作为新函数的参数\n            return self.apply(context, [].concat.call(args, [].slice.call(arguments))); \n        }\n    };\n}\n</code></pre>\n<p>备注：该代码参考自《JavaScript设计模式与开发实践》第二章。</p>\n<h2><a id=\"_15\"></a>五. bind与 call/apply方法的区别</h2>\n<p>共同点：</p>\n<blockquote><p>都可以改变函数执行的上下文环境；</p></blockquote>\n<p>不同点：</p>\n<blockquote><p>bind: 不立即执行函数，一般用在异步调用和事件； call/apply： 立即执行函数。</p></blockquote>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1069\">http://www.dengzhr.com/js/1069</a></div>\n\n        ','2','1'),(208,'【实战】AngularJS实现拖拽组件','\n\n            <p>正在施工 ing，先占个坑，慢慢填。。。。。…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>正在施工 ing，先占个坑，慢慢填。。。。。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1192\">http://www.dengzhr.com/js/1192</a></div>\n\n        ','2','1'),(209,'学习笔记：JavaScript对象创建模式','\n\n            <p>在JavaScript中创建对象是很容易的，可以使用对象字面量或者构造函数。常用的创建对象的模式有以下几种：</p>\n<h2>一. 工厂模式</h2>\n<p>工厂模式抽象了具体对象的过程，用函数来封装以特ing接口创建对象的细节。</p>\n<p>如下：</p>\n<pre><code>function createAnimal(name, age) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.sayName = function() {\n        alert(this.name);</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在JavaScript中创建对象是很容易的，可以使用对象字面量或者构造函数。常用的创建对象的模式有以下几种：</p>\n<h2><a id=\"_4\"></a>一. 工厂模式</h2>\n<p>工厂模式抽象了具体对象的过程，用函数来封装以特ing接口创建对象的细节。</p>\n<p>如下：</p>\n<pre><code>function createAnimal(name, age) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.sayName = function() {\n        alert(this.name);\n    }\n    return o;\n}\n\nvar cat = createAnimal(\"cat\", 12);\nvar dog = createAnimal(\"dog\", 3);\n</code></pre>\n<p>工厂模式虽然解决了创建多个相似兑现过的问题，但是却没有解决对象识别的问题。</p>\n<h2><a id=\"_5\"></a>二. 构造函数模式</h2>\n<p>构造函数模式可以创建特定类型的对象。</p>\n<pre><code>function Animal(name, age) {\n    this.name = name;\n    this.age = age;\n    this.sayName = function() {\n        alert(this.name);\n    }\n}\nvar cat = new Animal(\"cat\", 12);\nvar dog = new Animal(\"dog\", 3);\n</code></pre>\n<p>可以使用对象的constructor属性或instanceof操作符来标识对象类型。</p>\n<pre><code>cat.constructor == Animal  // true\n\ncat instanceof Animal  // true\n</code></pre>\n<h2><a id=\"_6\"></a>三. 原型模式</h2>\n<p>每个函数都有一个prototype（原型）属性。这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p>\n<p>使用原型对象的好处是，可以让所有对象实例共享它所包含的属性和方法。</p>\n<pre><code>function Animal() {}\nAnimal.prototype.name = \"animal\";\nAnimal.prototype.age = 1;\nAnimal.prototype.sayName = function() {\n    alert(this.name);\n}\n\nvar test1 = new Animal();\ntest1.sayName(); // \"animal\"\n\nvar test2 = new Animal();\ntest2.sayName(); // \"animal\"\n\nalert(test1.sayName === test2.sayName); // true\n</code></pre>\n<p>或者：</p>\n<pre><code>function Animal() {}\nAnimal.prototype = {\n    constructor: Animal,\n    name: \"animal\",\n    age: 1,\n    sayName: function() {\n        alert(this.name);\n    }\n};\n</code></pre>\n<p>原型中所有属性是被很多实例共享的，通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。但是，对于包含引用类型值的属性来说，问题就比较明显了，如下：</p>\n<pre><code>function Animal() {}\nAnimal.prototype = {\n    constructor: Animal,\n    name: \"animal\",\n    age: 1,\n    hobbies: [\"dance\", \"sing\", \"play\"],\n    sayName: function() {\n        alert(this.name);\n    }\n};\n\nvar cat = new Animal();\nvar dog = new Animal();\n\ncat.hobbies.push(\"sleep\");\n\nalert(cat.hobbies); // \"dance\", \"sing\", \"play\", \"sleep\"\nalert(dog.hobbies); // \"dance\", \"sing\", \"play\", \"sleep\"\n\nalert(cat.hobbies === dog.hobbies); // true\n</code></pre>\n<h2><a id=\"_7\"></a>四. 组合使用构造函数模式和原型模式</h2>\n<pre><code>function Animal(name, age) {\n    this.name = \"animal\";\n    this.age = 1;\n    this.hobbies = [\"dance\", \"sing\", \"play\"];\n}\nAnimal.prototype = {\n    constructor: Animal,\n    sayName: function() {\n        alert(this.name);\n    }\n};\n\nvar cat = new Animal(\"cat\", 2);\nvar dog = new Animal(\"dog\", 3);\n\ncat.hobbies.push(\"sleep\");\n\nalert(cat.hobbies); // \"dance\", \"sing\", \"play\", \"sleep\"\nalert(dog.hobbies); // \"dance\", \"sing\", \"play\"\n\nalert(cat.hobbies === dog.hobbies); // false\nalert(cat.sayName === dog.sayName); // true\n</code></pre>\n<h2><a id=\"_8\"></a>五. 动态原型模式</h2>\n<pre><code>function Animal(name, age) {\n    this.name = name;\n    this.age = age;\n    if(typeof this.sayName != \"function\") {\n        Animal.prototype.sayName = function() {\n            alert(this.name);\n        }\n    }\n}\nvar cat = new Animal(\"cat\", 12);\ncat.sayName(); // \"cat\"\n</code></pre>\n<p>使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</p>\n<h2><a id=\"_9\"></a>六. 寄生构造函数模式</h2>\n<p>寄生构造函数模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。</p>\n<p>从表面上看，这个函数很像典型的构造函数。除了使用new操作符之外，这个模式跟工厂模式长得一模一样。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值。</p>\n<pre><code>function Animal(name, age) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.sayName = function() {\n        alert(this.name);\n    }\n    return o;\n}\nvar cat = new Animal(\"cat\", 12);\ncat.sayName(); // \"cat\"\n</code></pre>\n<p>由于返回的对象与构造函数或构造函数的原型之间没有什么关系，因此不能依赖instanceof操作符来确定对象类型。</p>\n<p>建议在可以使用其他模式的情况下，不能使用这种模式。</p>\n<h2><a id=\"_10\"></a>七. 稳妥构造函数模式</h2>\n<p>稳妥构造函数模式与寄生构造函数模式类似，但有两点不同：</p>\n<ul>\n<li>一是新创建对象的实例方法不引用this；</li>\n<li>二是不适用new操作符调用构造函数。</li>\n</ul>\n<pre><code>function Animal(name, age) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    var msg = \"Hello, I\'m \";\n    o.sayName = function() {\n        alert(msg + this.name);\n    }\n    return o;\n}\nvar cat = new Animal(\"cat\", 12);\ncat.sayName(); // \"Hello, I\'m cat\"\n</code></pre>\n<p>稳妥构造函数模式适合在某些安全执行环境。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1029\">http://www.dengzhr.com/js/1029</a></div>\n\n        ','2','1'),(210,'学习笔记：JavaScript中的继承','\n\n            <p>许多OOP语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p>\n<p>实现对象集成集中方法如下：</p>\n<h2>一. 原型链继承</h2>\n<p>使用原型链集成的基本思想，是利用原型让一个引用类型集成另一个引用类型的属性和方法。</p>\n<p>本质就是重写原�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>许多OOP语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p>\n<p>实现对象集成集中方法如下：</p>\n<h2><a id=\"_4\"></a>一. 原型链继承</h2>\n<p>使用原型链集成的基本思想，是利用原型让一个引用类型集成另一个引用类型的属性和方法。</p>\n<p>本质就是重写原型对象，代之以一个新类型的实例。</p>\n<pre><code>/* ================ 父类的定义 ================ */\nfunction SuperType() {\n    this.property = true;\n}\n\nSuperType.prototype.getSuperValue = function() {\n    return this.property;\n}\n\n/* ================ 子类继承父类 ================ */\nfunction SubType() {\n    this.subProperty = false;\n}\n\n// 继承了SuperType\nSubType.prototype = new SuperType();\nSubType.prototype.getSubValue = function() {\n    return this.subProperty;\n}\n\n/* ================ 客户端实现 ================ */\nvar instance = new SubType();\nalert(\"Sub: \" + instance.getSubValue());\nalert(\"Super: \" + instance.getSuperValue());\n</code></pre>\n<p>原型链虽然很强大，但是用它来实现继承，最主要的问题来自包含引用类型值的原型。引用类型值的原型属性会被所有实例共享。</p>\n<pre><code>/* ================ 父类的定义 ================ */\nfunction SuperType() {\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\n\n/* ================ 子类继承父类 ================ */\nfunction SubType() {}\n\nSubType.prototype = new SuperType();\n\n/* ================ 客户端实现 ================ */\nvar instance1 = new SubType();\ninstance1.colors.push(\"black\");\nconsole.log(instance1.colors); // \"red\", \"blue\", \"green\", \"black\"\n\nvar instance2 = new SubType();\nconsole.log(instance2.colors); // \"red\", \"blue\", \"green\", \"black\"\n</code></pre>\n<p>所以，在实践中，很少会单独使用原型链。</p>\n<h2><a id=\"_5\"></a>二. 借用构造函数</h2>\n<p>借用构造函数技术也叫做伪造对象，或经典继承。基本思路是在子类型构造函数的内部调用超类型构造函数。</p>\n<p>函数只是在特定环境中执行代码的对象，因此通过使用apply()和call()方法，也可以在新创建的对象上执行构造函数。</p>\n<pre><code>/* ================ 父类的定义 ================ */\nfunction SuperType() {\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\n\n/* ================ 子类继承父类 ================ */\nfunction SubType() {\n    SuperType.call(this);\n}\n\n/* ================ 客户端实现 ================ */\nvar instance1 = new SubType();\ninstance1.colors.push(\"black\");\nconsole.log(instance1.colors); // \"red\", \"blue\", \"green\", \"black\"\n\nvar instance2 = new SubType();\nconsole.log(instance2.colors); // \"red\", \"blue\", \"green\"\n</code></pre>\n<p>使用call()方法（或apply()方法），实际上是在新创建的SubType实例的环境下调用了SuperType构造函数。</p>\n<p>相对于原型链而言，借用构造函数有一个很大的优势，就是可以在子类型构造函数中向超类型构造函数传递参数。例如：</p>\n<pre><code>/* ================ 父类的定义 ================ */\nfunction SuperType(name) {\n    this.name = name;\n}\n\n/* ================ 子类继承父类 ================ */\nfunction SubType() {\n    SuperType.call(this, \"Hello world\");\n    this.age = 12;\n}\n\n/* ================ 客户端实现 ================ */\nvar instance = new SubType();\nalert(instance.name); // \"Hello world\"\nalert(instance.age); // 12\n</code></pre>\n<p>由于在超类型中定义的方法，对于子类型而言是不可见的，结果所有类型都只能使用构造函数模式。因此借用构造函数的技术也很少单独使用。</p>\n<h2><a id=\"_6\"></a>三. 组合继承</h2>\n<p>组合继承又称伪经典继承，指的是将原型链和借用构造函数的技术结合到一块，从而发挥二者之长的一种继承模式。</p>\n<p>其背后的思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。</p>\n<p>这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p>\n<p>代码实现如下：</p>\n<pre><code>/* ================ 父类的定义 ================ */\nfunction SuperType(name) {\n    this.name = name;\n}\n\n/* ================ 子类继承父类 ================ */\nfunction SubType() {\n    SuperType.call(this, \"Hello world\");  // 借用构造函数\n    this.age = 12;\n}\nSubType.prototype = new SuperType(); // 原型链继承\n\n/* ================ 客户端实现 ================ */\nvar instance = new SubType();\nalert(instance.name); // \"Hello world\"\nalert(instance.age); // 12\n</code></pre>\n<h2><a id=\"_7\"></a>四. 寄生式继承</h2>\n<p>寄生式继承与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回该对象。</p>\n<p>代码实现如下：</p>\n<pre><code>// 基于已有对象借助原型创建新对象\nfunction cloneObject(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\n/* ================ 子类继承父类 ================ */\nfunction createType(obj) {\n    var clone = cloneObject(obj); // 创建新对象\n\n    // 增强该对象的方法 ... ...\n    clone.say = function() {\n        console.log(this.name + \" is \" + this.age + \" years old.\");\n    };\n\n    return clone;\n}\n\n/* ================ 客户端实现 ================ */\nvar person = {\n    name: \"Bob\",\n    age: 21\n};\nvar anotherPerson = createType(person);\nanotherPerson.say(); // Bob is 21 years old.\n</code></pre>\n<h2><a id=\"_8\"></a>五. 使用 class 关键字实现继承</h2>\n<pre><code>\"use strict\";\n\n/* ================ 父类的定义 ================ */\nclass SuperType {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n/* ================ 子类继承父类 ================ */\nclass SubType extends SuperType {\n  constructor(name) {\n    super(name);\n  }\n\n  get say() {\n    console.log(\"Hello \" + this.name + \".\");\n  }\n}\n\n/* ================ 客户端实现 ================ */\nvar instance = new SubType(\"Bob\");\ninstance.say(); // Hello Bob.\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1032\">http://www.dengzhr.com/js/1032</a></div>\n\n        ','2','1'),(211,'学习笔记：Notification API','\n\n            <p>Notification API 是浏览器的通知接口，用于在用户的桌面上显示通知信息，桌面电脑和手机都适用。具体的实现形式由浏览器自行部署，对于手机来说，一般显示在顶部的通知栏。</p>\n<p>如果网页代码调用这个API，浏览器会询问用户是否接受。只有在用户同意的情况下，通知信息才会显示。</p>\n<h2>一. 检查浏览器是否支持 Notification API：</h2>\n<pre><code>if (window.Notification) {\n    // 支持\n} else {\n    // 不</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>Notification API 是浏览器的通知接口，用于在用户的桌面上显示通知信息，桌面电脑和手机都适用。具体的实现形式由浏览器自行部署，对于手机来说，一般显示在顶部的通知栏。</p>\n<p>如果网页代码调用这个API，浏览器会询问用户是否接受。只有在用户同意的情况下，通知信息才会显示。</p>\n<h2><a id=\"_4\"></a>一. 检查浏览器是否支持 Notification API：</h2>\n<pre><code>if (window.Notification) {\n    // 支持\n} else {\n    // 不支持\n}\n</code></pre>\n<h2><a id=\"_5\"></a>二. Notification的权限申请：</h2>\n<p><strong>Notification.requestPermission()</strong> 方法用于让用户做出选择，到底是否接收通知。它的参数是一个回调函数，该函数可以接收用户授权状态作为参数。</p>\n<pre><code>if(window.Notification && Notification.permission !== \"denied\") {\n    Notification.requestPermission(function(status) {\n        // 进行Notification操作\n    });\n} else {\n    // 不支持\n}\n</code></pre>\n<h2><a id=\"_6\"></a>三. Notification的权限状态：</h2>\n<p>Notification.permission属性，用于读取用户给予的权限，它是一个只读属性，它有三种状态。如下：</p>\n<blockquote>\n<ul>\n<li><strong>default</strong>：用户还没有做出任何许可，因此不会弹出通知。</li>\n<li><strong>granted</strong>：用户明确同意接收通知。</li>\n<li><strong>denied</strong>：用户明确拒绝接收通知。</li>\n</ul>\n</blockquote>\n<h2><a id=\"_7\"></a>四. Notification构造函数</h2>\n<p>Notification对象作为构造函数使用时，用来生成一条通知。</p>\n<pre><code>var notification = new Notification(title, options);\n</code></pre>\n<p>参数说明：</p>\n<blockquote>\n<ul>\n<li><strong>title</strong>：【必选】用来指定通知的标题，String类型；</li>\n<li><strong>options</strong>：【可选】配置各种设置，Object类型。</li>\n</ul>\n</blockquote>\n<p><strong>options参数</strong>对象的属性如下：</p>\n<blockquote>\n<ul>\n<li><strong>dir</strong>：文字方向，可能的值为auto、ltr（从左到右）和rtl（从右到左），一般是继承浏览器的设置；</li>\n<li><strong>lang</strong>：使用的语种，比如en-US、zh-CN；</li>\n<li><strong>body</strong>：通知内容，格式为字符串，用来进一步说明通知的目的；</li>\n<li><strong>tag</strong>：通知的ID，格式为字符串。一组相同tag的通知，不会同时显示，只会在用户关闭前一个通知后，在原位置显示；</li>\n<li><strong>icon</strong>：图表的URL，用来显示在通知上。</li>\n</ul>\n</blockquote>\n<p>options参数对象的这些属性，都是可读写的。</p>\n<p><strong>例子：</strong></p>\n<pre><code>if(window.Notification && Notification.permission !== \"denied\") {\n    Notification.requestPermission(function(status) {\n        var n = new Notification(\'通知标题\', { body: \'这里是通知内容！\' }); \n    });\n}\n</code></pre>\n<h2><a id=\"_8\"></a>五. 实例对象的事件</h2>\n<blockquote>\n<ul>\n<li><strong>show</strong>：通知显示给用户时触发。</li>\n<li><strong>click</strong>：用户点击通知时触发。</li>\n<li><strong>close</strong>：用户关闭通知时触发。</li>\n<li><strong>error</strong>：通知出错时触发（大多数发生在通知无法正确显示时）。</li>\n</ul>\n</blockquote>\n<p>并不能从通知的close事件，判断它是否为用户手动关闭。</p>\n<p>例子：</p>\n<pre><code>// 当显示通知时的回调\n\nnotification.onshow = function() {\n  console.log(\'Notification shown\');\n};\n</code></pre>\n<pre><code>// Notification实例的close方法用于关闭通知\n\nvar notification = new Notification(\"Hi!\");\n\nnotification.close(); // 手动关闭\n\n// 自动关闭\nnotification.onshow = function () { \n  setTimeout(notification.close.bind(notification), 5000); \n}\n</code></pre>\n<h2><a id=\"_9\"></a>六. 兼容性</h2>\n<p>详细的兼容性信息可查看：<a href=\"http://caniuse.com/#search=Notification\">http://caniuse.com/#search=Notification</a></p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/34a0i08x1lfz70aoaui0bpcd/image_1atqhdm9013vmi4ea4ui81dgs9.png\" alt=\"image_1atqhdm9013vmi4ea4ui81dgs9.png-63.6kB\"></p>\n<h2><a id=\"_10\"></a>七. 推荐阅读</h2>\n<p>Web Notifications API（by阮一峰大神） <a href=\"http://javascript.ruanyifeng.com/bom/notification.html\">http://javascript.ruanyifeng.com/bom/notification.html</a></p>\n<p>notification API（MDN） <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/notification\">https://developer.mozilla.org/zh-CN/docs/Web/API/notification</a></p>\n<p>MDN: Using the Notifications API <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API/Using_the_Notifications_API\">https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API/Using_the_Notifications_API</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1039\">http://www.dengzhr.com/js/1039</a></div>\n\n        ','2','1'),(212,'设计模式笔记（二）：JavaScript中的策略模式','\n\n            <h2>一. 策略模式的定义</h2>\n<blockquote><p>策略模式的定义：定义了算法家族，分别封装起来，让它们之间可以相互替换。</p></blockquote>\n<p>策略模式的目的是想将算法的使用与实现分离开来。</p>\n<h2>二. 策略模式的实现</h2>\n<p>究其本质，策略模式使用委托去解耦使用它们的算法类。</p>\n<p>基于策略模式的程序至少由两部分组成：</p>\n<ul>\n<li>第一部分是一组 <strong>策略类</strong>。策略类封装了具体的算法，并负责具体的计算过程。</li>\n<li>第二部分是 <strong>环境类</strong> Context。Context接受客户请求，并将请求委托给某一个策略类。</li>\n</ul>\n<p>例如：…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 策略模式的定义</h2>\n<blockquote><p>策略模式的定义：定义了算法家族，分别封装起来，让它们之间可以相互替换。</p></blockquote>\n<p>策略模式的目的是想将算法的使用与实现分离开来。</p>\n<h2><a id=\"_5\"></a>二. 策略模式的实现</h2>\n<p>究其本质，策略模式使用委托去解耦使用它们的算法类。</p>\n<p>基于策略模式的程序至少由两部分组成：</p>\n<ul>\n<li>第一部分是一组 <strong>策略类</strong>。策略类封装了具体的算法，并负责具体的计算过程。</li>\n<li>第二部分是 <strong>环境类</strong> Context。Context接受客户请求，并将请求委托给某一个策略类。</li>\n</ul>\n<p>例如：</p>\n<pre><code>// 定义一组策略类\nvar strategies = {\n    A: function() { // A策略内容... },\n    B: function() { // B策略内容... },\n    C: function() { // C策略内容... }\n};\n\n// 定义Context环境类，维持对策略对象的引用\nvar context = function(strategy) {\n    // 对strategy的一些处理 ... ...\n\n    return strategy;\n};\n\n// 实际调用\ncontext( strategies.A() );\ncontext( strategies.B() );\ncontext( strategies.C() );\n</code></pre>\n<p>这样做有几个好处：可以防止使用大条件语句来决定哪些算法用于特定类型的对象，将关注点分离开来，因此降低了客户端的复杂度，同时还可以促进子类化的组成，提高了模块化和可测性。</p>\n<h3><a id=\"_6\"></a>2.1 实例：使用策略模式实现图片像素操作</h3>\n<pre><code>var filterRules = {\n    // 灰度\n    gray: function(imagedata) {\n        var imagedata = imagedata || [],\n            pixels = imagedata.data,\n            pixelsLen = pixels.length;\n        for(var i = 0; i < pixelsLen; i++) {\n            pixels[i * 4] = 255 - pixels[i * 4]; // 红色\n            pixels[i * 4 + 1] = 255 - pixels[i * 4 + 1]; // 绿色\n            pixels[i * 4 + 2] = 255 - pixels[i * 4 + 2]; // 蓝色\n        }\n    },\n\n    // 反转颜色\n    invert: function(imagedata) {\n        var imagedata = imagedata || [],\n            pixels = imagedata.data,\n            pixelsLen = pixels.length;\n        for(var i = 0; i < pixelsLen; i++) {\n            var average = ( pixels[i * 4] + pixels[i * 4 + 1] + pixels[i * 4 + 2] ) / 3;\n            pixels[i * 4] = average; // 红色\n            pixels[i * 4 + 1] = average; // 绿色\n            pixels[i * 4 + 2] = average; // 蓝色\n        }\n    },\n\n    // 浮雕\n    emboss: function(imagedata) {\n        var imagedata = imagedata || [],\n            pixels = imagedata.data,\n            pixelsLen = pixels.length,\n            imageWidth = imagedata.width;\n        for(var i = 0; i < pixelsLen; i++) {\n            if(i < pixelsLen - imageWidth * 4) {\n                if((i + 1) % 4 !== 0) {\n                    if((i + 4) % (imageWidth * 4) == 0) {\n                        pixels[i] = pixels[i - 4];\n                        pixels[i + 1] = pixels[i - 3];\n                        pixels[i + 2] = pixels[i - 2];\n                        pixels[i + 3] = pixels[i - 1];\n                        i += 4;\n                    } else {\n                        pixels[i] = 255 / 2 + 2 * pixels[i] - pixels[i + 4] - pixels[i + imageWidth * 4];\n                    }\n                }\n            } else if((i + 1) % 4 !== 0) {\n                pixels[i] = pixels[i - imageWidth * 4];\n            }\n        }\n    }\n};\n</code></pre>\n<pre><code>var canvas = document.getElementById(\"canvas\"),\n    context = canvas.getContext(\"2d\"),\n    image = new Image();\n\nimage.src = \"1.jpg\";\nimage.onload = function() {\n    context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n    // renderFilter(context, filter.gray, canvas);\n};\n\n// 渲染滤镜\nfunction renderFilter(context, filter, canvas) {\n    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    if(filterRules[filter]) {\n        filterRules[filter](imageData);\n    }\n    context.putImageData(imageData, 0, 0);\n}\n\n// 选择滤镜模式\nvar filterBtn = document.getElementById(\"btn_filter\");\nfilterBtn.addEventListener(\"click\", function(e) {\n    var target = e.target,\n        filter = target.dataset.filter;\n        if(filterRules[filter]) {\n            renderFilter(context, filter, canvas);\n        }\n}, false);\n</code></pre>\n<p>效果如下：</p>\n<p>【正在施工中… …】</p>\n<h3><a id=\"_7\"></a>2.2 实例：使用策略模式实现表单校验</h3>\n<p>参考《JavaScript设计模式与开发实践》第五章P80~86。</p>\n<h2><a id=\"_8\"></a>三. 策略模式的优缺点</h2>\n<h3><a id=\"_9\"></a>3.1 策略模式的优点：</h3>\n<ul>\n<li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免使用多重条件判断；</li>\n<li>算法独立封装，使得他们可以自由切换，易于理解和扩展；</li>\n<li>复用性高。</li>\n</ul>\n<h3><a id=\"_10\"></a>3.2 策略模式的缺点：</h3>\n<ul>\n<li>策略类会增多；</li>\n<li>所有策略类都需要对外暴露。</li>\n</ul>\n<h2><a id=\"_11\"></a>四. 策略模式的适用场景</h2>\n<p>策略模式的适用场景有：</p>\n<ul>\n<li>\n<ol>\n<li>当系统中有许多类，而他们之间的区别仅在于行为时，那么使用策略模式可以动态地让一个对象在许多行为中选择一种；</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>当系统需要动态地在几种算法中选择一种时；</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。</li>\n</ol>\n</li>\n</ul>\n<h2><a id=\"_12\"></a>五. 总结</h2>\n<p>策略模式将算法的使用和算法的实现分离开来，将不变的部分和变化的部分分隔开，从而使程序进行解耦。</p>\n<p>策略模式对于可提炼出多种较通用的算法，并在不同的使用场景下按需选择某一种或某几种策略完成对应的业务逻辑比较适用。所以，当业务逻辑涉及到分类和按需应用时，可考虑使用策略模式来实现。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1129\">http://www.dengzhr.com/js/1129</a></div>\n\n        ','2','1'),(213,'原生JavaScript实现复制/粘贴','\n\n            <p>在IE7及其以下版本浏览器中，由于不具备直接访问剪贴板的能力，开发者只能借助于flash插件来实现这一功能。</p>\n<p>而现在不部分现在浏览器支持剪贴板功能，Mac和iOS上的Safari除外。但是不同浏览器的支持程度不尽相同，而且一些功能并不完整或存在缺陷，需要考虑的兼容性问题较多。用户必须通过点击鼠标或按键的方式来主动触发，脚本并不能随时操纵剪贴板。</p>\n<p>下面总结一下剪贴板的JavaScript语法。</p>\n<h2>一. 剪�</h2>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在IE7及其以下版本浏览器中，由于不具备直接访问剪贴板的能力，开发者只能借助于flash插件来实现这一功能。</p>\n<p>而现在不部分现在浏览器支持剪贴板功能，Mac和iOS上的Safari除外。但是不同浏览器的支持程度不尽相同，而且一些功能并不完整或存在缺陷，需要考虑的兼容性问题较多。用户必须通过点击鼠标或按键的方式来主动触发，脚本并不能随时操纵剪贴板。</p>\n<p>下面总结一下剪贴板的JavaScript语法。</p>\n<h2><a id=\"_4\"></a>一. 剪贴板事件</h2>\n<blockquote>\n<ul>\n<li><strong>beforecopy</strong>：在发生复制操作前触发；</li>\n<li><strong>copy</strong>：在发生复制操作的时候触发；</li>\n<li><strong>beforecut</strong>：在发生剪切操作前触发；</li>\n<li><strong>cut</strong>：在发生剪切操作的时候触发；</li>\n<li><strong>beforepaste</strong>：在发生粘贴操作前触发；</li>\n<li><strong>paste</strong>：在发生粘贴操作的时候触发。</li>\n</ul>\n</blockquote>\n<p>在实际的事件发生之前，通过beforecopy、beforecut和beforepaste事件，可以在向剪贴板发送数据，或者从剪贴板取得数据之前修改数据。</p>\n<h2><a id=\"_5\"></a>二. 访问剪贴板数据：clipboardData对象</h2>\n<p>要访问剪贴板中的数据，可以通过<strong><code>clipboardData</code></strong>对象：</p>\n<blockquote>\n<ul>\n<li>在IE中，clipboardData对象是window对象的属性；</li>\n<li>而在Chrome、Safari和Firefox 4+中，clipboardData对象是相应event对象的属性。</li>\n</ul>\n</blockquote>\n<p>但是，在Chrome、Safari和Firefox 4+中，只有在处理剪贴板事件期间，clipboardData对象才有效，这是为了防止对剪贴板的未授权访问；在IE中，则可以随时访问clipboardData对象。为了确保跨浏览器兼容，<strong>最好只在发生剪贴板事件期间使用clipboardData对象</strong>。</p>\n<h3><a id=\"_6\"></a>2.1 clipboardData对象的方法：</h3>\n<p> </p>\n<blockquote>\n<ul>\n<li>getData()</li>\n<li>setData()</li>\n<li>clearData()</li>\n</ul>\n</blockquote>\n<h4><a id=\"_7\"></a>2.1.1 getData()</h4>\n<p>getData()方法用于从剪贴板中获取数据，它接收一个参数，即要取得的数据格式。</p>\n<blockquote>\n<ul>\n<li>在IE中，有两种数据格式：”text”和”URL”。</li>\n<li>在Chrome、Safari和Firefox 4+中，这个参数是一种MIME类型。不过，可以用”text”代表”text/plain”。</li>\n</ul>\n</blockquote>\n<pre><code>//获取剪贴板数据方法\nfunction getClipboardText(event){\n    var clipboardData = event.clipboardData || window.clipboardData;\n    return clipboardData.getData(\"text\");\n};\n</code></pre>\n<h4><a id=\"_8\"></a>2.1.2 setData()</h4>\n<p>setData()方法的第一个参数也是数据类型，第二个参数是要放在剪贴板中的文字。</p>\n<p>对于第一个参数，IE照样是支持”text”和”URL”，而在Chrome、Safari中，仍然支持MIME类型。但是与getData()方法不同的是，在Chrome、Safari中的setData()方法不能识别”text”类型。</p>\n<p>在成功将文本放到剪贴板中后，该方法会返回true，否则返回false。</p>\n<pre><code>//设置剪贴板数据\nfunction setClipboardText(event, value){\n    if(event.clipboardData){\n        return event.clipboardData.setData(\"text/plain\", value);\n    }else if(window.clipboardData){\n        return window.clipboardData.setData(\"text\", value);\n    }\n};\n</code></pre>\n<h3><a id=\"_9\"></a>2.2 clipboardData对象的属性：</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dropEffect</td>\n<td>String</td>\n<td>默认是 none。</td>\n</tr>\n<tr>\n<td>effectAllowed</td>\n<td>String</td>\n<td>默认是 uninitialized。</td>\n</tr>\n<tr>\n<td>Files</td>\n<td>FileList</td>\n<td>粘贴操作为空List。</td>\n</tr>\n<tr>\n<td>items</td>\n<td>DataTransferItemList</td>\n<td>剪切板中的各项数据。</td>\n</tr>\n<tr>\n<td>types</td>\n<td>Array</td>\n<td>剪切板中的数据类型。</td>\n</tr>\n</tbody>\n</table>\n<h4><a id=\"_10\"></a>2.2.1 items属性：</h4>\n<p>items是一个DataTransferItemList对象，自然里面都是DataTransferItem类型的数据了。</p>\n<p><strong>属性</strong></p>\n<p>items的DataTransferItem有两个属性 kind 和 type：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>kind</td>\n<td>一般为string或者file。</td>\n</tr>\n<tr>\n<td>type</td>\n<td>具体的数据类型，例如具体是哪种类型字符串或者哪种类型的文件，即MIME-Type。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getAsFile</td>\n<td>空</td>\n<td>如果kind是file，可以用该方法获取到文件</td>\n</tr>\n<tr>\n<td>getAsString</td>\n<td>回调函数</td>\n<td>如果kind是string，可以用该方法获取到字符串，字符串需要用回调函数得到，回调函数的第一个参数就是剪切板中的字符串</td>\n</tr>\n</tbody>\n</table>\n<h4><a id=\"_11\"></a>2.2.2 types属性：</h4>\n<p>一般types中常见的值有text/plain、text/html、Files。</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>text/plain</td>\n<td>普通字符串。</td>\n</tr>\n<tr>\n<td>text/html</td>\n<td>带有样式的html。</td>\n</tr>\n<tr>\n<td>Files</td>\n<td>文件(例如剪切板中的数据)。</td>\n</tr>\n</tbody>\n</table>\n<pre><code><input type=\"text\" id=\"input\">\n\ndocument.querySelector(\"#input\").addEventListener(\"paste\", function(e) {\n    var clipboardData = e.clipboardData || window.clipboardData,\n        i = 0,\n        items,\n        item,\n        types;\n\n    if( clipboardData ) {\n        items = clipboardData.items;\n        if( !items ) {\n            return;\n        }\n        item = items[0];\n\n        // 保存在剪贴板中的数据类型\n        types = clipboardData.types || [];\n        for(i = 0; i < types.length; i++ ) {\n            if( types[i] === \'Files\' ) {\n                item = items[i];\n                break;\n            }\n        }\n\n        // 判断是否为图片数据\n        if( item && item.kind === \'file\' && item.type.match(/^image\\//i) ) {\n            alert(\"This is an image.\");\n        }\n    }\n});\n</code></pre>\n<h3><a id=\"_12\"></a>2.3 clipboardData对象的兼容性</h3>\n<p>clipboardData对象的兼容性如下： <a href=\"http://caniuse.com/#search=Clipboard\">http://caniuse.com/#search=Clipboard</a></p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/l9dj8mfu0l5atpqgu5isb6gj/image_1au6rgnf5cn7etf1kt01cptvm9.png\" alt=\"image_1au6rgnf5cn7etf1kt01cptvm9.png-40.2kB\"></p>\n<h2><a id=\"_13\"></a>三. 复制文本到剪贴板：document.execCommand()</h2>\n<p>当文档对象被转换为设计模式的时候（选中，设置contentEditable等），文档对象提供了一个execCommand方法，通过给这这个方法传递参数命令可以操作可编辑区域的内容。这个方法的命令大多数是对文档选中区域的操作 (如bold, italics等)，通过执行execCommand 方法可以对当前活动元素进行很多操作。</p>\n<h3><a id=\"_14\"></a>3.1 语法：</h3>\n<pre><code>bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)\n</code></pre>\n<p>参数如下：</p>\n<blockquote>\n<ul>\n<li>aCommandName ： 命令的名称，如”cut”、”copy”、”paste”等<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand#%E5%91%BD%E4%BB%A4\">命令</a>。</li>\n<li>aShowDefaultUI ： 否展示用户界面，默认为false。Mozilla没有实现。</li>\n<li>aValueArgument ： 一些命令需要一些额外的参数值（如insertimage需要提供这个image的url）。默认为null。</li>\n</ul>\n</blockquote>\n<p>对于复制文本到剪切板，用到的方法是：</p>\n<pre><code>document.execCommand(\"copy\", \"false\", null);\n</code></pre>\n<p>在调用之前，可以使用 <code>document.queryCommandSupported(\"copy\");</code> 或 <code>document.queryCommandEnabled(\"copy\");</code> 方法（这两个方法功能相同）来检测浏览器是否支持复制命令。</p>\n<p>需要注意的是，Chrome 虽然支持复制命令的，但在 Chorme 中这两个方法都会返回 false 值。检测 document.execCommand 方法是否存在也是一个判断方法，但更好的做法是将 document.execCommand(“copy”) 调用放在 try-catch 块内。</p>\n<pre><code>// 选中 #myEle 标签中的文本\nvar myEle = document.getElementById(\'#myEle\'),\n    range = document.createRange();\n\nrange.selectNode(myEle);\nwindow.getSelection().addRange(range);\n\ntry {\n    if(document.execCommand) {\n        // 复制选中的文字到剪贴板\n        document.execCommand(\"copy\", \"false\", null);\n    }\n} catch {\n    // 不支持复制命令\n}\n</code></pre>\n<h2><a id=\"_15\"></a>应用实例：将剪切板中的图片资源显示到页面上</h2>\n<pre><code><input type=\"text\" id=\"input\" placeholder=\"请粘贴图片到文本框中\">\n\n\n// 将图片资源显示到页面中\nfunction showImage(imageData) {\n    var reader = new FileReader();\n    reader.onload = function(e){\n        var img = new Image();\n        img.src = e.target.result;\n        document.body.appendChild(img);\n    };\n    // 读取图片文件\n    reader.readAsDataURL(imageData);\n}\n\ndocument.querySelector(\"#input\").addEventListener(\"paste\", function(e){\n    var clipboardData = e.clipboardData,\n        items,\n        item,\n        types;\n\n    if(clipboardData){\n        items = clipboardData.items;\n        if(!items){\n            return;\n        }\n        item = items[0];\n        // 保存在剪贴板中的数据类型\n        types = clipboardData.types || [];\n        for(var i = 0; i < types.length; i++ ){\n            if(types[i] === \"Files\"){\n                item = items[i];\n                break;\n            }\n        }\n        // 判断是否为图片数据\n        if( item && item.kind === \'file\' && item.type.match(/^image\\//i) ){\n            var blob = item.getAsFile();\n            showImage(blob);\n        }\n    }\n});\n</code></pre>\n<p>效果如下：</p>\n<p><iframe style=\"width: 100%;\" src=\"//codepen.io/dengzhirong/embed/PGOjxm/?height=300&theme-id=15149&default-tab=result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong/pen/PGOjxm/\">PGOjxm</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong\">@dengzhirong</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1056\">http://www.dengzhr.com/js/1056</a></div>\n\n        ','2','1'),(214,'JavaScript：获取url的querystring参数','\n\n            <h2>一. 获取url的querystring参数</h2>\n<p>获取url的querystring参数的两种方法如下：</p>\n<h3>1.1 方法一：正则匹配</h3>\n<pre><code>//获取url中的参数\nfunction getQueryString(name) {\n    var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", i); // 匹配目标参数\n    var result = window.location.search.substr(1).match(reg);</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 获取url的querystring参数</h2>\n<p>获取url的querystring参数的两种方法如下：</p>\n<h3><a id=\"_5\"></a>1.1 方法一：正则匹配</h3>\n<pre><code>//获取url中的参数\nfunction getQueryString(name) {\n    var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", i); // 匹配目标参数\n    var result = window.location.search.substr(1).match(reg);  // 对querystring匹配目标参数\n    if (result != null) {\n        return decodeURIComponent(result[2]);\n    } else {\n        return null;\n    }\n}\n</code></pre>\n<p>对于 <code>http://localhost/index.html?q1=abc&q2=efg&q3=h</code> 的url，获取 <code>q1</code> 参数值的方法如下：</p>\n<pre><code>var q1 = getQueryString(\'q1\'); // abc\n</code></pre>\n<h3><a id=\"_6\"></a>1.2 方法二：split</h3>\n<pre><code>function getQueryString() {   \n    var qs = location.search.substr(1), // 获取url中\"?\"符后的字串   \n        args = {}, // 保存参数数据的对象\n        items = qs.length ? qs.split(\"&\") : [], // 取得每一个参数项,\n        item = null,\n        len = items.length;\n\n    for(var i = 0; i < len; i++) {\n        item = items[i].split(\"=\");\n        var name = decodeURIComponent(item[0]),\n            value = decodeURIComponent(item[1]);\n        if(name) {\n            args[name] = value;\n        }\n    }\n    return args;\n}\n</code></pre>\n<p>对于 <code>http://localhost/index.html?q1=abc&q2=efg&q3=h</code> 的url，获取 <code>q1</code> 参数值的方法如下：</p>\n<pre><code>var qs = getQueryString();  \n\nvar q1 = qs[\"q1\"]; // abc\n</code></pre>\n<p>用上面的getQueryString()方法能很好的解决获取url的querystring参数问题。就</p>\n<p>上面两种getQueryString()方法都能很好地解决获取url的querystring参数问题。就此顺便整理一下Location对象，方便日后学习参考。</p>\n<h2><a id=\"_7\"></a>二. Location对象的属性</h2>\n<p>备注：以 <code>http://localhost:80/dir/index.html?q1=abc&q2=efg&q3=h#anchor</code> 为例：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>定义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hash</td>\n<td>返回URL中的hash（#后跟零或多个字符串）</td>\n<td>#anchor</td>\n</tr>\n<tr>\n<td>host</td>\n<td>相当于hostname + port，即：主机名（域名）＋端口号</td>\n<td>localhost:80</td>\n</tr>\n<tr>\n<td>hostname</td>\n<td>主机名（域名）</td>\n<td>localhost</td>\n</tr>\n<tr>\n<td>href</td>\n<td>当前页面的完整URL</td>\n<td>http://localhost:80/dir/index.html?q1=abc&q2=efg&q3=h#anchor</td>\n</tr>\n<tr>\n<td>pathname</td>\n<td>URL中的目录和文件名/dir/index.html</td>\n</tr>\n<tr>\n<td>port</td>\n<td>端口号</td>\n<td>80</td>\n</tr>\n<tr>\n<td>protocal</td>\n<td>协议</td>\n<td>http:</td>\n</tr>\n<tr>\n<td>search</td>\n<td>查询字符串。这个字符以问号开头</td>\n<td>?q1=abc&q2=efg&q3=h</td>\n</tr>\n</tbody>\n</table>\n<p>location的这8个属性都是可读写的。</p>\n<p>其中，改变location.href会跳转到新的URL页面，而修改location.hash会跳到当前页面中锚点位置。</p>\n<p><strong>每次修改window.location的属性（hash除外），页面都会以新的URL重新加载，并在浏览器的历史纪录中生成一条新纪录。</strong></p>\n<h2><a id=\"_8\"></a>三. Location对象的方法</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>assign(url)</td>\n<td>打开新的URL，并在浏览器的历史纪录中生成一条记录。</td>\n</tr>\n<tr>\n<td>replace(url)</td>\n<td>打开新的URL，但是不会在浏览器的历史纪录中生成新纪录。</td>\n</tr>\n<tr>\n<td>reload(force)</td>\n<td>刷新当前页面。force为true时从服务器端重新加载；为false时从浏览器缓存中重新加载。默认值false。</td>\n</tr>\n</tbody>\n</table>\n<p>其中，<code>location.assign(url)</code> 的效果跟下列两行代码的效果完全一样：</p>\n<pre><code>window.location = url;\nlocation.href = url;\n</code></pre>\n<p>位于 <code>location.reload()</code> 调用之后的代码可能会也可能不会执行，这取决于网络延迟或系统资源等因素。因此，最好将 <code>location.reload()</code> 放在代码的最后一行。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/1065\">http://www.dengzhr.com/frontend/1065</a></div>\n\n        ','2','1'),(215,'学习笔记：JavaScript 函数柯里化','\n\n            <h2>一. 函数柯里化的定义</h2>\n<blockquote><p>函数<a href=\"https://zh.wikipedia.org/zh-hans/%E6%9F%AF%E9%87%8C%E5%8C%96\">柯里化</a>，Function currying，又称部分求值，指的是逐步传参，逐步求解的过程。</p></blockquote>\n<h2>二. 函数柯里化的实现</h2>\n<p>一个Curry函数首先会接受一些参数，接受参数之后，该函数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p>\n<p>如下：</p>\n<pre><code>var add = (function() {\n    var numArr</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 函数柯里化的定义</h2>\n<blockquote><p>函数<a href=\"https://zh.wikipedia.org/zh-hans/%E6%9F%AF%E9%87%8C%E5%8C%96\">柯里化</a>，Function currying，又称部分求值，指的是逐步传参，逐步求解的过程。</p></blockquote>\n<h2><a id=\"_5\"></a>二. 函数柯里化的实现</h2>\n<p>一个Curry函数首先会接受一些参数，接受参数之后，该函数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p>\n<p>如下：</p>\n<pre><code>var add = (function() {\n    var numArr = [];\n\n    return function() {\n        if(arguments.length === 0) {\n            var result = 0;\n            for(var i = 0, len = numArr.length; i < len; i++) {\n                result += numArr[i];\n            }\n            return result;\n        } else {\n            // numArr.push(arguments);\n            Array.prototype.push.apply(numArr, arguments);\n        }\n    }\n})();\n\n/* =============== 客户端调用 =============== */\nadd(21);\nadd(2);\n\nconsole.log(add()); // 23\n</code></pre>\n<h2><a id=\"_6\"></a>三. 通用的柯里化函数</h2>\n<p>柯里化的操作可以概括为：</p>\n<ul>\n<li>接受一个函数；</li>\n<li>返回一个只接收一个参数的函数。</li>\n</ul>\n<p>通用的柯里化函数可以如下：</p>\n<pre><code>var currying = function(fn) {\n    var args = [];\n\n    return function() {\n        if(arguments.length === 0) {\n            // 进行真正的求值计算\n            return fn.apply(this, args);\n        } else {\n            // 保存调用的所有参数\n            Array.prototype.push.apply(args, arguments);\n            return arguments.callee;\n        }\n    }\n};\n</code></pre>\n<p>那么上面的add函数可以改写成如下：</p>\n<pre><code>var add = (function() {\n    var result = 0;\n    return function() {\n        for(var i = 0, len = arguments.length; i < len; i++) {\n            result += arguments[i];\n        }\n        return result;\n    }\n})();\n</code></pre>\n<p>调用结果如下：</p>\n<pre><code>/* =============== 客户端调用 =============== */\nvar addCurrying = currying(add); // 转换成currying函数\naddCurrying(21);\naddCurrying(2);\n\nconsole.log(addCurrying()); // 23\n</code></pre>\n<h2><a id=\"_7\"></a>四. 反柯里化</h2>\n<p>反柯里化与柯里化相反，就是把原来已经固定的参数或者this上下文等当作参数延迟到未来传递。</p>\n<p>反柯里化的作用在与扩大函数的适用性，使本来作为特定对象所拥有的功能的函数可以被任意对象所用。更通俗的解释说反柯里化是 函数的借用，是函数能够接受处理其他对象，通过借用泛化、扩大了函数的使用范围。</p>\n<p>反柯里化的三种写法如下：</p>\n<h3><a id=\"_8\"></a>4.1 写法一：</h3>\n<pre><code>var uncurrying= function (fn) {\n    return function () {\n        var context = [].shift.call(arguments);\n        return fn.apply(context, arguments);\n    }\n};\n</code></pre>\n<h3><a id=\"_9\"></a>4.2 写法二：</h3>\n<pre><code>var uncurrying = function(fn) {\n    return function() {\n        return Function.prototype.call.apply(fn, arguments);\n    }\n}\n</code></pre>\n<h3><a id=\"_10\"></a>4.3 写法三：</h3>\n<pre><code>var uncurrying = Function.prototype.bind.bind(Function.prototype.call);\n</code></pre>\n<h3><a id=\"_11\"></a>4.4 反柯里化的实际调用示例：</h3>\n<pre><code>/* =============== 客户端调用 =============== */\nvar push = uncurrying(Array.prototype.push); // 反柯里化\n\nvar arr = {}; \npush( arr , [\"Bob\" , \"Jenny\" , \"Tom\"] );\n\nconsole.log(arr); // Object {0: \"Bob\", 1: \"Jenny\", 2: \"Tom\", length: 3}\n</code></pre>\n<h2><a id=\"_12\"></a>五. 柯里化的适用场景</h2>\n<p>当一个函数传递的参数绝大多数是相同的，且函数结果的可以推迟到参数耗尽时才计算，那么该函数就适合使用柯里化。</p>\n<h2><a id=\"_13\"></a>六. 柯里化的性能分析</h2>\n<p>柯里化肯定会有一些性能开销，具体性能分析如下：</p>\n<ul>\n<li>存取 arguments 对象通常要比存取命名参数要慢一些；</li>\n<li>一些老版本的浏览器在 arguments.length 的实现上相当慢；</li>\n<li>使用 fn.apply() 和 fn.call() 要比直接调用 fn() 要慢点；</li>\n<li>创建大量嵌套作用域和闭包会带来开销。</li>\n</ul>\n<h2><a id=\"_14\"></a>七. 总结</h2>\n<p>函数柯里化允许和鼓励你分隔复杂功能变成更小更容易分析的部分。这些小的逻辑单元显然是更容易理解和测试的，然后你的应用就会变成干净而整洁的组合，由一些小单元组成的组合。</p>\n<p>但是函数柯里化也会带来一些性能开销。在项目开发中斟酌使用。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1161\">http://www.dengzhr.com/js/1161</a></div>\n\n        ','2','1'),(216,'设计模式笔记（四）：JavaScript中的中介者模式','\n\n            <h2>一. 中介者模式的定义</h2>\n<blockquote><p>中介者模式的定义：<strong>用一个中介对象来封装一系列的对象交互</strong>。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p></blockquote>\n<p>中介者模式的作用是接触对象与对象之间的紧耦合关系。</p>\n<h2>二. 中介者模式的实现</h2>\n<p>在中介者模式中，独立的对象（colleague）之间并不直接通信，而是通过中介者对象。当其…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 中介者模式的定义</h2>\n<blockquote><p>中介者模式的定义：<strong>用一个中介对象来封装一系列的对象交互</strong>。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p></blockquote>\n<p>中介者模式的作用是接触对象与对象之间的紧耦合关系。</p>\n<h2><a id=\"_5\"></a>二. 中介者模式的实现</h2>\n<p>在中介者模式中，独立的对象（colleague）之间并不直接通信，而是通过中介者对象。当其中一个colleague对象改变状态以后，它将会通知该中介者对象，而中介者对象将会把该变化传达到任意其他应该知道此变化的colleague对象。</p>\n<p>用代码表示如下：</p>\n<pre><code>/* ================ 中介者对象 ================ */\nvar mediator = {\n    change: function(obj) {\n        switch (obj) {\n            case colleague1:\n                // colleague1 的具体交互 ... ...\n                break;\n            case colleague2:\n                // colleague2 的具体交互 ... ...\n                break;\n            case colleague3:\n                // colleague3 的具体交互 ... ...\n                break;\n            case colleague4:\n                // colleague4 的具体交互 ... ...\n                break;\n         }\n\n        console.log(obj.name + \" has changed!\");\n    }\n};\n\n/* ================ colleague对象 ================ */\nvar Colleague = function(name) {\n    this.name = name;\n\n    // colleague对象的功能和方法 ... ... \n};\nColleague.prototype.change = function() {\n    mediator.change(this); // 给中介者对象发送消息\n};\n\nvar colleague1 = new Colleague(\"colleague1\"),\n    colleague2 = new Colleague(\"colleague2\"),\n    colleague3 = new Colleague(\"colleague3\"),\n    colleague4 = new Colleague(\"colleague4\");\n\n/* ================ 客户端调用 ================ */\ncolleague1.change(); // 打印\"colleague1 has changed!\"，且完成colleague1的change事件操作\ncolleague2.change(); // 打印\"colleague2 has changed!\"，且完成colleague2的change事件操作\ncolleague3.change(); // 打印\"colleague3 has changed!\"，且完成colleague3的change事件操作\ncolleague4.change(); // 打印\"colleague4 has changed!\"，且完成colleague4的change事件操作\n</code></pre>\n<h2><a id=\"_6\"></a>三. 中介者模式的优缺点</h2>\n<p>中介者模式使得各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。</p>\n<p>然而，中介者模式最大的缺点就是系统中新增一个中介者对象，因此对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象自身往往就是一个难以维护的对象。</p>\n<h2><a id=\"_7\"></a>四. 中介者模式的适用场景</h2>\n<p>中介者模式可以很方便地对模块或对象进行解耦，一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。</p>\n<p>一般来说，如果对象之间的复杂耦合确实导致调用和维护出现困难，且耦合度随项目变化越来越高，则可以考虑使用中介者模式来重构代码。</p>\n<h2><a id=\"_8\"></a>五. 总结</h2>\n<p>中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原色，是指一个对象应该尽可能少地了解另外的对象。而在中介者模式中，对象之间几乎不存在彼此间的联系，只能通过中介者对象来互相影响。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1136\">http://www.dengzhr.com/js/1136</a></div>\n\n        ','2','1'),(217,'canvas在高倍屏下变模糊的处理办法','\n\n            <h2>一. 事起缘由</h2>\n<p>最近在用Canvas做社区网站的<a href=\"https://my.oschina.net/\">技能雷达图</a>，如下图所示。</p>\n<p>一倍屏下的显示情况：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/gk0cg92qwho608jewlhw09hi/image_1au479vu344r18fqg3b74a4859.png\" alt=\"image_1au479vu344r18fqg3b74a4859.png-7.2kB\"></p>\n<p>二倍屏下的显示情况：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/zsbacvcreved1q0l67vrh602/mohu.png\" alt=\"mohu.png-12.3kB\"></p>\n<p>正当我很开心的准备发布出去时，用Mac Book 开发的同事跟我说，这简直是糊得不要不要的呀~( ╯□╰ )~。。纳尼可是我的华硕显示十分完美呀，这就十分尴尬了。</p>\n<p>猜想是Canvas毕竟类似于位图，在Retina屏下如果不做多倍屏显示处理的话，图片应该会模糊。Google了一翻，果然如此。</p>\n<h2>二. 问题分析</h2>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 事起缘由</h2>\n<p>最近在用Canvas做社区网站的<a href=\"https://my.oschina.net/\">技能雷达图</a>，如下图所示。</p>\n<p>一倍屏下的显示情况：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/gk0cg92qwho608jewlhw09hi/image_1au479vu344r18fqg3b74a4859.png\" alt=\"image_1au479vu344r18fqg3b74a4859.png-7.2kB\"></p>\n<p>二倍屏下的显示情况：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/zsbacvcreved1q0l67vrh602/mohu.png\" alt=\"mohu.png-12.3kB\"></p>\n<p>正当我很开心的准备发布出去时，用Mac Book 开发的同事跟我说，这简直是糊得不要不要的呀~( ╯□╰ )~。。纳尼可是我的华硕显示十分完美呀，这就十分尴尬了。</p>\n<p>猜想是Canvas毕竟类似于位图，在Retina屏下如果不做多倍屏显示处理的话，图片应该会模糊。Google了一翻，果然如此。</p>\n<h2><a id=\"_5\"></a>二. 问题分析</h2>\n<p>因为canvas不是矢量图，而是像图片一样是位图模式的。如果不做Retina屏适配的话，例如二倍屏，浏览器就会以2个像素点的宽度来渲染一个像素，该canvas在Retina屏幕下相当于占据了2倍的空间，相当于图片被放大了一倍，因此图片会变模糊。</p>\n<p>因此，要做Retina屏适配，关键是知道当前屏幕的设备像素比，然后将canvas放大到该设备像素比来绘制，然后将canvas压缩到一倍来展示。</p>\n<h2><a id=\"_6\"></a>三. 解决办法</h2>\n<p>因此，要做Retina屏适配，关键是知道当前canvas的实际渲染倍率，然后将canvas放大到该倍率来绘制，最后将canvas压缩成一倍的物理大小来展示。</p>\n<p>需要注意的是，canvas中的线条大小、文字大小等都需要乘以该倍率来进行绘制。</p>\n<h3><a id=\"_7\"></a>3.1 canvas的实际渲染倍率</h3>\n<p>在浏览器的window变量中有一个devicePixelRatio的属性，该属性表示了屏幕的设备像素比，即用几个（通常是2个）像素点宽度来渲染1个像素。</p>\n<p>在canvas context中也存在一个 webkitBackingStorePixelRatio 的属性，该属性的值决定了浏览器在渲染canvas之前会用几个像素来来存储画布信息。在iOS6下的safari中的值是2，但是在chrome和iOS7的safari中的值却是1。在iOS6下的safari中，如果有一张100 × 100像素的图片绘制，该图片首先会在内存中生成一张200 × 200的图片，然后再浏览器渲染时会按100 × 100的图片来显示，因此不会出现模糊失真的情况。而在在chrome和iOS7的safari中就会出现模糊。</p>\n<p>但是webkitBackingStorePixelRatio属性在各浏览器厂商的获取方式不一样，所以需要加上浏览器前缀来实现兼容。</p>\n<p>如下：</p>\n<pre><code>var canvas = document.getElementById(\"canvas\"),\n        context= canvas.getContext(\"2d\");  \n\n// 屏幕的设备像素比\nvar devicePixelRatio = window.devicePixelRatio || 1;\n\n// 浏览器在渲染canvas之前存储画布信息的像素比\nvar backingStoreRatio = context.webkitBackingStorePixelRatio ||\n                    context.mozBackingStorePixelRatio ||\n                    context.msBackingStorePixelRatio ||\n                    context.oBackingStorePixelRatio ||\n                    context.backingStorePixelRatio || 1;\n\n// canvas的实际渲染倍率\nvar ratio = devicePixelRatio / backingStoreRatio;\n</code></pre>\n<h3><a id=\"_8\"></a>3.2 按实际渲染倍率来缩放canvas</h3>\n<p>先补充一个基础知识点：</p>\n<blockquote>\n<ul>\n<li>要设置canvas的画布大小，使用的是<code>canvas.width</code> 和 <code>canvas.height</code>；</li>\n<li>要设置画布的实际渲染大小，使用的style或CSS设置的 <code>width</code> 和<code>height</code>，只是简单的对画布进行缩放。</li>\n</ul>\n</blockquote>\n<p>譬如：</p>\n<pre><code><canvas width=\"640\" height=\"800\" style=\"width:320px; height:400px\"></canvas>\n</code></pre>\n<p>canvas的实际大小的640px × 800px，但是实际渲染到页面的大小是320px × 400px，相当于缩小一倍来显示。</p>\n<p>因此，要使canvas适配高倍屏，就是要将canvas放大到设备像素比来绘制，最后将canvas压缩成一倍的物理大小来展示。如下：</p>\n<pre><code>canvas.style.width = canvas.width;\ncanvas.style.height = canvas.height;\n\ncanvas.width = canvas.width * ratio;\ncanvas.height = canvas.height * ratio;\n</code></pre>\n<h3><a id=\"_9\"></a>3.3 实际渲染效果：</h3>\n<p>实际渲染效果如下：</p>\n<h4><a id=\"_10\"></a>一倍屏下：</h4>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/gk0cg92qwho608jewlhw09hi/image_1au479vu344r18fqg3b74a4859.png\" alt=\"image_1au479vu344r18fqg3b74a4859.png-7.2kB\"></p>\n<pre><code><canvas width=\"200\" height=\"120\" style=\"width: 200px; height: 120px;\"></canvas>\n</code></pre>\n<h4><a id=\"_11\"></a>二倍屏下：</h4>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/gk0cg92qwho608jewlhw09hi/image_1au479vu344r18fqg3b74a4859.png\" alt=\"image_1au479vu344r18fqg3b74a4859.png-7.2kB\"></p>\n<pre><code><canvas width=\"400\" height=\"240\" style=\"width: 200px; height: 120px;\"></canvas>\n</code></pre>\n<h4><a id=\"_12\"></a>三倍屏下：</h4>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/gk0cg92qwho608jewlhw09hi/image_1au479vu344r18fqg3b74a4859.png\" alt=\"image_1au479vu344r18fqg3b74a4859.png-7.2kB\"></p>\n<pre><code><canvas width=\"600\" height=\"360\" style=\"width: 200px; height: 120px;\"></canvas>\n</code></pre>\n<p>Perfect！</p>\n<h3><a id=\"_13\"></a>3.4 注意事项</h3>\n<p>canvas中的线条大小、文字大小等都需要乘以设备像素比来进行绘制，否则高倍屏下的线条会变细几倍。</p>\n<h2><a id=\"_14\"></a>四. 应用实例</h2>\n<p>该雷达图的实现代码已存放到Github上，地址： <a href=\"https://github.com/dengzhirong/radarChart\">https://github.com/dengzhirong/radarChart</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/1050\">http://www.dengzhr.com/frontend/html/1050</a></div>\n\n        ','2','1'),(218,'JavaScript cookie 的工具函数封装','\n\n            <h2>一. 语法</h2>\n<h3>1.1 获取当前页面的所有cookie：</h3>\n<pre><code>var allCookies = document.cookie;\n</code></pre>\n<p>allCookies 是一个字符串，其中包含了以分号分隔的cookie列表字符串 (即 <code>key=value</code> 键值对)。</p>\n<h3>1.2 写一个新cookie：</h3>\n<pre><code>document.cookie = updatedCookie;\n</code></pre>\n<p>updatedCookie是一个键值对形式的字符串。只能用这个…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 语法</h2>\n<h3><a id=\"_5\"></a>1.1 获取当前页面的所有cookie：</h3>\n<pre><code>var allCookies = document.cookie;\n</code></pre>\n<p>allCookies 是一个字符串，其中包含了以分号分隔的cookie列表字符串 (即 <code>key=value</code> 键值对)。</p>\n<h3><a id=\"_6\"></a>1.2 写一个新cookie：</h3>\n<pre><code>document.cookie = updatedCookie;\n</code></pre>\n<p>updatedCookie是一个键值对形式的字符串。只能用这个方法一次设置或更新一个cookie，而且写入并不是覆盖，而是添加。例如：</p>\n<pre><code>document.cookie = \"fontSize=14\";\ndocument.cookie = \"fontSize=16\";\ndocument.cookie = \"fontColor=black\";\n\ndocument.cookie; // fontSize=16;fontColor=black\n</code></pre>\n<h3><a id=\"_7\"></a>1.3 可选属性：</h3>\n<p>除了Cookie本身的内容，还有一些可选的属性也是可以写入的，定义cookie的设定/更新，跟着一个分号以作分隔：</p>\n<pre><code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]\n</code></pre>\n<blockquote>\n<ul>\n<li>(1) <strong>path=path</strong> (例如 ‘/’, ‘/mydir’) 如果没有定义，默认为当前文档位置的路径。</li>\n<li>(2) <strong>domain=domain</strong> (例如 ‘example.com’， ‘.example.com’ (包括所有子域名), ‘subdomain.example.com’) 如果没有定义，默认为当前文档位置的路径的域名部分。</li>\n<li>(3) <strong>max-age=max-age-in-seconds</strong> (例如一年为60<em>60</em>24*365)</li>\n<li>(4) <strong>expires=date-in-GMTString-format</strong> 如果没有定义，cookie会在对话结束时过期。这个值的格式参见<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString\">Date.toUTCString()</a> 。</li>\n<li>(5) <strong>secure</strong> (cookie只通过https协议传输) cookie的值字符串可以用encodeURIComponent()来保证它不包含任何逗号、分号或空格(cookie值中禁止使用这些值)。</li>\n</ul>\n</blockquote>\n<h3><a id=\"_8\"></a>二. cookie的接口封装：</h3>\n<pre><code>var cookieUtil = {\n    // 设置cookie\n    setItem: function(name, value, days) {\n        var date=new Date();\n        date.setDate(date.getDate()+days);\n        document.cookie=name+\'=\'+value+\';expires=\'+date;\n    },\n\n    // 获取cookie\n    getItem: function(name) {\n         var arr=document.cookie.replace(/\\s/g, \"\").split(\';\');\n         for(var i=0;i<arr.length;i++) {\n             var tempArr=arr[i].split(\'=\');\n             if(tempArr[0]==name) {\n                return decodeURIComponent(tempArr[1]);\n             }\n         }\n         return \'\';\n    },\n\n    // 删除cookie\n    removeItem: function(name) {\n        this.setItem(name,\'1\', -1);\n    },\n\n    // 检查是否含有某cookie\n    hasItem: function(name) {\n        return (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(name).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(document.cookie);\n    },\n\n    // 获取全部的cookie列表\n    getAllItems: function() {\n        var cookieArr = document.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/);\n        for (var nIdx = 0; nIdx < cookieArr.length; nIdx++) { cookieArr[nIdx] = decodeURIComponent(cookieArr[nIdx]); }\n        return cookieArr;\n    }\n};\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1053\">http://www.dengzhr.com/js/1053</a></div>\n\n        ','2','1'),(219,'设计模式笔记（三）：JavaScript中的代理模式','\n\n            <h2>一. 代理模式的定义</h2>\n<blockquote><p>代理模式的定义：为其他对象提供一种代理，以控制对着这个对象的访问。</p></blockquote>\n<p>在代理模式中，一个对象充当另一个对象的接口。</p>\n<p>这种模式看起来像是额外的开销，但是出于性能因素的考虑却是非常有用的。代理充当了本体对象的守护对象，并且试图使本体对象做尽可能少的工作。</p>\n<h2>二. 代理模式的适用场景</h2>\n<p>代理模式的适用场景有：</p>\n<ul>\n<li><strong>延迟一个大对象的实例化</strong>；</li>\n<li><strong>访问远程对象</strong>；</li>\n<li><strong>访问控制</strong>；</li>\n<li>… …</li>\n</ul>\n<h2>三. 代理模式的实现</h2>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 代理模式的定义</h2>\n<blockquote><p>代理模式的定义：为其他对象提供一种代理，以控制对着这个对象的访问。</p></blockquote>\n<p>在代理模式中，一个对象充当另一个对象的接口。</p>\n<p>这种模式看起来像是额外的开销，但是出于性能因素的考虑却是非常有用的。代理充当了本体对象的守护对象，并且试图使本体对象做尽可能少的工作。</p>\n<h2><a id=\"_5\"></a>二. 代理模式的适用场景</h2>\n<p>代理模式的适用场景有：</p>\n<ul>\n<li><strong>延迟一个大对象的实例化</strong>；</li>\n<li><strong>访问远程对象</strong>；</li>\n<li><strong>访问控制</strong>；</li>\n<li>… …</li>\n</ul>\n<h2><a id=\"_6\"></a>三. 代理模式的实现</h2>\n<p>在代理模式中，一个对象充当另一个对象的接口，使得本体对象做尽可能少的工作。</p>\n<pre><code>/* =============== 本体类 =============== */\nvar Client = function() {};\nClient.prototype = {\n    add: function() {\n        // 添加功能... ...\n    },\n    delete: function() {\n        // 删除功能... ...\n    },\n    update: function() {\n        // 修改功能... ...\n    }\n};\n\n/* =============== 代理类 =============== */\nvar Proxy = function() {\n    this.client = new Client();\n};\nProxy.prototype = {\n    add: function() {\n        return this.client.add();\n    },\n    delete: function() {\n        return this.client.delete();\n    },\n    update: function() {\n        return this.client.update();\n    }\n};\n</code></pre>\n<h3><a id=\"_7\"></a>3.1 虚拟代理</h3>\n<p>假如Client类有很多方法，并且大多数都庞大且复杂，为了实例它会占用很多很多CPU。那当我们需要使用这个对象时才去实例化它不是更好吗？<strong>虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建</strong>。</p>\n<p>我们把上面的代码用虚拟代理重构一下：</p>\n<pre><code>/* =============== 本体类 =============== */\nvar Client = function() {};\nClient.prototype = {\n    add: function() {\n        // 添加功能... ...\n    },\n    delete: function() {\n        // 删除功能... ...\n    },\n    update: function() {\n        // 修改功能... ...\n    }\n};\n\n\n/* =============== 代理类 =============== */\nvar Proxy = function() {\n    this.client = null;\n};\nProxy.prototype = {\n    // 在必要的时候才创建实例对象\n    _init: function() {\n        if (!this.client) {\n            this.client = new Client();\n        }\n    },\n    add: function() {\n        this._init();\n        return this.client.add();\n    },\n    delete: function() {\n        this._init();\n        return this.client.delete();\n    },\n    update: function() {\n        this._init();\n        return this.client.update();\n    }\n};\n</code></pre>\n<h3><a id=\"_8\"></a>3.2 缓存代理</h3>\n<p>缓存代理可以为一些开销大的运算结果提供暂时的存储。在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。</p>\n<p>例如：</p>\n<pre><code>/* =============== 开销大的本体类 =============== */\nvar calculate = function() {\n    var result;\n\n    // 复杂且庞大的计算 .... ...\n\n    return result;\n};\n\n/* =============== 缓存代理类 =============== */\nvar calculateProxy = (function() {\n    var cache = {}; // 缓存计算结果\n\n    return function() {\n        var args = Array.prototype.join.call(arguments, \",\");\n        if(args in cache) {\n            return cache[args];\n        }\n        return cache[args] = calculate.apply(this, arguments);\n    }\n})();\n\n/* =============== 客户端实现 =============== */\ncalculateProxy(1, 2, 3, 4, 5); // 本体calculate函数被计算，并写入缓存结果\ncalculateProxy(1, 2, 3, 4, 5); // 本体calculate函数并没有被计算，而是直接返回之前缓存好的计算结果\ncalculateProxy(1, 2, 3); // 本体calculate函数被计算，并写入缓存结果\n</code></pre>\n<p>通过增加缓存代理的方式，本体calculate函数可以专注于自身的计算职能，而缓存的额功能则由代理对象来实现。</p>\n<h3><a id=\"_9\"></a>3.3 用高阶函数动态创建代理</h3>\n<p>通过传入高阶函数这种更加灵活的方式，可以为各种计算方法创建缓存代理。这些方法被当作参数传入一个专门用于创建缓存代理的工厂中。这样，我们就可以为加减乘除等创建缓存代理，代码如下：</p>\n<pre><code>/********** 计算乘积 **********/\nvar mult = function() {\n    var result = 1;\n    for(var i = 0, l = arguments.length; i < l; i++) {\n        result = result * arguments[i];\n    }\n    return result;\n};\n/********** 计算加和 **********/\nvar plus = function() {\n    var result = 0;\n    for(var i = 0, l = arguments.length; i < l; i++) {\n        result = result + arguments[i];\n    }\n    return result;\n};\n\n/********** 创建缓存代理的工厂 **********/\nvar createProxyFactory = function(fn) {\n    var cache = {};\n\n    return function() {\n       var args = Array.prototype.join.call(arguments, \",\");\n        if(args in cache) {\n            return cache[args];\n        }\n        return cache[args] = fn.apply(this, arguments); \n    };\n};\n\nvar multProxy = createProxyFactory(mult);\nvar plusProxy = createProxyFactory(plus);\n\n/********** 客户端实现 **********/\nmultProxy(1, 2, 3, 4, 5); // 120\nplusProxy(1, 2, 3, 4, 5); // 15\n</code></pre>\n<h3><a id=\"_10\"></a>3.4 其他代理模式</h3>\n<p>代理模式的变种很多，主要有：</p>\n<ul>\n<li>远程代理：为一个对象在不同的地址空间提供局部代表。</li>\n<li>保护代理：用于控制不同权限的对象对目标对象的访问。</li>\n<li>智能引用代理：取代了简单的指针，它在访问对象时执行了一些附加操作，比如计算一个对象被引用的次数。</li>\n<li>… …</li>\n</ul>\n<p>代理模式包括许多小分类，在JavaScript开发中最常用的是虚拟代理和缓存代理。</p>\n<h2><a id=\"_11\"></a>四. 代理模式的实际应用</h2>\n<h3><a id=\"_12\"></a>4.1 虚拟代理实现图片预加载</h3>\n<p>在Web开发中，由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张图片作为loading图占位，然后用异步的方式加载图片，等图片加载完成后再将其插入img节点中。这种延迟初始化的场景就很适合使用虚拟代理。</p>\n<p>引入代理对象proxyImage，通过这个代理对象，在图片被真正加载完成之前，将出现一张占位的菊花图loading.gif，来提示用户图片正在加载。如下：</p>\n<pre><code>var myImage = (function() {\n    var imgNode = document.createElement(\"img\");\n    document.body.appendChild(imgNode);\n\n    return {\n        setSrc: function(src) {\n            imgNode.src = src;\n        }\n    };\n})();\n\nvar proxyImage = (function() {\n    var img = new Image;\n    img.onload = function() {\n        myImage.setSrc(this.src);\n    };\n    return {\n        setSrc: function(src) {\n            myImage.setSrc(\"loading.gif\");\n            img.src = src;\n        }\n    };\n})();\n\nproxyImage.setSrc(\"http://127.0.0.1/1.jpg\");\n</code></pre>\n<p><em>备注：该代码摘抄自《JavaScript设计模式与开发实践》第6章P92。</em></p>\n<h3><a id=\"_13\"></a>4.2 虚拟代理实现合并HTTP请求</h3>\n<p>假设在做一个标签管理的功能时，当点击标签删除按钮，该对应的标签就会对服务器进行标签删除的网络请求。当在短时间内点击多次标签删除按钮，可以预见，如此频繁的网络请求将会带来相当大的开销。</p>\n<p>解决方案是：我们可以收集一段时间内的请求，最后一次性发送给服务器。比如等待2秒钟之后，才把这2秒之内需要删除的标签打包发送给服务器。</p>\n<pre><code>/* ============== 删除标签的本体类 ============== */\nvar deleteTag = function(tagName) {\n    // 删除标签的网络请求与功能实现\n    // ... ...\n}\n\n/* ============== 删除标签的代理类 ============== */\nvar deleteTagProxy = (function() {\n    var cache = [], // 保存一段时间需要删除的标签名\n        timer; // 定时器\n\n    return function(tagName) {\n        cache.push(tagName);\n        if(timer) { // 保证不会覆盖已经启动的定时器\n            return;\n        }\n\n        // 2s后向本体发送需要同步的标签名集合\n        timer = setTimeout(function() {\n            deleteTag(cache.join(\",\"));\n\n            // 清空定时器\n            clearTimeout(timer);\n            timer = null;\n\n            // 清空标签名集合\n            cache = [];\n        }, 2000);\n    };\n})();\n\n/* ============== 删除标签的交互实现 ============== */\n/* \n * 标签删除按钮的DOM结构为：<div class=\"btn-delete-tag\" data-tagName=\"my-tag\"></div>\n */\nvar deleteTagBtn = document.getElementByClassName(\"btn-delete-tag\");\n\ndeleteTagBtn.forEach(function(element, index) {\n    element.addEventListener(\"click\", function() {\n\n        deleteTagProxy(this.dataSet.tagName);\n\n    }, false);\n});\n</code></pre>\n<h3><a id=\"_14\"></a>4.3 缓存代理用于ajax异步请求数据</h3>\n<p>在项目中常常会遇到分页的需求。同一页的数据理论上只需要去后台拉去一次。这些已经拉取好的数据在某个地方被缓存之后，下次再请求同一页时，便可以直接从缓存中读取数据。</p>\n<p>这里适合使用缓存代理模式。</p>\n<pre><code>/* =============== ajax工具函数 =============== */\nfunction ajax(options) {\n    options = options || {};\n    options.type = (options.type || \"GET\").toUpperCase();\n    options.dataType = options.dataType || \"json\";\n    var params = formatParams(options.data);\n\n    //创建XMLHttpRequest\n    if (window.XMLHttpRequest) { // IE6+及现代浏览器\n        var xhr = new XMLHttpRequest();\n    } else { //IE6及其以下版本浏览器\n        var xhr = new ActiveXObject(\'Microsoft.XMLHTTP\');\n    }\n\n    // 接收数据\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n            var status = xhr.status;\n            if (status >= 200 && status < 300) {\n                options.success && options.success(xhr.responseText, xhr.responseXML);\n            } else {\n                options.fail && options.fail(status);\n            }\n        }\n    }\n\n    // 连接和发送数据\n    if (options.type == \"GET\") {\n        xhr.open(\"GET\", options.url + \"?\" + params, true);\n        xhr.send(null);\n    } else if (options.type == \"POST\") {\n        xhr.open(\"POST\", options.url, true);\n        xhr.send(params);\n    }\n}\n\n//格式化参数\nfunction formatParams(data) {\n    var arr = [];\n    for (var name in data) {\n        arr.push(encodeURIComponent(name) + \"=\" + encodeURIComponent(data[name]));\n    }\n    arr.push((\"v=\" + Math.random()).replace(\".\",\"\"));\n    return arr.join(\"&\");\n}\n\n/* =============== ajax异步请求分页数据 =============== */\nvar getPageContext = function(pageId) {\n    var result;\n    ajax({\n        url: \"/test/index.php\",\n        method: \"get\",\n        dataType: \"json\",\n        data: {\n            id: pageId\n        },\n        success: function(response) {\n             result = response;\n        }\n    });\n    return result;\n};\n\n/* =============== 缓存代理类 =============== */\nvar getPageContextProxy = (function() {\n    var cache = {}; // 缓存计算结果\n\n    return function() {\n        var args = Array.prototype.join.call(arguments, \",\");\n        if(args in cache) {\n            return cache[args];\n        }\n        return cache[args] = getPageContext.apply(this, arguments);\n    }\n})();\n\n/* =============== 客户端实现 =============== */\ngetPageContextProxy(1); // 向服务器请求第1页数据\ngetPageContextProxy(2); // 向服务器请求第2页数据\ngetPageContextProxy(1); // 从缓存中读取第1页数据\n</code></pre>\n<h2><a id=\"_15\"></a>五. 总结</h2>\n<p>在JavaScript开发中最常用的是虚拟代理和缓存代理。</p>\n<p>虽然代理模式很有用，但是在实际业务开发中，往往不需要去预先猜测是否需要使用代理模式。当真正发现不方便直接访问某个对象时，再编写代理也不迟。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1132\">http://www.dengzhr.com/js/1132</a></div>\n\n        ','2','1'),(220,'Web RTC学习笔记','\n\n            <p>备注：初学，整理一下资料~~</p>\n<p>WebRTC，网页实时通信，Web Real-Time Communication的缩写，是一个支持网页浏览器进行实时语音通话或视频聊天的技术，是谷歌2010年以6820万美元收购Global IP Solutions公司而获得的一项技术。</p>\n<p>WebRTC提供了实时音视频的核心技术，包括音视频的采集、编�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>备注：初学，整理一下资料~~</p>\n<p>WebRTC，网页实时通信，Web Real-Time Communication的缩写，是一个支持网页浏览器进行实时语音通话或视频聊天的技术，是谷歌2010年以6820万美元收购Global IP Solutions公司而获得的一项技术。</p>\n<p>WebRTC提供了实时音视频的核心技术，包括音视频的采集、编解码、网络传输、显示等功能，并且还支持跨平台：windows，linux，mac，android。</p>\n<h2><a id=\"_4\"></a>兼容性</h2>\n<p>目前Chrome、Firefox、Opera已支持。具体可查看：<a href=\"http://caniuse.com/#search=webrtc\">http://caniuse.com/#search=webrtc</a></p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/qadqcgvno6kj15bbb5sm3gqq/image_1atqd8bqu1sj2vglbdkh3l1eq69.png\" alt=\"image_1atqd8bqu1sj2vglbdkh3l1eq69.png-37.4kB\"></p>\n<h2><a id=\"_5\"></a>安全性</h2>\n<p>这里有几个实时通信应用可以出现的安全性问题：</p>\n<ul>\n<li>未加密的媒体数据流可以会在浏览器或通信途中被获取。</li>\n<li>应用可能会在用户不知情的情况下记录视频和其它信息。</li>\n<li>恶意软件或病毒可能被安装在一个不起眼的插件或应用中。</li>\n</ul>\n<p>WebRTC通过各种特性避免了这些问题：</p>\n<ul>\n<li>WebRTC 实现很多用户安全协议，比如DTLS和SRTP。</li>\n<li>对数据流和信号量进行编码加密。</li>\n<li>摄像头和手机必须通过严格的授权，只有在显示用户界面的时候才能调用。</li>\n</ul>\n<h2><a id=\"_6\"></a>WebRTC API：</h2>\n<blockquote>\n<ul>\n<li><strong>MediaStream</strong> (别名 getUserMedia) // 取得数据流，比如从摄像头和手机中获取</li>\n<li><strong>RTCPeerConnection</strong> // 音频和视频通话，设备加密和带宽管理</li>\n<li><strong>RTCDataChannel</strong> // 点对点通信</li>\n</ul>\n</blockquote>\n<h2><a id=\"_7\"></a>现成的WebRTC库或框架</h2>\n<p>webRTC.io： <a href=\"https://github.com/webRTC-io/webRTC.io\">https://github.com/webRTC-io/webRTC.io</a></p>\n<p>SimpleWebRTC：<a href=\"https://github.com/andyet/SimpleWebRTC\">https://github.com/andyet/SimpleWebRTC</a></p>\n<p>EasyRTC：<a href=\"https://github.com/priologic/easyrtc\">https://github.com/priologic/easyrtc</a></p>\n<h2><a id=\"_8\"></a>推荐阅读</h2>\n<ul>\n<li>Capturing Audio & Video in HTML5 <a href=\"http://www.html5rocks.com/zh/tutorials/getusermedia/intro/#toc-webaudio-api\">http://www.html5rocks.com/zh/tutorials/getusermedia/intro/#toc-webaudio-api</a></li>\n<li>WebRTC Google官方教程 <a href=\"https://codelabs.developers.google.com/codelabs/webrtc-web/#0\">https://codelabs.developers.google.com/codelabs/webrtc-web/#0</a></li>\n<li>WebRTC API （MDN文档） <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API\">https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API</a></li>\n<li>WebRTC（by 阮一峰大神） <a href=\"http://javascript.ruanyifeng.com/htmlapi/webrtc.html\">http://javascript.ruanyifeng.com/htmlapi/webrtc.html</a></li>\n</ul>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1035\">http://www.dengzhr.com/js/1035</a></div>\n\n        ','2','1'),(221,'[小gist] 用正则提取固定字符之间的字符串','\n\n            <p>在JS的正则零宽断言匹配中，只支持前瞻匹配，不支持后瞻。这就尴尬了，因为在业务当中，我们大多时候是知道了要目标数据的前后缀字符串，但是并不想连同前后缀一起获取。</p>\n<p>为了模拟后瞻，我想，要不就用笨方法，先将前后缀字符串一同提取，然后再讲前后缀字符串一同replace为空字符串。于是就有了下面这个简单的方法，但确实很实用：</p>\n<pre><code>// 提取固定字符之间的字符串\nfunction getInnerString(source,</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在JS的正则零宽断言匹配中，只支持前瞻匹配，不支持后瞻。这就尴尬了，因为在业务当中，我们大多时候是知道了要目标数据的前后缀字符串，但是并不想连同前后缀一起获取。</p>\n<p>为了模拟后瞻，我想，要不就用笨方法，先将前后缀字符串一同提取，然后再讲前后缀字符串一同replace为空字符串。于是就有了下面这个简单的方法，但确实很实用：</p>\n<pre><code>// 提取固定字符之间的字符串\nfunction getInnerString(source, prefix, postfix) {\n    var regexp = new RegExp(encodeReg(prefix) + \'.+\' + encodeReg(postfix), \'gi\');\n    var matches = String(source).match(regexp);\n    var formatedMatches =  _.map(matches, value => {\n        return value\n            .replace(prefix, \'\')\n            .replace(postfix, \'\');\n    });\n    return formatedMatches;\n}\n\n//转义影响正则的字符\nfunction encodeReg(source) {\n    return String(source).replace(/([.*+?^=!:${}()|[\\]/\\\\])/g,\'\\\\$1\');\n}\n</code></pre>\n<p>使用：</p>\n<pre><code>var a = \'让我们荡起双桨吧\';\ngetInnerString(a, \'让我们\', \'吧\'); // [\'双桨\']\n\nvar b = \'老总和不在办公室，有事请留言给李秘书\';\ngetInnerString(b, \'有事请留言给\', \'\'); // [\'李秘书\']\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1339\">http://www.dengzhr.com/js/1339</a></div>\n\n        ','2','1'),(222,'【实战】封装一个audio音频组件','\n\n            <p>备注：因为懒得去重复些一堆的事件兼容性函数，先用jQuery库快速捣鼓一个audio音频组件。等以后有空了，再干掉jQuery库的依赖，用纯JavaScript重构一下。</p>\n<p>这个组件包含进度条拖拽，支持自定制audio的样式。体验如下：</p>\n<p><iframe style=\"width: 100%;\" title=\"woEweX\" src=\"//codepen.io/dengzhirong8344/embed/woEweX/?height=649&theme-id=15300&default-tab=js,result&embed-version=2\" width=\"300\" height=\"649\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong8344/pen/woEweX/\">woEweX</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong8344\">@dengzhirong8344</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n<p>直接上代码：</p>\n<h2>组件代码：</h2>\n<pre><code>/*\n* 音频组件\n* options参</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>备注：因为懒得去重复些一堆的事件兼容性函数，先用jQuery库快速捣鼓一个audio音频组件。等以后有空了，再干掉jQuery库的依赖，用纯JavaScript重构一下。</p>\n<p>这个组件包含进度条拖拽，支持自定制audio的样式。体验如下：</p>\n<p><iframe style=\"width: 100%;\" title=\"woEweX\" src=\"//codepen.io/dengzhirong8344/embed/woEweX/?height=649&theme-id=15300&default-tab=js,result&embed-version=2\" width=\"300\" height=\"649\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong8344/pen/woEweX/\">woEweX</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong8344\">@dengzhirong8344</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n<p>直接上代码：</p>\n<h2><a id=\"_4\"></a>组件代码：</h2>\n<pre><code>/*\n* 音频组件\n* options参数：\n*     @param src {String}  # 音频资源\n      @param autoplay {Boolean}  # 是否自动播放。默认值为false\n      @param loop {Boolean}  # 是否循环播放。默认值为true\n      @param btnPlay {String}  # 播放按钮DOM的query\n      @param btnPause {String}  # 暂停按钮DOM的query\n      @param slideBar {String}  # 可滑动进度条DOM的query\n      @param slideThumb {String}  # 可滑动进度条的控制按钮DOM的query\n      @param playing {Function(curTime, duration)}  # 音频正在播放时触发的回调函数，参数分别有当前播放时间、总播放时间\n      @param ended {Function} # 音频播放结束时的回调函数\n      @param seeked {Function} # 音频TimeRange加载完成的回调函数\n* 创建实例的方法：\n      var mp3 = audioComponent.create(options);\n* 实例方法：\n      @method play  # 继续播放音频，回调函数的参数是当前播放时间\n      @method pause  # 暂停音频，回调函数的参数是当前播放时间\n      @method playPause  # 切换视频播放，回调函数的参数是当前播放时间、是否已经暂停\n      @method getDuration  # 获取音频的总播放时间(ms)\n      @method getCurrentTime  # 获取音频当前播放时间(ms)\n      @method onPlaying  # 监听音频播放的回调函数，参数分别有当前播放时间、总播放时间\n */\nfunction audioComponent(options) {\n    // 默认参数设置\n    this.src = options.src || \"\";\n    this.autoplay = options.autoplay || false;\n    this.loop = options.loop || true;\n    this.btnPlay = options.btnPlay || \"\";\n    this.btnPause = options.btnPause || \"\";\n    this.slideBar = options.slideBar || \"\";\n    this.slideThumb = options.slideThumb || \"\";\n    this.playing = options.playing || null;\n    this.ended = options.ended || null;\n    this.seeked = options.seeked || null;\n\n    this.duration = 0;\n    this.currentTime = 0;\n    this.isSlideMouseMove = false;\n};\naudioComponent.prototype = {\n    // 创建audio元素\n    _create: function() {\n        var _this = this;\n        var audio = $(\"<audio>\").attr(\n            {\n                \"src\": _this.src,\n                \"autoplay\": _this.autoplay,\n                \"loop\": _this.loop\n            });\n        $(\"body\").append(audio);\n        _this.audio = audio[0];\n    },\n    // 获取音频播放的总时长\n    _seeked: function() {\n        var _this = this;\n        $(_this.audio).on(\'seeked progress\', function() {\n            _this.duration = _this.audio.seekable.end(0);\n            if(typeof _this.seeked == \"function\") {\n                _this.seeked(_this.duration);\n            }\n        });\n    },\n    // 播放\n    play: function(callback) {\n        var audio = this.audio;\n        audio.play();\n        if(typeof callback == \"function\") {\n            callback(audio.currentTime);\n        }\n    },\n    // 暂停\n    pause: function(callback) {\n        var audio = this.audio;\n        audio.pause();\n        if(typeof callback == \"function\") {\n            callback(audio.currentTime);\n        }\n    },\n    // 播放与暂停切换\n    playPause: function(callback) {\n        var audio = this.audio;\n        var isPause = audio.paused;\n        if(isPause) {\n            this.play();\n        } else {\n            this.pause();\n        }\n        if(typeof callback == \"function\") {\n            callback(audio.currentTime, isPause);\n        }\n    },\n    // 获取音频总播放时间\n    getDuration: function() {\n        return this.duration;\n    },\n    // 获取音频当前播放时间\n    getCurrentTime: function() {\n        return this.currentTime;\n    },\n    // 音频正在播放的回调函数\n    onPlaying: function(callback) {\n        var _this = this,\n            audio = this.audio;\n        this.currentTime = audio.currentTime;\n        if(audio.addEventListener) {\n            audio.addEventListener(\"timeupdate\", function() {\n                if(typeof callback == \"function\") {\n                    callback(audio.currentTime);\n                }\n                if(typeof _this.playing == \"function\") {\n                    _this.playing(audio.currentTime);\n                }\n            });\n        }\n    },\n    // 按钮的事件绑定\n    _domBind: function() {\n        var _this = this;\n        if(this.btnPlay) {\n            $(document).on(\"click\", this.btnPlay, function() {\n                _this.play();\n            });\n        }\n        if(this.btnPause) {\n            $(document).on(\"click\", this.btnPause, function() {\n                _this.pause();\n            });\n        }\n    },\n    // 滑动条事件绑定\n    _slideBind: function() {\n        var _this = this,\n            slideBar = $(this.slideBar),\n            slideThumb = $(this.slideThumb),\n            audio = this.audio;\n        var totalWidth = slideBar.width();\n        // 按钮跟随音乐播放\n        _this.onPlaying(function(curTime) {\n            if(!_this.isSlideMouseMove) {\n                var duration = _this.duration;\n                ratio = totalWidth / duration;\n                slideThumb.css(\"left\", curTime * ratio);\n            }\n        });\n        // 滑块滑动事件绑定\n        var isMousedown = false,\n            initConfig = {\n                time: 0\n            },\n            moveConfig = {};\n        $(document).on(\"mousedown\", this.slideThumb, function(e) {\n            isMousedown = true;\n            initConfig.time = audio.currentTime;\n            initConfig.x = e.pageX;\n            initConfig.left = parseInt($(this).css(\"left\"));\n            _this.isSlideMouseMove = true;\n        })\n        .on(\"mousemove\", this.slideThumb, function(e) {\n            if(isMousedown) {\n                e.preventDefault();\n                moveConfig.x = e.pageX;\n                var deltaX = moveConfig.x - initConfig.x;\n                var slideLeft = initConfig.left + deltaX;\n                if(slideLeft >= totalWidth) {\n                    slideLeft = totalWidth;\n                } else if(slideLeft <= 0) {\n                    slideLeft = 0;\n                }\n                moveConfig.time = slideLeft * _this.duration / totalWidth;\n                slideThumb.css(\"left\", slideLeft);\n            }\n        })\n        .on(\"mouseup\", function(e) {\n            if(isMousedown) {\n                isMousedown = false;\n                audio.currentTime = moveConfig.time;\n                audio.play();\n\n                moveConfig = {};\n                initConfig = {};\n\n                setTimeout(function() {\n                    _this.isSlideMouseMove = false;\n                }, 100);\n            }\n        });\n\n        // 滑动条上的点击事件\n        $(document).on(\"click\", this.slideBar, function(e) {\n            e.stopPropagation();\n            var mouseX = e.pageX;\n            var offsetLeft = $(this).offset().left;\n            var slideLeft = mouseX - offsetLeft;\n            var currentTime = slideLeft * _this.duration / totalWidth;\n            slideThumb.css(\"left\", slideLeft);\n            audio.currentTime = currentTime;\n            audio.play();\n        });\n    },\n    init: function() {\n        this._create();\n        this._seeked();\n        this._domBind();\n        this._slideBind();\n    }\n};\naudioComponent.create = function(options) {\n    var audio = new audioComponent(options);\n    audio.init();\n    return audio;\n};\n</code></pre>\n<h2><a id=\"_5\"></a>组件的使用方法：</h2>\n<pre><code>var $totalTimeText = $(\".text-totalTime\");\nvar $curTimeText = $(\".text-curTime\");\n\n// 实例化一个音频实例\nvar mp3 = audioComponent.create({\n    src: \"danqingke.mp3\",\n    autoplay: false,\n    loop: true,\n    btnPlay: \"#btn-play\",\n    btnPause: \"#btn-pause\",\n    slideBar: \".slidebar\",\n    slideThumb: \".slide-thumb\",\n    seeked: function(duration) {\n        var totalTimeText = timeFormat(duration);\n        $totalTimeText.text(totalTimeText);\n    },\n    playing: function(curtime, duration) {\n        var curTimeText = timeFormat(curtime);\n        $curTimeText.text(curTimeText);\n    },\n});\n\n// 时间格式化 mm:ss\nfunction timeFormat(s) {\n    var second = s % 60 > 0 ? parseInt(s % 60) : s;\n    var minute = s / 60 > 0 ? parseInt(s / 60) : 0;\n    second = second > 10 ? second : \"0\" + second;\n    minute = minute > 10 ? minute : \"0\" + minute;\n    return minute + \":\" + second;\n}\n</code></pre>\n<p>CSS代码：</p>\n<pre><code>.btn {\n    display: inline-block;\n    margin: 0 10px;\n    padding: 5px 10px;\n    font-size: 14px;\n    color: #fff;\n    border-radius: 5px;\n    background: #4dbb89;\n    cursor: pointer;\n}\n.time {\n    margin: 10px 20px;\n}\n.slidebar {\n    margin: 0 20px;\n    position: relative;\n    width: 150px;\n    height: 8px;\n    background: #969595;\n    border-radius: 5px;\n}\n.slidebar .slide-thumb {\n    position: absolute;\n    display: inline-block;\n    width: 18px;\n    height: 18px;\n    margin-left: -9px;\n    margin-top: -5px;\n    border-radius: 50%;\n    background: #41bba0;\n}\n</code></pre>\n<p>HTML代码：</p>\n<pre><code><div class=\"btn\" id=\"btn-play\">play</div><div class=\"btn\" id=\"btn-pause\">pause</div>\n<div class=\"time\">\n    <span class=\"text-curTime\">00:00</span> / <span class=\"text-totalTime\"></span>\n</div>\n<div class=\"slidebar\"><span class=\"slide-thumb\"></span></div>\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/1236\">http://www.dengzhr.com/frontend/html/1236</a></div>\n\n        ','2','1'),(223,'AngularJS依赖注入原理分析','\n\n            <p>正在施工 ing，先占个坑，慢慢填。。。。。…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>正在施工 ing，先占个坑，慢慢填。。。。。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1195\">http://www.dengzhr.com/js/1195</a></div>\n\n        ','2','1'),(224,'【实战】数字线性变化的动画实现（原生JS || jQuery）','\n\n            <p>在一些数据展示的专题页里，有时候希望数字能动态从某一个数变化到另一个数，以此来吸引用户眼球，突出数据。</p>\n<p>于是有了下文。</p>\n<p>在这里，我用了两种方式：一种是原生的JavaScript，另一种是jQuery插件。</p>\n<p>数字线性变化的原理很简单，就是让数字增量变化，并循环动画。</p>\n<h2>原生JS版</h2>\n<p>首先获取DOM元素。为了兼容到IE6，兼容性方法如下：</p>\n<pre><code>var domUtil = {\n    // 获取DOM元素\n    get: function(query)</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在一些数据展示的专题页里，有时候希望数字能动态从某一个数变化到另一个数，以此来吸引用户眼球，突出数据。</p>\n<p>于是有了下文。</p>\n<p>在这里，我用了两种方式：一种是原生的JavaScript，另一种是jQuery插件。</p>\n<p>数字线性变化的原理很简单，就是让数字增量变化，并循环动画。</p>\n<h2><a id=\"_4\"></a>原生JS版</h2>\n<p>首先获取DOM元素。为了兼容到IE6，兼容性方法如下：</p>\n<pre><code>var domUtil = {\n    // 获取DOM元素\n    get: function(query) {\n        var _this = this;\n        if(document.querySelector) {\n            return document.querySelector(query);\n        } else {\n            var elements = document;\n            var queryStrArray = query.split(/ +/);\n            for(var i = 0; i < queryStrArray.length; i++) {\n                var domName = queryStrArray[i];\n                elements = _this.getElementsOfParentNode(domName, elements);\n            }\n            if(elements.length == 1) {\n                return elements[0];\n            } else {\n                return elements;\n            }\n        }\n    },\n    // 获取DOM元素\n    getElementsOfParentNode: function(domName, parentNode) {\n        var _this = this;\n        parentNode = parentNode || document;\n        domName = domName.trim();\n        var regExps = {\n            id: /^#/,\n            class: /^/\n        };\n        if(regExps.id.test(domName)) {\n            domName = domName.replace(/^\\#/g, \"\");\n            return parentNode.getElementById(domName);\n        } else if(regExps.class.test(domName)) {\n            domName = domName.replace(/^./g, \"\");\n            return _this.getElementsByClassName(domName, parentNode);\n        } else {\n            return parentNode.getElementsByTagName(domName);\n        }\n    },\n    // 获取class元素的兼容方法\n    getElementsByClassName: function(className, parentNode) {\n        if(parentNode.getElementsByClassName){\n            return parentNode.getElementsByClassName(className);\n        } else {\n            className = className.replace(/^ +| +$/g,\"\");\n            var classArray = className.split(/ +/);\n            var eles = parentNode.getElementsByTagName(\"*\");\n            for(var i = 0;i < classArray.length; i++){\n                var classEles = [];\n                var reg = new RegExp(\"(^| )\" + classArray[i] + \"( |$)\");\n                for(var j = 0;j < eles.length; j++){\n                    var ele = eles[j];\n                    if(reg.test(ele.className)){\n                        classEles.push(ele);\n                    }\n                }\n                eles = classEles;\n            }\n            return eles;\n        }\n    }\n};\n</code></pre>\n<pre><code>/*\n * 数字动画（目前仅支持数字动画的线性变化）\n * options参数：\n *     element  {String}    DOM元素query字符串\n *     from   {Number}    起始数字\n *     to   {Number}    终点数字\n *     duration   {Number}   动画时间\n *     callback   {Function}   数字变化时的回调函数\n */\nvar animatingNumber = function(options) {\n    this.element = domUtil.get(options.element);\n    this.startNum = options.from;\n    this.endNum = options.to;\n    this.duration = options.duration || 2000;\n    this.callback = options.callback;\n\n    this.timer = null;\n};\n\nanimatingNumber.prototype = {\n    start: function() {\n        var _this = this;\n        _this.animate();\n    },\n    stop: function() {\n        if(this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    },\n    animate: function() {\n        var _this = this;\n        var curNum = _this.startNum;\n        var animateTime = 0;\n        var range = _this.endNum - _this.startNum;\n        var timerStep = Math.abs( Math.floor(_this.duration / range) );\n        timerStep = timerStep > 20 ? timerStep : 20;\n        var numStep = (range / _this.duration) * timerStep;\n\n        _this.stop();\n\n        (function animate() {\n            _this.timer = setTimeout(function() {\n                curNum = Math.ceil( curNum + numStep );\n                if( (_this.endNum > _this.startNum && curNum >= _this.endNum) || (_this.endNum < _this.startNum && curNum <= _this.endNum) ) {\n                    curNum = _this.endNum;\n                }\n                _this.element.innerText = curNum;\n                animateTime++;\n                if(typeof this.callback == \'function\') {\n                    this.callback(curNum);\n                }\n                animate();\n                if(curNum >= _this.endNum) {\n                    _this.stop();\n                }\n            }, timerStep);\n        })();\n    }\n};\n\nanimatingNumber.create = function(options) {\n    return new animatingNumber(options);\n};\n</code></pre>\n<p>使用：</p>\n<pre><code><p>Number: <span class=\'dynamicNum\'>500</span></p>\n\n<script>\n    animatingNumber.create({\n        element: \'.dynamicNum\',\n        from: 1,\n        to: 500,\n        duration: 2000\n    }).start();\n</script>\n</code></pre>\n<p>效果如下：</p>\n<p><iframe style=\"width: 100%;\" title=\"rjEBpJ\" src=\"//codepen.io/dengzhirong8344/embed/rjEBpJ/?height=300&theme-id=15300&default-tab=result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong8344/pen/rjEBpJ/\">rjEBpJ</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong8344\">@dengzhirong8344</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n<h2><a id=\"_5\"></a>jQuery插件版</h2>\n<p>原理同上，只是DOM元素获取使用jQuery方法，并把数字动画方法封装成jQuery插件。如下：</p>\n<pre><code>/*\n * 数字动画（目前仅支持数字动画的线性变化）\n * options参数：\n *     from   {Number}    起始数字\n *     to   {Number}    终点数字\n *     duration   {Number}   动画时间\n *     callback   {Function}   数字变化时的回调函数\n */\n(function( $ ) {\n    $.fn.animatingNumber = function(options) {\n        var settings = {\n            element: this,\n            startNum: options.from,\n            endNum: options.to,\n            duration: options.duration || 2000,\n            callback: options.callback\n        };\n        var timer = null;\n\n        var methods = {\n            start: function() {\n                var _this = this;\n                _this.animate();\n            },\n            stop: function() {\n                if(timer) {\n                    clearTimeout(timer);\n                    timer = null;\n                }\n            },\n            animate: function() {\n                var _this = this;\n                var curNum = settings.startNum;\n                var animateTime = 0;\n                var range = settings.endNum - settings.startNum;\n                var timerStep = Math.abs( Math.floor(settings.duration / range) );\n                timerStep = timerStep > 20 ? timerStep : 20;\n                var numStep = (range / settings.duration) * timerStep;\n\n                _this.stop();\n\n                (function animate() {\n                    timer = setTimeout(function() {\n                        curNum = Math.ceil( curNum + numStep );\n                        if( (settings.endNum > settings.startNum && curNum >= settings.endNum) || (settings.endNum < settings.startNum && curNum <= settings.endNum) ) {\n                            curNum = settings.endNum;\n                        }\n                        settings.element.text(curNum);\n                        animateTime++;\n                        if(typeof settings.callback == \'function\') {\n                            settings.callback(curNum);\n                        }\n                        animate();\n                        if(curNum >= settings.endNum) {\n                            _this.stop();\n                        }\n                    }, timerStep);\n                })();\n            }\n        };\n        return this.each(function() {\n            return methods.start();\n        });\n\n    };\n})( jQuery );\n</code></pre>\n<p>使用：</p>\n<pre><code><p>Number: <span class=\'dynamicNum\'></span></p>\n\n<script>\n$(\'.dynamicNum\').animatingNumber({\n    from: 1,\n    to: 1000,\n    duration: 2000\n});\n</script>\n</code></pre>\n<p>效果如下：</p>\n<p><iframe style=\"width: 100%;\" title=\"PWrYQq\" src=\"//codepen.io/dengzhirong8344/embed/PWrYQq/?height=300&theme-id=15300&default-tab=js,result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong8344/pen/PWrYQq/\">PWrYQq</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong8344\">@dengzhirong8344</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n<h2><a id=\"_6\"></a>最后</h2>\n<p>后期会考虑加上缓动函数的选择项。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1328\">http://www.dengzhr.com/js/1328</a></div>\n\n        ','2','1'),(225,'Mocha+Chai单元测试并没有想象中难','\n\n            <p>作为过来人，首先想说的是：<strong>不要怕！</strong></p>\n<p>刚从前端转来做Node的，从来没接触过单元测试，一听这个名词就觉得高大上。加上周围一些前端儿也基本没有接触过单元测试，总把单元测试看得比较遥远，中文教程也点到即止并有点过分重视命令行参数的讲解，让我迟迟不敢轻易入坑。</p>\n<p>然而，当项目确实希望用到单元测试的时候，我决定抛开内心的恐惧，硬着头皮认认真真地读英文版的Mocha和chai Assert文档，发现，真的不过如…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>作为过来人，首先想说的是：<strong>不要怕！</strong></p>\n<p>刚从前端转来做Node的，从来没接触过单元测试，一听这个名词就觉得高大上。加上周围一些前端儿也基本没有接触过单元测试，总把单元测试看得比较遥远，中文教程也点到即止并有点过分重视命令行参数的讲解，让我迟迟不敢轻易入坑。</p>\n<p>然而，当项目确实希望用到单元测试的时候，我决定抛开内心的恐惧，硬着头皮认认真真地读英文版的Mocha和chai Assert文档，发现，真的不过如此而已！远远没有想象中的难，Hour级入门。</p>\n<p>现在，我有一种感觉：不跑单元测试会让我感到恐慌。。。</p>\n<p>这一次又给了我深刻的教训：接触一个新技术的时候，不要慌，不要害怕，不过分依赖过来人的看法，不亲自实践又怎知难易呢？</p>\n<p>罗里吧嗦了一大堆，现在开始步入正题。。。</p>\n<h2><a id=\"_4\"></a>一. 单元测试</h2>\n<p>单元测试分为两种：</p>\n<ul>\n<li>TDD：Test-Driven Development，测试驱动开发，注重输出结果。</li>\n<li>BDD：Behavior Driven Development，行为驱动开发，注重测试逻辑。</li>\n</ul>\n<p>对于TDD、BDD的区别可查看：<a href=\"http://www.cnblogs.com/ustbwuyi/archive/2012/10/26/2741223.html\">关于TDD、BDD和DDD的一些看法</a>。</p>\n<p>对于单元测试，推荐查看<a href=\"https://www.h5jun.com/post/5-questions-every-unit-test-must-answer.html\">【译】每个单元测试必须回答的 5 个问题</a>。</p>\n<p>mocha默认的模式是BDD。</p>\n<h2><a id=\"_5\"></a>二. Mocha介绍</h2>\n<p>在Node.js中，目前比较流行的单元测试组合是<code>mocha + chai</code>。mocha是一个测试框架，chai是一个断言库，所以合称”抹茶”。</p>\n<p>断言库类型有：<code>jasmine</code>、<code>should.js</code>、<code>chai</code>、<code>assert</code>。哪个更好主要看团队和项目需要吧，个人喜欢chai断言库的assert风格，更接近原生也更人性化。</p>\n<p>Mocha主要特性有：</p>\n<ul>\n<li>支持异步的测似用例，如Promise；</li>\n<li>支持代码覆盖率coverage测试报告；</li>\n<li>支持配置不同的测试（如断言库）；</li>\n<li>… …</li>\n</ul>\n<p>本文使用的是：<code>Mocha + chai(assert风格)</code>。</p>\n<p><strong>安装如下</strong>：</p>\n<pre><code>npm install mocha -g\nnpm install mocha\nnpm install chai\n</code></pre>\n<p><strong>跑Mocha测试的命令</strong>：</p>\n<pre><code>mocha [debug] [options] [files]\n\n如：\nmocha --recursive test/\n</code></pre>\n<h2><a id=\"_6\"></a>二. Mocha的三个基本方法：</h2>\n<p>Mocha有三个基本方法：</p>\n<h3><a id=\"_7\"></a>describe(moduleName, function)</h3>\n<p>describe是可嵌套的，描述测试用例是否正确。</p>\n<pre><code>describe(\'测试模块的描述\', function() {\n  // ....\n});\n</code></pre>\n<h3><a id=\"_8\"></a>it(info, function)</h3>\n<p>info为描述性说明。一个it对应一个单元测试用例。</p>\n<pre><code>describe(\'单元测试的描述，一般写明用途和返回值\', function() {\n  // ....\n});\n</code></pre>\n<h3><a id=\"_9\"></a>assert.equal(exp1, exp2)</h3>\n<p>mocha的断言语句，判断exp1是否等于exp2。</p>\n<h2><a id=\"_10\"></a>三. Mocha的异步代码测试：</h2>\n<h3><a id=\"_11\"></a>done</h3>\n<p>一个it里面只有一个done。</p>\n<p>done标识回调的最深处，也是嵌套回调函数的末端。</p>\n<p>备注：在mocha v3.x版本，Promise回调不需要使用 <code>done</code> 来标识回调最深处，并且在Promise回调中是用done回报错。</p>\n<pre><code>describe(\'User\', function() {\n  describe(\'#save()\', function() {\n    it(\'should save without error\', function(done) {\n      var user = new User(\'Luna\');\n      user.save(done);\n    });\n  });\n});\n</code></pre>\n<h3><a id=\"_12\"></a>四. Test Hooks方法：</h3>\n<p><code>before()</code>、<code>after()</code>、<code>beforeEach()</code>、<code>afterEach()</code> 是基于BDD风格提出的。用于预处理和test后的处理。</p>\n<p>Test Hooks方法的几个注意点：</p>\n<ul>\n<li>beforeEach会对当前describe下的所有子case生效；</li>\n<li>before和after的代码没有特殊顺序要求；</li>\n<li>同一个describe下的执行顺序为before、beforeEach、afterEach、after；</li>\n<li>当一个it有多个before的时候，执行顺序是从最外围的describe的before开始，其他同理。</li>\n</ul>\n<pre><code>describe(\'hooks\', function() {\n\n  before(function() {\n    // runs before all tests in this block\n  });\n\n  after(function() {\n    // runs after all tests in this block\n  });\n\n  beforeEach(function() {\n    // runs before each test in this block\n  });\n\n  afterEach(function() {\n    // runs after each test in this block\n  });\n\n  // test cases\n});\n</code></pre>\n<p>Hooks的三种写法：</p>\n<pre><code>beforeEach(function() {\n});\n\nbeforeEach(function nameFun() {\n});\n\nbeforeEach(\"some description\", function() {\n});\n</code></pre>\n<h2><a id=\"_13\"></a>五. only()、skip()函数</h2>\n<p>describe块和it块都允许调用<code>only()</code>和<code>skip()</code>方法。</p>\n<p><code>only()</code>方法表示在当前的父describe块下，只执行该单元的测试。</p>\n<p><code>skip()</code>方法表示在当前的父describe块下，跳过不执行该单元的测试。</p>\n<p>当在一个describe块下，同时存在<code>only()</code>和<code>skip()</code>方法，则只执行<code>.only()</code>方法。</p>\n<pre><code>describe(\'Array\', function() {\n  describe.only(\'父describe块下只执行该测试单元\', () => {\n    it.skip(\'跳过的测试单元\', () => { //... });\n  });\n  describe(\'不执行\', () => { //... });\n});\n</code></pre>\n<h2><a id=\"_14\"></a>六. mocha 常用命令参数</h2>\n<h3><a id=\"_15\"></a>–recursive 遍历子目录下的全部文件</h3>\n<p>Mocha默认运行/test子目录里面的测试脚本。</p>\n<p>Mocha默认只执行/test子目录下第一层的测试用例。</p>\n<p>所以，应加上–recursive参数，使全部子目录下的测试用例都能被执行。</p>\n<pre><code>mocha --recursive\n</code></pre>\n<h3><a id=\"_16\"></a>-u tdd 执行TDD模式</h3>\n<p>mocha默认的模式是BDD，要想执行TDD的test时需要加上参数，如：</p>\n<pre><code>mocha -u tdd test.js\n</code></pre>\n<h3><a id=\"_17\"></a>–watch, -w 监听脚本变化</h3>\n<p><code>--watch</code>参数用来监视指定的测试脚本。当脚本发生变化，就会自动运行mocha。</p>\n<pre><code>mocha --watch\n</code></pre>\n<h3><a id=\"_18\"></a>–bail, -b</h3>\n<p>只要有一个测试用例没有通过，就会停止执行后面的测试用例。</p>\n<h3><a id=\"_19\"></a>-timeout, -t 指定超时门槛</h3>\n<p>Mocha默认每个测试用例最多执行2000毫秒。如果2000毫秒后还没有执行完成，则报错。-t可执行超时门槛。</p>\n<pre><code>mocha -t 5000 test.js\n</code></pre>\n<h3><a id=\"_20\"></a>使用nobe通配符适配文件</h3>\n<pre><code>mocha spec/{my,awesome}.js\nmocha test/unit/*.js\nmocha \'test/**/*.@(js|jsx)\'\n</code></pre>\n<h2><a id=\"_21\"></a>七. chai库</h2>\n<p>我个人比较喜欢assert风格。具体可查看文档：<a href=\"http://chaijs.com/api/assert/\">http://chaijs.com/api/assert/</a></p>\n<p>其实最常用的API也就那几个：</p>\n<ul>\n<li>.equal(actual, expected, [message])</li>\n<li>.deepeEqual(actual, expected, [message])</li>\n<li>.isOk(object, [message])</li>\n<li>.isTrue(value, [message])</li>\n<li>.include(haystack, needle, [message])</li>\n<li>… …</li>\n</ul>\n<h2><a id=\"_22\"></a>八. 参考</h2>\n<ol>\n<li>Node.js 单元测试：我要写测试：<a href=\"http://taobaofed.org/blog/2015/12/10/nodejs-unit-tests/\">http://taobaofed.org/blog/2015/12/10/nodejs-unit-tests/</a></li>\n<li>【译】每个单元测试必须回答的 5 个问题：<a href=\"https://www.h5jun.com/post/5-questions-every-unit-test-must-answer.html\">https://www.h5jun.com/post/5-questions-every-unit-test-must-answer.html</a></li>\n<li>测试框架 Mocha 实例教程：<a href=\"http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html\">http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html</a></li>\n</ol>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/1282\">http://www.dengzhr.com/node-js/1282</a></div>\n\n        ','2','1'),(226,'Node.js：设置CORS跨域请求中的多域名白名单','\n\n            <p>说到CORS，相信前端儿都不陌生，这里我就不多说了，具体可以详看阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">跨域资源共享 CORS 详解</a>。</p>\n<p>CORS，主要就是配置Response响应头中的 <strong>Access-Control-Allow-Origin</strong> 属性为你允许该接口访问的域名。最常见的设置是：</p>\n<pre><code>res.header(\'Access-Control-Allow-Origin\', \'*\');\nres.header(\'Access-Control-Allow-Credentials\',</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>说到CORS，相信前端儿都不陌生，这里我就不多说了，具体可以详看阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">跨域资源共享 CORS 详解</a>。</p>\n<p>CORS，主要就是配置Response响应头中的 <strong>Access-Control-Allow-Origin</strong> 属性为你允许该接口访问的域名。最常见的设置是：</p>\n<pre><code>res.header(\'Access-Control-Allow-Origin\', \'*\');\nres.header(\'Access-Control-Allow-Credentials\', \'true\');  // 允许服务器端发送Cookie数据\n</code></pre>\n<p>然而，这样的设置是最简单粗暴，同时也是最不安全的。它表示该接口允许所有的域名对它进行跨域请求。然而，在一般实际业务中，都希望该接口只允许对某一个或几个网站开放跨域请求权限，而非全部。</p>\n<p>那么，聪明的你肯定想着，多域名白名单还不简单吗，写个正则就好啦？再不行，直接配置 Access-Control-Allow-Origin 属性为用逗号分隔的多个域名不就好了吗？就像下面这样：</p>\n<pre><code>res.header(\'Access-Control-Allow-Origin\', \'*.666.com\'); \n\n// 或者如下\nres.header(\'Access-Control-Allow-Origin\', \'a.666.com,b.666.com,c.666.com\');\n</code></pre>\n<p>很遗憾地告诉你，这样的写法是无效的。在Node.js中，res的响应头Header中的 Access-Control-Allow-Origin 属性不能匹配除 (*) 以外的正则表达式的，域名之间不能也用逗号分隔。也就是说， <strong>Access-Control-Allow-Origin 的属性值只允许设置为单个确定域名字符串或者 </strong> (*)。</p>\n<p>既然我们希望允许的是多个域名，也不愿意使用不安全的 * 通配符，难道就真不能配置多域名白名单的CORS了吗？</p>\n<p>多域名白名单的CORS确实是可以实现的。只是有一点曲线救国的味道。</p>\n<h2><a id=\"_4\"></a>多域名白名单的CORS实现原理</h2>\n<p>具体原理可以参考cors库的核心代码：</p>\n<p><a href=\"https://github.com/expressjs/cors/blob/master/lib/index.js\">https://github.com/expressjs/cors/blob/master/lib/index.js</a></p>\n<p>实现原理是这样的：</p>\n<p>既然 Access-Control-Allow-Origin 属性已经明确不能设置多个域名，那么我们只得放弃这条路了。</p>\n<p>最流行也是最有效的方法就是，<strong>在服务器端判断请求的Header中Origin属性值（req.header.origin）是否在我们的域名白名单列表内</strong>。如果在白名单列表内，那么我们就把 Access-Control-Allow-Origin 设置成当前的Origin值，这样就满足了Access-Control-Allow-Origin 的单一域名要求，也能确保当前请求通过访问；如果不在白名单列表内，则返回错误信息。</p>\n<p>这样，<strong>我们就把跨域请求的验证，从浏览器端转移到服务端来了</strong>。对Origin字符串的验证就变成了相当于常规字符串的验证，我们不仅可以使用数组列表验证，还可以使用正则匹配。</p>\n<h2><a id=\"_5\"></a>具体代码如下：</h2>\n<pre><code>// 判断origin是否在域名白名单列表中\nfunction isOriginAllowed(origin, allowedOrigin) {\n    if (_.isArray(allowedOrigin)) {\n        for(let i = 0; i < allowedOrigin.length; i++) {\n            if(isOriginAllowed(origin, allowedOrigin[i])) {\n                return true;\n            }\n        }\n        return false;\n    } else if (_.isString(allowedOrigin)) {\n        return origin === allowedOrigin;\n    } else if (allowedOrigin instanceof RegExp) {\n        return allowedOrigin.test(origin);\n    } else {\n        return !!allowedOrigin;\n    }\n}\n\n\nconst ALLOW_ORIGIN = [  // 域名白名单\n    \'*.233.666.com\',\n    \'hello.world.com\',\n    \'hello..*.com\'\n];\n\napp.post(\'a/b\', function (req, res, next) {\n    let reqOrigin = req.headers.origin;  // request响应头的origin属性\n\n    // 判断请求是否在域名白名单内\n    if(isOriginAllowed(reqOrigin, ALLOW_ORIGIN)) {\n        // 设置CORS为请求的Origin值\n        res.header(\"Access-Control-Allow-Origin\", reqOrigin);\n        res.header(\'Access-Control-Allow-Credentials\', \'true\');\n\n        // 你的业务代码逻辑代码 ...\n        // ...\n    } else {\n        res.send({ code: -2, msg: \'非法请求\' });\n    }\n});\n</code></pre>\n<p>Oh yeah，简直完美~</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/1360\">http://www.dengzhr.com/node-js/1360</a></div>\n\n        ','2','1'),(227,'Jade使用笔记','\n\n            <h2>安装</h2>\n<pre><code>npm install jade\n</code></pre>\n<h2>在Sublime Text开发的配置</h2>\n<h3>Jade语法高亮显示：</h3>\n<p>Jade代码高亮显示需要安装的插件有：<strong>Jade</strong>；</p>\n<h3>Jade编译为HTML：</h3>\n<p>首先需要全局安装Jade模块：</p>\n<pre><code>npm install jade --global\n</code></pre>\n<p>然后，通过 Package Control 安装 <strong>Jade Build</strong> 插件。</p>\n<p>使用时，在菜单 Tools > Build System 中，确认勾选了 <strong>Automatic</strong> 或 <strong>Jade</strong>。在 …</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>安装</h2>\n<pre><code>npm install jade\n</code></pre>\n<h2><a id=\"_5\"></a>在Sublime Text开发的配置</h2>\n<h3><a id=\"_6\"></a>Jade语法高亮显示：</h3>\n<p>Jade代码高亮显示需要安装的插件有：<strong>Jade</strong>；</p>\n<h3><a id=\"_7\"></a>Jade编译为HTML：</h3>\n<p>首先需要全局安装Jade模块：</p>\n<pre><code>npm install jade --global\n</code></pre>\n<p>然后，通过 Package Control 安装 <strong>Jade Build</strong> 插件。</p>\n<p>使用时，在菜单 Tools > Build System 中，确认勾选了 <strong>Automatic</strong> 或 <strong>Jade</strong>。在 .jade 文件中按 <strong>Ctrl+B</strong> (Mac: Cmd+B) 执行编译即可。如果编译成功，则会在同级目录下生成 .html 文件。</p>\n<p>推荐通过 Package Control 安装 <code>Sublime​On​Save​Build</code>，参考 <a href=\"https://sublime.wbond.net/packages/SublimeOnSaveBuild\">https://sublime.wbond.net/packages/SublimeOnSaveBuild</a> 进行配置，将 jade 添加到 <strong>filename_filter</strong> 中，这样每次保存文件即可以自动执行编译。</p>\n<h2><a id=\"_8\"></a>Jade语法</h2>\n<h3><a id=\"_9\"></a>标签</h3>\n<p>Jade：</p>\n<pre><code>html\n</code></pre>\n<p>渲染后变成：<code><html></html></code>。</p>\n<p>Jade：</p>\n<pre><code>div#foo.bar.baz\n</code></pre>\n<p>渲染后变成：<code><div id=\"foo\"></div><div class=\"bar\"></div></code>。</p>\n<h2><a id=\"_10\"></a>文本</h2>\n<p>对于小段文本，可以把简单内容直接放在标签之后：</p>\n<pre><code>p wahoo!\n</code></pre>\n<p>渲染后：<code><p>wahoo!</p></code>。</p>\n<p>对于大段文本，可以在每一行文本的前面加上” | “：</p>\n<pre><code>p\n  | foo bar baz\n  | rawr rawr\n  | super cool\n  | go jade go\n</code></pre>\n<p>渲染后为：<code><p>foo bar baz rawr rawr super cool go jade go</p></code>。</p>\n<p>对于大段文本，还可以选择以” . “：</p>\n<pre><code>p.\n    foo asdf\n    asdf\n      asdfasdfaf\n      asdf\n    asd\n</code></pre>\n<p>渲染后：</p>\n<pre><code><p>\n  foo asdf\n  asdf\n    asdfasdfaf\n    asdf\n  asd\n</p>\n</code></pre>\n<p>这和带一个空格的 ‘.’ 不一样。带空格的 ” . ” 会被Jade的解析器忽略，当作一个普通的文字:</p>\n<pre><code>p .\n</code></pre>\n<p>渲染为：<code><p>.</p></code>。</p>\n<h2><a id=\"_11\"></a>注释</h2>\n<p>单行注释有以下三种：</p>\n<pre><code>// 单行注释\n<!-- 单行注释 -->\n//- 不输出的单行注释\n</code></pre>\n<h2><a id=\"_12\"></a>属性</h2>\n<p>Jade支持使用 “(” 和 “)” 作为属性分隔符。</p>\n<pre><code>a(href=\'/login\', title=\'View login page\') Login\n</code></pre>\n<p>渲染为：<code><a href=\"/login\" title=\"View login page\">Login</a></code>。</p>\n<p>当一个值是 undefined 或者 null 属性不会被加上。如：</p>\n<pre><code>div(something=null)\n</code></pre>\n<p>渲染为：<code><div></div></code>。</p>\n<h2><a id=\"_13\"></a>可执行代码</h2>\n<p>Jade目前支持三种类型的可执行代码。第一种是前缀 <strong>–</strong>， 这是不会被输出的：</p>\n<pre><code>- var foo = \'bar\';\n</code></pre>\n<pre><code>-var items = [1, 2, 3, 4]\n- if (items.length)\n  ul\n    - items.forEach(function(item){\n      li= item\n    - })\n</code></pre>\n<p>渲染为：</p>\n<pre><code><ul>\n  <li>1</li>\n  <li>2</li>\n  <li>3</li>\n  <li>4</li>\n</ul>\n</code></pre>\n<p>使用<strong>=</strong>输出转义的代码：</p>\n<pre><code>- var foo = \'bar\'\n= foo\nh1= foo\n</code></pre>\n<p>输出：<code>bar<h1>bar</h1></code>。</p>\n<h2><a id=\"_14\"></a>循环</h2>\n<p>遍历数组：</p>\n<pre><code>-var items = [\"one\", \"two\", \"three\"]\neach item, i in items\n  li #{item}: #{i}\n</code></pre>\n<p>渲染为：</p>\n<pre><code><li>one: 0</li>\n<li>two: 1</li>\n<li>three: 2</li>\n</code></pre>\n<p>遍历对象：</p>\n<pre><code>-var obj = { foo: \'bar\', name: \"hello\" }\neach val, key in obj\n  li #{key}: #{val}\n</code></pre>\n<p>渲染为：</p>\n<pre><code><li>foo: bar</li>\n<li>name: hello</li>\n</code></pre>\n<p>也可以使用for循环：</p>\n<pre><code>-var users = { bob: {roles: \"1\", custom: \"2\"}, jeny: {roles: \"2\"} }\nfor user in users\n  for role in user.roles\n    li= role\n</code></pre>\n<p>渲染为：<code><li>1</li><li>2</li></code>。</p>\n<h2><a id=\"_15\"></a>条件判断</h2>\n<h3><a id=\"_16\"></a>if判断：</h3>\n<pre><code>-var users = { bob: {role: \"admin\", name: \"bob\"}, jeny: {role: \"custom\", name: \"jeny\"} }\nfor user in users\n  - if (user.role == \'admin\')\n    p #{user.name} is an admin\n  - else\n    p= user.name\n</code></pre>\n<p>渲染为：</p>\n<pre><code><p>bob is an admin</p>\n<p>jeny</p>\n</code></pre>\n<h3><a id=\"_17\"></a>case判断：</h3>\n<pre><code>- var friends = 10\ncase friends\n  when 0\n    p you have no friends\n  when 1\n    p you have a friend\n  default\n    p you have #{friends} friends\n</code></pre>\n<p>或：</p>\n<pre><code>- var friends = 1\ncase friends\n  when 0: p you have no friends\n  when 1: p you have a friend\n  default: p you have #{friends} friends\n</code></pre>\n<p>均渲染为：</p>\n<pre><code><p>you have 10 friends</p>\n</code></pre>\n<h2><a id=\"_18\"></a>模板继承</h2>\n<p>Jade支持通过<strong>block</strong>和<strong>extends</strong>关键字来实现模板继承。</p>\n<p>在父模板中，使用<strong>block</strong>定义占位符，如下：</p>\n<p>layout.jade:</p>\n<pre><code>html\n  head\n    h1 My Site - #{title}\n    block scripts\n      script(src=\'/jquery.js\')\n  body\n    block content\n    block foot\n      #footer\n        p some footer content\n</code></pre>\n<p>在子模板中，直接使用extends定义它的父模板。父模板可以选择带.jade扩展名或者不带。</p>\n<p>child.jade：</p>\n<pre><code>extends layout\n\nblock scripts\n  script(src=\'/jquery.js\')\n  script(src=\'/pets.js\')\n\nblock content\n  h1= title\n  each pet in pets\n    include pet\n</code></pre>\n<p>其中，child.jade渲染为：</p>\n<pre><code> <html>\n  <head>\n    <h1>My Site - </h1>\n    <script src=\"/jquery.js\"></script>\n    <script src=\"/pets.js\"></script>\n  </head>\n  <body>\n    <h2>pet</h2>\n    <h2>pet</h2>\n    <h2>pet</h2>\n    <h2>pet</h2>\n    <div id=\"footer\"></div>\n    <p>some footer content</p>\n  </body>\n</html>\n</code></pre>\n<h2><a id=\"_19\"></a>包含</h2>\n<p>Includes 允许你静态包含一段Jade，或者别的存放在单个文件中的东西比如css, html。</p>\n<p>如：</p>\n<pre><code> html\n    include head.jade\n    body\n        h1 My Site\n        p Welcome to my super amazing site.\n        include foot.jade\n</code></pre>\n<h2><a id=\"_20\"></a>Mixins</h2>\n<pre><code>mixin list\n    ul\n        li foo\n        li bar\n        li baz\n\nh2 Groceries\n+list\n+list\n</code></pre>\n<p>渲染为：</p>\n<pre><code><h2>Groceries</h2>\n<ul>\n  <li>foo</li>\n  <li>bar</li>\n  <li>baz</li>\n</ul>\n<ul>\n  <li>foo</li>\n  <li>bar</li>\n  <li>baz</li>\n</ul>\n</code></pre>\n<p>带参数的mixin：</p>\n<pre><code>mixin pets(pets)\n    ul.pets\n    each pet in pets\n        li= pet\n\nmixin profile(user)\n    .user\n        h2= user.name\n        mixin pets(user.pets)\n\n-var user = {name: \"bob\", pets: [\"cat\", \"dog\", \"pig\"]}\n+profile(user)\n</code></pre>\n<p>渲染为：</p>\n<pre><code><div class=\"user\">\n  <h2>bob</h2>\n  <ul class=\"pets\"></ul>\n  <li>cat</li>\n  <li>dog</li>\n  <li>pig</li>\n</div>\n</code></pre>\n<h2><a id=\"_21\"></a>变量调用</h2>\n<p>jade 的变量调用有 3 种方式：</p>\n<ul>\n<li>\n<h1><a id=\"_22\"></a>{表达式}</h1>\n</li>\n<li>=表达式 // 会对字符进行转义</li>\n<li>!=表达式 // 不会对字符进行转义</li>\n</ul>\n<pre><code>- var s = \'hello world\' // 在服务端空间中定义变量\np #{s}\np= s\n</code></pre>\n<p>渲染为：</p>\n<pre><code><p>hello world</p>\n<p>hello world</p>\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/854\">http://www.dengzhr.com/node-js/854</a></div>\n\n        ','2','1'),(228,'原生Node.js实现WebSocket的原理','\n\n            <pre><code>let crypto = require(\'crypto\');\nlet http = require(\'http\');\n\nlet app = http.createServer();\nlet sockets = [];  // 存放每一个客户端socket的数组\n\napp.on(\'upgrade\', (req, socket, head) => {\n    socket.setEncoding(\'utf8\');  // 统一socket的编码格式为utf8\n\n    //</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <pre><code>let crypto = require(\'crypto\');\nlet http = require(\'http\');\n\nlet app = http.createServer();\nlet sockets = [];  // 存放每一个客户端socket的数组\n\napp.on(\'upgrade\', (req, socket, head) => {\n    socket.setEncoding(\'utf8\');  // 统一socket的编码格式为utf8\n\n    // 设置socket的header，升级协议\n    const GUID = \'258EAFA5-E914-47DA-95CA-C5AB0DC85B11\';\n    const key = crypto.createHash(\'sha1\')\n        .update(req.headers[\'sec-websocket-key\'] + GUID, \'binary\')\n        .digest(\'base64\');\n    const headers = [\n        \'HTTP/1.1 101 Switching Protocols\',\n        \'Upgrade: websocket\',\n        \'Connection: Upgrade\',\n        `Sec-WebSocket-Accept: ${key}`\n    ];\n    socket.write(headers.concat(\'\', \'\').join(\'\\r\\n\'));\n\n    // 记录客户端socket相关信息\n    sockets.push(socket);\n\n    socket.on(\'data\', function(data) {\n        //进行广播，使每个客户端收到消息\n        sockets.forEach(otherSocket => {\n            // socket的通信handler和业务handler ...\n            if (otherSocket !== socket) {\n                // ...\n            }\n        });\n    });\n    socket.on(\'end\', () => {\n        // 结束socket时的handler\n    });\n    socket.on(\'close\', () => {\n        //当前客户端socket下线退出，清除相关信息\n        let index = sockets.indexOf(socket);\n        sockets.splice(index, 1);\n    });\n});\napp.on(\'clientError\', (err, socket) => {\n    // 客户端错误时，结束socket连接\n    socket.end(\'HTTP/1.1 400 Bad Request\');\n});\n\napp.listen(4006);\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/1416\">http://www.dengzhr.com/node-js/1416</a></div>\n\n        ','2','1'),(229,'原生Node.js实现静态资源服务器','\n\n            <p><strong>事起缘由</strong>：上个月面试的时候，面试官问我如何写静态文件服务器。额，这个，这个不是用Express里面的static方法一行命令就能搞掂的咩，要压缩的话一个Compress中间件就搞掂了呀？。。如果非要自己写的话，不就是createServer，监听一下路由，再读取文件输出文本流到客户端不就OK了吗？。。。。咦。。。稍…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p><strong>事起缘由</strong>：上个月面试的时候，面试官问我如何写静态文件服务器。额，这个，这个不是用Express里面的static方法一行命令就能搞掂的咩，要压缩的话一个Compress中间件就搞掂了呀？。。如果非要自己写的话，不就是createServer，监听一下路由，再读取文件输出文本流到客户端不就OK了吗？。。。。咦。。。稍等！稍等！！好像哪里不对，。。。读文件也要分文件类型来输出呀，image和视频文件就不能用文本格式输出，要考虑MIME呀；直接读文件的话，肯定还会涉及到安全性问题；读取I/O操作成本辣么高，不考虑缓存和Gzip压缩会死人的呀；如果是大文件的话，可能还要考虑断点续传耶；卧槽，如果要用于商业项目的话日志也是要考虑的呀，容错什么的都不能少耶。。。。。。。。我的天呀，静态文件服务器并没有我一开始想的那么简单，一头脑风暴下来就发现这东西注意的地方很多，看来确实值得研究和实操一遍呀。</p>\n<p>好的，事不宜迟，开始写。</p>\n<p>一个静态文件服务器需要具备什么素质呢？</p>\n<p>首先，用户从客户端输入文件地址，服务器端根据这个地址进行解析，所以<strong>第一步应该是解析路由</strong>；拿到路由之后就可以确定文件在磁盘的具体位置，就可以读取文件流，所以<strong>第二步是读取文件流输出到客户端</strong>。</p>\n<p>如果不考虑性能优化、兼容性和监控管理的话，一个极其简单的静态资源服务器就算完成了。</p>\n<p>但是，如果要追求完美的话，我们还需要做更多的事情，譬如：</p>\n<blockquote>\n<ul>\n<li><strong>MIME判断</strong>，区分文本文件和富媒体文件；</li>\n<li><strong>增加缓存机制</strong>；</li>\n<li><strong>服务器端增加Gzip压缩</strong>；</li>\n<li><strong>大文件的断点续传</strong>；</li>\n<li><strong>日志监控</strong>；</li>\n<li><strong>安全性</strong>；</li>\n<li><strong>容错机制</strong>；</li>\n</ul>\n</blockquote>\n<p>好的，下面开始一步步实现。</p>\n<h2><a id=\"_4\"></a>一. 路由解析</h2>\n<pre><code>let http = require(\"http\"),\n    url = require(\"url\");\n\nlet staticPath = \"./res/\";\n\nlet app = http.createServer((request, response) => {\n    let pathName = url.parse(request.url).pathname;\n\n    response.write(\"pathName = \" + pathName);\n    response.end();\n});\n\napp.listen(80, \"127.0.0.1\");\n</code></pre>\n<p>此时，在客户端请求地址譬如<code>http:127.0.0.1/res/1.html</code>，客户端则会显示：<code>pathName = /res/1.html</code>。</p>\n<h2><a id=\"_5\"></a>二. 将文件输出到客户端</h2>\n<p>拿到了路由接下来我们就可以根据静态文件夹的地址拼装出文件的真实地址，然后读取文件流并输出。</p>\n<p>假设静态文件夹为<code>./res/</code>。设定用户输入<code>http:127.0.0.1/1.txt</code>时，服务器会将文件路径映射到<code>./res/</code>目录，即实际访问的是<code>./res/1.txt</code>文件。</p>\n<p>文件读取时，需要考虑文件是否存在和文件是否可读的情况，如果发生错误，应有响应信息和状态提示。</p>\n<p>代码如下：</p>\n<pre><code>let http = require(\"http\"),\n    url = require(\"url\"),\n    path = require(\"path\"),\n    fs = require(\"fs\");\n\nlet staticPath = \"./res/\";\n\nlet app = http.createServer((request, response) => {\n    let pathName = url.parse(request.url).pathname,\n        realPath = path.join(staticPath, pathName); // 请求文件的在磁盘中的真实地址\n\n    fs.exists(realPath, (exists) => {\n        if(!exists) {\n            // 当文件不存在时\n            response.writeHead(404, {\"Content-Type\": \"text/plain\"});\n\n            response.write(\"This request URL \' \" + realPath + \" \' was not found on this server.\");\n            response.end();\n        } else {\n            // 当文件存在时\n            fs.readFile(realPath, \"binary\", (err, file) => {\n                if (err) {\n                    // 文件读取出错\n                    response.writeHead(500, {\"Content-Type\": \"text/plain\"});\n\n                    response.end(err);\n                } else {\n                    // 当文件可被读取时，输出文本流\n                    response.writeHead(200, {\"Content-Type\": \"text/plain\"});\n                    response.write(file, \"binary\");\n                    response.end();\n                }\n            });\n        }\n    });\n});\n\napp.listen(80, \"127.0.0.1\");\n</code></pre>\n<p>如果文件是文本文件的话，只要编码格式没啥问题，是可以正确读取的。但是如果访问的是富媒体资源如图片，就会出现下面这种尴尬的情形：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/ecqdycgwchnxi6lxxny4cpas/image_1b1cbd77obihaa36c8cua10uh9.png\" alt=\"image_1b1cbd77obihaa36c8cua10uh9.png-83.1kB\"></p>\n<p>显然，png图片的MIME类型并不是<code>\"text/html\"</code>，而是”text/png”，如果非要以<code>\"text/html\"</code>格式读取的话很可能会出现乱码。</p>\n<p>所以，我们的静态资源服务器中应该要增加MIME类型的支持。</p>\n<h2><a id=\"_6\"></a>三. MIME判断</h2>\n<p>不同文件对应着不同的MIME类型，所以应该首先有一张MIME类型的映射表。我们将文件后缀名对应的MIME值制作映射表，作为MIME模块。新建MIME.js文件，代码如下：</p>\n<pre><code>let type = {\n    \"txt\": \"text/plain\",\n    \"xml\": \"text/xml\",\n    \"html\": \"text/html\",\n    \"css\": \"text/css\",\n    \"js\": \"text/javascript\",\n    \"json\": \"application/json\",\n    \"gif\": \"image/gif\",\n    \"png\": \"image/png\",\n    \"jpeg\": \"image/jpeg\",\n    \"jpg\": \"image/jpeg\",\n    \"svg\": \"image/svg+xml\",\n    \"ico\": \"image/x-icon\",\n    \"pdf\": \"application/pdf\",\n    \"swf\": \"application/x-shockwave-flash\",\n    \"tiff\": \"image/tiff\",\n    \"wav\": \"audio/x-wav\",\n    \"wma\": \"audio/x-ms-wma\",\n    \"wmv\": \"video/x-ms-wmv\"\n};\n\nexports.type = type;\n</code></pre>\n<p>对于文件的后缀名，可以通过<code>path.extname</code>方法来获取。由于<code>path.extname</code>返回值中包含<code>.</code>。所以应除掉”.”。</p>\n<pre><code>let extName = path.extname(realPath);\nextName = extName ? extName.slice(1) : \"\";\n</code></pre>\n<p>所以，文件真正的MIME类型就可以拿到了，如下：</p>\n<pre><code>// ...\nlet MIME = require(\"./MIME.js\").type;\n\n// ...\nlet contentType = MIME[extName] || \"text/plain\";\nresponse.writeHead(200, {\"Content-Type\": contentType});\n</code></pre>\n<p>对于未知类型的文件，默认返回”text/plain”类型。</p>\n<h2><a id=\"_7\"></a>四. 增加缓存机制</h2>\n<p>如果文件每次访问都要进行一次I/O读写操作的话，当响应量一旦大起来的时候，硬盘可能会吃不消。</p>\n<p>如果我们能充分利用好浏览器缓存的话，就能很好得挡掉很大一部分文件请求和读写操作。</p>\n<p>在服务器端进行文件缓存处理的话，主要有四个Header属性需要配置，分别如下：</p>\n<blockquote>\n<ul>\n<li><strong>Expires</strong> / <strong>Cache-Control: max-age=xxxx</strong>：设置文件的最大缓存时间。</li>\n<li><strong>Last-Modified</strong> / <strong>If-Modified-Since</strong>：把浏览器端文件缓存的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。如果没有修改，则返回304状态码。</li>\n<li><strong>ETag头</strong>：用来判断文件是否已经被修改，区分不同语言和Session等等。</li>\n</ul>\n</blockquote>\n<h3><a id=\"_8\"></a>4.1 Expires / Cache-Control</h3>\n<p>配置缓存文件的最大缓存时长可通过设置Header中的Expires或Cache-Control属性来实现。如果没有过期，则不会向服务器端发送请求，而是直接从缓存中读取文件。</p>\n<p>Cache-Control和Expires实现的功能一样。当Cache-Control和Expires同时定义时，Cache-Control会覆盖Expires属性。由于有些浏览器不支持Cache-Control而只支持Expires，因此还是有必要同时定义这两个属性的。</p>\n<pre><code>let Expires = {\n    fileMatch: /^(gif|png|jpg|js|css)$/ig,\n    maxAge: 60 * 60 * 24 * 365\n};\n\n// ...\n\nif (extName.match(Expires.fileMatch)) {\n    let expires = new Date();\n    expires.setTime(expires.getTime() + Expires.maxAge * 1000);\n    response.setHeader(\"Expires\", expires.toUTCString());\n    response.setHeader(\"Cache-Control\", \"max-age=\" + Expires.maxAge);\n}\n</code></pre>\n<h3><a id=\"_9\"></a>4.2 Last-Modified / If-Modified-Since</h3>\n<p>读取文件的最后修改时间可通过fs.stat()方法来实现。</p>\n<pre><code>fs.stat(realPath, function (err, stat) {\n    let lastModified = stat.mtime.toUTCString();\n    response.setHeader(\"Last-Modified\", lastModified);\n});\n</code></pre>\n<p>同时我们也要检测浏览器是否发送了If-Modified-Since请求头。如果发送而且跟文件的修改时间相同的话，则返回304状态。</p>\n<pre><code>if (request.headers[ifModifiedSince] && lastModified == request.headers[ifModifiedSince]) {\n    response.writeHead(304, \"Not Modified\");\n    response.end();\n}\n</code></pre>\n<h3><a id=\"_10\"></a>4.3 ETag</h3>\n<p>浏览器在接受到服务器发过来的 <code>Etag</code> 后，会保存下来，下次请求的时候会将它放在请求头中，其 key 值为 <code>If-None-Match</code>。</p>\n<p>服务器拿到 <code>If-None-Match</code> 之后，对比之前的 <code>Etag</code>，如果没变，则返回 <code>304 Not Modified.</code>。</p>\n<pre><code>let crypto = require(\"crypto\");\n\nlet hashStr = \"A hash string.\",\n    hash = crypto.createHash(\'sha1\').update(hashStr).digest(\'base64\');\n\n// ...\n\nif(request.headers[\'if-none-match\'] == hash){\n    response.writeHead(304, \"Not Modified\");\n    response.end();\n} else {\n    response.setHeader(\"Etag\", hash);\n    res.end(); \n}\n</code></pre>\n<p>Etag在缓存处理中用得比较广泛，使用它可以减少一些不必要请求。</p>\n<p>对于静态文件，可以将文件最后一次的修改时间（Last-Modified）作为Etag值，这样就可以避免直接比较文件内容数据的hash值的消耗要小得多。所以很多时候ETag都是配合Last-Modified 一起使用。</p>\n<h2><a id=\"_11\"></a>五. Gzip压缩</h2>\n<p>对文本文件进行gzip压缩，可以将文件压缩得很小，大大减少网络流量。</p>\n<p>为了满足zlib模块的调用模式，将读取文件改为流的形式。</p>\n<p>对于支持压缩的文件格式以及浏览器端接受gzip或deflate压缩，则调用相对应的压缩方式。对于不支持的，则以管道方式转发给response。代码如下：</p>\n<pre><code>let raw = fs.createReadStream(realPath);\nlet acceptEncoding = request.headers[\'accept-encoding\'] || \'\';\n\nif (acceptEncoding.match(/\\bdeflate\\b/)) {\n  response.writeHead(200, { \'Content-Encoding\': \'deflate\' });\n  raw.pipe(zlib.createDeflate()).pipe(response);\n} else if (acceptEncoding.match(/\\bgzip\\b/)) {\n  response.writeHead(200, { \'Content-Encoding\': \'gzip\' });\n  raw.pipe(zlib.createGzip()).pipe(response);\n} else {\n  response.writeHead(200, {});\n  raw.pipe(response);\n}\n</code></pre>\n<h2><a id=\"_12\"></a>六. 安全性考虑</h2>\n<p>由于我们获取的静态资源文件夹路径，是通过客户端输入的path值与静态资源文件夹的路径进行合并而得。假如客户端输入的 <code>../1.html</code>，那岂不是可以访问静态资源文件夹以外的文件了？尽管浏览器可以干掉<code>..</code>这两个点，但是如果采用curl方式访问的话，问题就会出现。</p>\n<p>目前比较流行的做法是替换掉所有的<code>..</code>，然后调用path.normailze()方法来处理掉不正常的<code>/</code>。对于不存在的文件访问，应该返回404。</p>\n<pre><code>realPath = path.join(staticPath, path.normalize(pathName.replace(/\\.\\./g, \"\")));\n</code></pre>\n<h2><a id=\"_13\"></a>七. 日志监控</h2>\n<p>// 正在完善中，敬请期待~ … …</p>\n<h2><a id=\"_14\"></a>八. 完整代码：</h2>\n<p>app.js：</p>\n<pre><code>let http = require(\"http\"),\n    url = require(\"url\"),\n    path = require(\"path\"),\n    fs = require(\"fs\"),\n    MIME = require(\"./MIME.js\").type,\n    zlib = require(\"zlib\");\n\nlet staticPath = \"./res/\";\n\nlet Expires = {\n    fileMatch: /^(gif|png|jpg|js|css)$/ig,\n    maxAge: 60 * 60 * 24 * 365 // 一年\n};\n\nlet app = http.createServer((request, response) => {\n    let pathName = url.parse(request.url).pathname || \"\",\n        realPath = path.join(staticPath, path.normalize(pathName.replace(/\\.\\./g, \"\")));; // 请求文件的在磁盘中的真实地址\n\n    fs.exists(realPath, (exists) => {\n        if(!exists) {\n            // 当文件不存在时\n            response.writeHead(404, {\"Content-Type\": \"text/plain\"});\n\n            response.write(\"This request URL \' \" + realPath + \" \' was not found on this server.\");\n            response.end();\n        } else {\n            // 当文件存在时\n            fs.readFile(realPath, \"binary\", (err, file) => {\n                if (err) {\n                    // 文件读取出错\n                    response.writeHead(500, {\"Content-Type\": \"text/plain\"});\n\n                    response.end(err);\n                } else {\n                    // 当文件可被读取时，输出文本流\n                    let extName = path.extname(realPath);\n                    extName = extName ? extName.slice(1) : \"\";\n                    let contentType = MIME[extName] || \"text/plain\";\n\n                    if (extName.match(Expires.fileMatch)) {\n                        let expires = new Date();\n                        expires.setTime(expires.getTime() + Expires.maxAge * 1000);\n                        response.setHeader(\"Expires\", expires.toUTCString());\n                        response.setHeader(\"Cache-Control\", \"max-age=\" + Expires.maxAge);\n                    }\n\n                    let stat = fs.statSync(realPath);\n                    let lastModified = stat.mtime.toUTCString();\n                    response.setHeader(\"Last-Modified\", lastModified);\n\n                    if (request.headers[\"if-modified-since\"] && lastModified == request.headers[\"if-modified-since\"]) {\n                        response.writeHead(304, \"Not Modified\");\n                        response.end();\n                        return;\n                    }\n                    let raw = fs.createReadStream(realPath);\n                    let acceptEncoding = request.headers[\'accept-encoding\'] || \'\';\n                    if (acceptEncoding.match(/\\bdeflate\\b/)) {\n                      response.writeHead(200, { \'Content-Encoding\': \'deflate\' });\n                      raw.pipe(zlib.createDeflate()).pipe(response);\n                    } else if (acceptEncoding.match(/\\bgzip\\b/)) {\n                      response.writeHead(200, { \'Content-Encoding\': \'gzip\' });\n                      raw.pipe(zlib.createGzip()).pipe(response);\n                    } else {\n                      response.writeHead(200, {});\n                      raw.pipe(response);\n                    }\n                }\n            });\n        }\n    });\n});\n\napp.listen(80, \"127.0.0.1\");\n</code></pre>\n<p>MIME.js：</p>\n<pre><code>let type = {\n    \"txt\": \"text/plain\",\n    \"xml\": \"text/xml\",\n    \"html\": \"text/html\",\n    \"css\": \"text/css\",\n    \"js\": \"text/javascript\",\n    \"json\": \"application/json\",\n    \"gif\": \"image/gif\",\n    \"png\": \"image/png\",\n    \"jpeg\": \"image/jpeg\",\n    \"jpg\": \"image/jpeg\",\n    \"svg\": \"image/svg+xml\",\n    \"ico\": \"image/x-icon\",\n    \"pdf\": \"application/pdf\",\n    \"swf\": \"application/x-shockwave-flash\",\n    \"tiff\": \"image/tiff\",\n    \"wav\": \"audio/x-wav\",\n    \"wma\": \"audio/x-ms-wma\",\n    \"wmv\": \"video/x-ms-wmv\"\n};\n\nexports.type = type;\n</code></pre>\n<h2><a id=\"_15\"></a>九. 重构整理后的代码</h2>\n<p>显然，我们的代码已经有“意大利面条”的感觉了。对于层层回调，可以考虑使用Promise/A+来进行重构。</p>\n<p>另外，我们的静态资源服务器可以封装成模块来使用，应考虑到static目录可有多个，Gzip压缩可配置等。</p>\n<h2><a id=\"_16\"></a>十. 参考</h2>\n<p>博文共赏：Node.js静态文件服务器实战：<a href=\"http://www.infoq.com/cn/news/2011/11/tyq-nodejs-static-file-server\">http://www.infoq.com/cn/news/2011/11/tyq-nodejs-static-file-server</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/1199\">http://www.dengzhr.com/node-js/1199</a></div>\n\n        ','2','1'),(230,'学习笔记：node-mysql中防止SQL注入','\n\n            <p><strong>备注： 本文针对<a href=\"https://github.com/mysqljs/mysql\">mysqljs/mysql</a>。</strong></p>\n<hr>\n<p>为了防止SQL注入，可以将SQL中传入参数进行编码，而不是直接进行字符串拼接。在node-mysql中，防止SQL注入的常用方法有以下四种：</p>\n<h3>方法一：使用escape()对传入参数进行编码：</h3>\n<p>参数编码方法有如下三个：</p>\n<pre><code>mysql.escape(param)\nconnection.escape(param)\npool.escape(param)\n</code></pre>\n<p>例如：</p>\n<pre><code>var userId </code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p><strong>备注： 本文针对<a href=\"https://github.com/mysqljs/mysql\">mysqljs/mysql</a>。</strong></p>\n<hr>\n<p>为了防止SQL注入，可以将SQL中传入参数进行编码，而不是直接进行字符串拼接。在node-mysql中，防止SQL注入的常用方法有以下四种：</p>\n<h3><a id=\"_4\"></a>方法一：使用escape()对传入参数进行编码：</h3>\n<p>参数编码方法有如下三个：</p>\n<pre><code>mysql.escape(param)\nconnection.escape(param)\npool.escape(param)\n</code></pre>\n<p>例如：</p>\n<pre><code>var userId = 1, name = \'test\';\nvar query = connection.query(\'SELECT * FROM users WHERE id = \' + connection.escape(userId) + \', name = \' + connection.escape(name), function(err, results) {\n    // ...\n});\nconsole.log(query.sql); // SELECT * FROM users WHERE id = 1, name = \'test\'\n</code></pre>\n<h3><a id=\"_5\"></a>escape()方法编码规则如下：</h3>\n<blockquote>\n<ul>\n<li>Numbers不进行转换；</li>\n<li>Booleans转换为true/false；</li>\n<li>Date对象转换为’YYYY-mm-dd HH:ii:ss’字符串；</li>\n<li>Buffers转换为hex字符串，如X’0fa5’；</li>\n<li>Strings进行安全转义；</li>\n<li>Arrays转换为列表，如[‘a’, ‘b’]会转换为’a’, ‘b’；</li>\n<li>多维数组转换为组列表，如[[‘a’, ‘b’], [‘c’, ‘d’]]会转换为’a’, ‘b’), (‘c’, ‘d’)；</li>\n<li>Objects会转换为key=value键值对的形式。嵌套的对象转换为字符串；</li>\n<li>undefined/null会转换为NULL；</li>\n<li>MySQL不支持NaN/Infinity，并且会触发MySQL错误。</li>\n</ul>\n</blockquote>\n<h2><a id=\"_6\"></a>方法二：使用connection.query()的查询参数占位符：</h2>\n<p>可使用 <strong>?</strong> 做为查询参数占位符。在使用查询参数占位符时，在其内部自动调用 <strong>connection.escape()</strong> 方法对传入参数进行编码。</p>\n<p>如：</p>\n<pre><code>var userId = 1, name = \'test\';\nvar query = connection.query(\'SELECT * FROM users WHERE id = ?, name = ?\', [userId, name], function(err, results) {\n    // ...\n});\nconsole.log(query.sql); // SELECT * FROM users WHERE id = 1, name = \'test\'\n</code></pre>\n<p>上面程序还可以改写成如下：</p>\n<pre><code>var post  = {userId: 1, name: \'test\'};\nvar query = connection.query(\'SELECT * FROM users WHERE ?\', post, function(err, results) {\n    // ...\n});\nconsole.log(query.sql); // SELECT * FROM users WHERE id = 1, name = \'test\'\n</code></pre>\n<h2><a id=\"_7\"></a>方法三： 使用escapeId()编码SQL查询标识符：</h2>\n<p>如果你不信任用户传入的SQL标识符（数据库、表、字符名），可以使用escapeId()方法进行编码。最常用于排序等。escapeId()有如下三个功能相似的方法：</p>\n<pre><code>mysql.escapeId(identifier)\nconnection.escapeId(identifier)\npool.escapeId(identifier)\n</code></pre>\n<p>例如：</p>\n<pre><code>var sorter = \'date\';\nvar sql    = \'SELECT * FROM posts ORDER BY \' + connection.escapeId(sorter);\nconnection.query(sql, function(err, results) {\n  // ...\n});\n</code></pre>\n<h2><a id=\"_8\"></a>方法四： 使用mysql.format()转义参数：</h2>\n<p>准备查询，该函数会选择合适的转义方法转义参数 　　 mysql.format()用于准备查询语句，该函数会自动的选择合适的方法转义参数。</p>\n<p>例如：</p>\n<pre><code>var userId = 1;\nvar sql = \"SELECT * FROM ?? WHERE ?? = ?\";\nvar inserts = [\'users\', \'id\', userId];\nsql = mysql.format(sql, inserts); // SELECT * FROM users WHERE id = 1\n</code></pre>\n<h2><a id=\"_9\"></a>参考文章：</h2>\n<p><a href=\"https://github.com/mysqljs/mysql\">1</a>. <a href=\"https://github.com/mysqljs/mysql\">https://github.com/mysqljs/mysql</a></p>\n<p><a href=\"https://www.npmjs.org/search?q=mysql\">2</a>. <a href=\"http://itbilu.com/nodejs/npm/NyPG8LhlW.html\">http://itbilu.com/nodejs/npm/NyPG8LhlW.html</a></p>\n<p><strong>备注：</strong>Node.js与MySQL交互操作有很多库，具体可以在 <a href=\"https://www.npmjs.org/search?q=mysql\">https://www.npmjs.org/search?q=mysql</a> 查看。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/877\">http://www.dengzhr.com/node-js/877</a></div>\n\n        ','2','1'),(231,'Node.js插件：supervisor自动监测文件修改','\n\n            <p>在node.js中，调试的时候，无论修改了代码的哪一部分，都需要重启Node.js服务之后才能生效。这是因为 Node.js 只有在第一次引用到某部份时才会去解析脚本文件，以后都会直接访问内存，避免重复载入。Node.js的这种设计虽然有利于提高性能，却不利于开发调试，因为我们在开发过程中总是希望修改后立即看到效果，而不是每次都要终止进程并重启。</p>\n<p>supervisor可以监测文件修改，并自动�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在node.js中，调试的时候，无论修改了代码的哪一部分，都需要重启Node.js服务之后才能生效。这是因为 Node.js 只有在第一次引用到某部份时才会去解析脚本文件，以后都会直接访问内存，避免重复载入。Node.js的这种设计虽然有利于提高性能，却不利于开发调试，因为我们在开发过程中总是希望修改后立即看到效果，而不是每次都要终止进程并重启。</p>\n<p>supervisor可以监测文件修改，并自动重启Node服务器。这样修改后就能立即看到效果了。</p>\n<h2><a id=\"_4\"></a>supervisor的安装：</h2>\n<p>supervisor建议安装到全局环境。</p>\n<pre><code>npm -g install supervisor\n</code></pre>\n<p>安装完成之后就可以使用supervisor来启动服务了。</p>\n<pre><code>supervisor app.js\n</code></pre>\n<h2><a id=\"_5\"></a>supervisor支持的参数如下：</h2>\n<p>要监控的文件夹或js文件，默认为’.’：</p>\n<pre><code>-w|--watch <watchItems>\n</code></pre>\n<p>要忽略监控的文件夹或js文件：</p>\n<pre><code>-i|--ignore <ignoreItems>\n</code></pre>\n<p>监控文件变化的时间间隔（周期），默认为Node.js内置的时间：</p>\n<pre><code>-p|--poll-interval <milliseconds>\n</code></pre>\n<p>要监控的文件扩展名，默认为’node|js’：</p>\n<pre><code>-e|--extensions <extensions>\n</code></pre>\n<p>要执行的主应用程序，默认为’node’：</p>\n<pre><code>-x|--exec <executable>\n</code></pre>\n<p>开启debug模式（用–debug flag来启动node）：</p>\n<pre><code>--debug\n</code></pre>\n<p>安静模式，不显示DEBUG信息：</p>\n<pre><code>-q|--quiet\n</code></pre>\n<h2><a id=\"_6\"></a>其他：</h2>\n<p>实现同样功能的类似产品还有<a href=\"https://github.com/foreverjs/forever\">forever</a>，<a href=\"https://github.com/remy/nodemon\">nodemon</a>，<a href=\"https://github.com/fgnass/node-dev\">node-dev</a>，<a href=\"https://github.com/Unitech/pm2\">PM2</a>等。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/860\">http://www.dengzhr.com/node-js/860</a></div>\n\n        ','2','1'),(232,'【摘记】node-xlsx的使用','\n\n            <p>node-xlsx文档地址：<a href=\"https://github.com/mgcrea/node-xlsx\">https://github.com/mgcrea/node-xlsx</a>。</p>\n<p>node-xlsx依赖于 <a href=\"https://github.com/SheetJS/js-xlsx\">js-xlsx</a> 组件，API极简单，可读写xlsx文件内容。</p>\n<p>node-xlsx的主要使用方法如下：</p>\n<h3>1 . 读xlsx文件：</h3>\n<pre><code>let xlsx = require(\'node-xlsx\'),\n    fs = require(\'fs\');\n\nconst workSheetsFromBuffer = xlsx.parse(fs.readFileSync(`${__dirname}/myFile.xlsx`));</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>node-xlsx文档地址：<a href=\"https://github.com/mgcrea/node-xlsx\">https://github.com/mgcrea/node-xlsx</a>。</p>\n<p>node-xlsx依赖于 <a href=\"https://github.com/SheetJS/js-xlsx\">js-xlsx</a> 组件，API极简单，可读写xlsx文件内容。</p>\n<p>node-xlsx的主要使用方法如下：</p>\n<h3><a id=\"_4\"></a>1 . 读xlsx文件：</h3>\n<pre><code>let xlsx = require(\'node-xlsx\'),\n    fs = require(\'fs\');\n\nconst workSheetsFromBuffer = xlsx.parse(fs.readFileSync(`${__dirname}/myFile.xlsx`));\nconst workSheetsFromFile = xlsx.parse(`${__dirname}/myFile.xlsx`);\n</code></pre>\n<h3><a id=\"_5\"></a>2 . 写xlsx文件：</h3>\n<pre><code>let xlsx = require(\'node-xlsx\'),\n    fs = require(\'fs\');\n\nconst data = [[1, 2, 3], [true, false, null, \'sheetjs\'], [\'foo\', \'bar\', new Date(\'2014-02-19T14:30Z\'), \'0.3\'], [\'baz\', null, \'qux\']];\nvar buffer = xlsx.build([{name: \"mySheetName\", data: data}]);\n\nfs.writeFileSync(\'./test.xlsx\', buffer);\n</code></pre>\n<h3><a id=\"_6\"></a>3. 发送excel文件：</h3>\n<p>发送excel文件到浏览器端的关键是设置好 header 的 Content-Type 值。</p>\n<p>对于excel，Content-Type有如下两种：</p>\n<pre><code>// .xls 文件\napplication/vnd.ms-excel\n\n// .xlsx 文件\napplication/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n</code></pre>\n<p>下面以restify为例写一段demo：</p>\n<pre><code>let restify = require(\'restify\'),\n    xlsx = require(\'node-xlsx\');\n\nlet app = restify.createServer({\n    name: \'demo-xlsx\',\n    version: \'1.0.0\'\n});\n\n// 访问 http://127.0.0.1:8001/test，即下载myfile.xlsx文件\napp.get(\'/test\', function(req, res, next) {\n    const data = [[1, 2, 3], [true, false, null, \'sheetjs\'], [\'foo\', \'bar\', new Date(\'2014-02-19T14:30Z\'), \'0.3\'], [\'baz\', null, \'qux\']];\n    return sendExcel(res, data, \'sheet表名\', \'myfile\');\n});\n\napp.listen(8001, function() {\n    console.log(app.name, \'Start listening at %s\', app.url);\n});\n\n/**\n * 写入Excel\n * @param res            Response对象\n * @param xlsxData       xlsx数组\n * @param sheetName      excel表名\n * @param xlsxFileName   excel文件名（备注：不要使用中文）\n */\nfunction sendExcel(res, xlsxData, sheetName, xlsxFileName) {\n    try {\n        let buffer = xlsx.build([{name: sheetName, data: xlsxData}]);\n        let xlsxContentType = \'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\';  // For Excel2007 and above .xlsx files\n\n        res.setHeader(\'Content-Type\', xlsxContentType);\n        res.setHeader(\'Content-Disposition\', `attachment; filename=${xlsxFileName}.xlsx`);\n        res.writeHead(200);\n        res.end(buffer);\n    } catch (err) {\n        console.log(\'mistake to build excel\');\n    }\n}\n</code></pre>\n<h3><a id=\"_7\"></a>另外：其他支持读写Excel的Node.js模块有：</h3>\n<blockquote>\n<ul>\n<li><strong>node-xlsx</strong>: 可读写excel文件，仅支持xlsx格式文件；</li>\n<li><strong>excel-parser</strong>: 仅可读excel文件，支持xls及xlsx格式文件；</li>\n<li><strong>excel-export</strong>: 仅可导出excel文件，生成文件格式为xlsx；</li>\n<li><strong>node-xlrd</strong>: 仅可读excel文件，仅支持xls格式文件；</li>\n<li>… …</li>\n</ul>\n</blockquote>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/1400\">http://www.dengzhr.com/node-js/1400</a></div>\n\n        ','2','1'),(233,'Node.js的优秀模块整理： 调试篇','\n\n            <h2>目录：</h2>\n<ul>\n<li>supervisor 监视代码改动</li>\n<li>node-inspector 可使用浏览器调试Node.js</li>\n</ul>\n<h3>监视代码改动：supervisor</h3>\n<p>默认情况下，Node.js并不能监视代码的实时改动。当修改代码的某一部分时并不能实时看到修改后的效果，你必须终止Node.js再重新运行。这虽然有利于提高性能，但是并不利于开发调试。</p>\n<p>supervisor可以监视代码的改动，并自动重启Node.js。</p>\n<pre><code>$ npm install </code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>目录：</h2>\n<ul>\n<li>supervisor 监视代码改动</li>\n<li>node-inspector 可使用浏览器调试Node.js</li>\n</ul>\n<h3><a id=\"_5\"></a>监视代码改动：supervisor</h3>\n<p>默认情况下，Node.js并不能监视代码的实时改动。当修改代码的某一部分时并不能实时看到修改后的效果，你必须终止Node.js再重新运行。这虽然有利于提高性能，但是并不利于开发调试。</p>\n<p>supervisor可以监视代码的改动，并自动重启Node.js。</p>\n<pre><code>$ npm install -g supervisor\n</code></pre>\n<h3><a id=\"_6\"></a>使用浏览器调试node.js</h3>\n<p>安装：</p>\n<pre><code>$ npm install -g node-inspector\n</code></pre>\n<p>然后再终端中通过<code>node --debug-brk=5858 debug.js</code>命令连接你要除错的脚本的调试服务器启动node-inspector：</p>\n<pre><code>$ node-inspector\n</code></pre>\n<p>未完待续。。。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/838\">http://www.dengzhr.com/node-js/838</a></div>\n\n        ','2','1'),(234,'学习笔记： Ubuntu下安装搭建MySQL环境','\n\n            <p><strong>缘由：</strong> 为方便日后查阅，故整理并记录之。</p>\n<h2>一. 安装 MySQL</h2>\n<pre><code>sudo apt-get install mysql-server\nsudo apt-get install mysql-client\nsudo apt-get install php5-mysql // 安装php5-mysql是将php和mysql连接起来\n</code></pre>\n<h2>二. 检查MySQL是否正在运行</h2>\n<pre><code>sudo netstat -tap | grep mysql\n</code></pre>\n<p>当运行成功后�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p><strong>缘由：</strong> 为方便日后查阅，故整理并记录之。</p>\n<h2><a id=\"_4\"></a>一. 安装 MySQL</h2>\n<pre><code>sudo apt-get install mysql-server\nsudo apt-get install mysql-client\nsudo apt-get install php5-mysql // 安装php5-mysql是将php和mysql连接起来\n</code></pre>\n<h2><a id=\"_5\"></a>二. 检查MySQL是否正在运行</h2>\n<pre><code>sudo netstat -tap | grep mysql\n</code></pre>\n<p>当运行成功后，可以看到类似于如下的界面：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/dnak5ue7unfsnm5i0x4e7py5/image_1apg9c7o13rq6a0ne2n2d5qf9.png\" alt=\"image_1apg9c7o13rq6a0ne2n2d5qf9.png-5kB\"></p>\n<p>如果服务器不能正常运行，可以以下命令启动它：</p>\n<pre><code>sudo /ect/init.d/mysql restart\n</code></pre>\n<h2><a id=\"_6\"></a>三. 卸载MySQL</h2>\n<pre><code>sudo apt-get autoremove --purge mysql-server-5.0\nsudo apt-get remove mysql-server\nsudo apt-get autoremove mysql-server\nsudo apt-get remove mysql-common (非常重要)\n</code></pre>\n<p>清楚残留数据：</p>\n<pre><code>dpkg -l |grep ^rc|awk \'{print $2}\' |sudo xargs dpkg -P\n</code></pre>\n<h2><a id=\"_7\"></a>四. 登陆MySQL</h2>\n<pre><code>mysql -uroot -p\n</code></pre>\n<p>输入正确密码即可进入：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/fb6i2lwbowmiib67f2ubedx3/image_1apg9k8e91rjm1iiuc3c13gk1m2nm.png\" alt=\"image_1apg9k8e91rjm1iiuc3c13gk1m2nm.png-19.6kB\"></p>\n<h2><a id=\"_8\"></a>五. MySQL的一些简单操作：</h2>\n<h3><a id=\"_9\"></a>5.1 启动MySQL服务：</h3>\n<pre><code>sudo start mysql\n</code></pre>\n<h3><a id=\"_10\"></a>5.2 停止MySQL服务：</h3>\n<pre><code>sudo stop mysql\n</code></pre>\n<h3><a id=\"_11\"></a>5.3 修改 MySQL 的管理员密码：</h3>\n<pre><code>sudo mysqladmin -u root password myNewPassword\n</code></pre>\n<h3><a id=\"_12\"></a>5.4 修改MySQL启动端口：</h3>\n<pre><code>sudo vi /ect/mysql/my.cnf\n\nport = 3306 // 该端口值即MySQL的启动端口\n</code></pre>\n<h3><a id=\"_13\"></a>5.5 MySQL安装后的目录结构：</h3>\n<p>备注： 此结构只针对于使用<code>apt-get install</code>在线安装情况。</p>\n<blockquote>\n<ul>\n<li>数据库存放目录： <code>/var/lib/mysql/</code>；</li>\n<li>相关配置文件存放目录： <code>/usr/share/mysql</code>；</li>\n<li>相关命令存放目录： <code>/usr/bin</code>(mysqladmin mysqldump等命令)；</li>\n<li>启动脚步存放目录： <code>/etc/rc.d/init.d/</code>；</li>\n</ul>\n</blockquote>\n<h2><a id=\"_14\"></a>六. 远程登陆MySQL数据库</h2>\n<h3><a id=\"_15\"></a>6.1 MySQL远程访问的命令格式如下：</h3>\n<pre><code>mysql -h主机地址 -u用户名 －p用户密码\n</code></pre>\n<p>例如：<code>mysql -h192.168.1.20 -uroot －p1234567890</code>。</p>\n<p>配置完了服务器的数据访问权限，此时还不能远程访问MySQL数据库。因为现在还没有对服务器上的数据库或表赋予访问权限（GRANT）。</p>\n<h3><a id=\"_16\"></a>6.2 在目标服务器上，修改mysql的my.cnf文件：</h3>\n<pre><code>sudo vi /etc/mysql/my.cnf\n</code></pre>\n<p>注释掉bind-address，屏蔽其只对本地监听：</p>\n<pre><code># bind-address = 127.0.0.1\n</code></pre>\n<p>重启MySQL服务，使其修改的配置生效：</p>\n<pre><code>sudo restart mysql\n</code></pre>\n<h3><a id=\"_17\"></a>6.3 对服务器上的数据库或表赋予访问权限：</h3>\n<pre><code>GRANT ALL PRIVILEGES ON 数据库名.* TO 账户@\"%\" IDENTIFIED BY \"密码\";\nflush privileges;\n</code></pre>\n<p>例如： <code>GRANT ALL PRIVILEGES ON *.* TO root@\"%\" IDENTIFIED BY \"1234567890\"; flush privileges;</code>，赋予root拥有该主机中的所有数据库的访问权限。</p>\n<p>修改完成后，更新数据库修改配置：</p>\n<pre><code>flush privileges;\n</code></pre>\n<h3><a id=\"_18\"></a>6.4 修改用户的IP访问限制为所有IP：</h3>\n<p>在服务器上登陆MySQL数据库后，修改用户的IP访问限制为所有IP：</p>\n<pre><code>show databases; // 显示所有的数据库\nuse mysql; // 切换到名字为mysql的数据库\nupdate user set host = \'%\' where user = \'root\'; // 修改root用户的访问IP为无限制。\"%\"表示所有IP，也可以将其设置成固定IP地址\n</code></pre>\n<h2><a id=\"_19\"></a>七. MySQL图形化管理软件推荐</h2>\n<p>目前主流的MySQL图形化管理软件有<strong>phpMyAdmin</strong>、<strong>MySQLDumper</strong>、<strong>MySQL GUI Tools</strong>、<strong>MySQL Workbench</strong>、<strong>Navicat</strong>等。目前我使用的是 <strong>Navicat</strong>。</p>\n<h2><a id=\"_20\"></a>最后的提醒：</h2>\n<p><strong>请不要用root账号做远程登陆账号，新建用户吧！</strong></p>\n<p><strong>请不要用root账号做远程登陆账号，新建用户吧！</strong></p>\n<p><strong>请不要用root账号做远程登陆账号，新建用户吧！</strong></p>\n<p>重要的事情说三遍~ <img src=\"http://static.zybuluo.com/dengzhirong/4wp1gvldzphsjm3frne3g2tq/QQ%E5%9B%BE%E7%89%8720160807130723.gif\" alt=\"QQ图片20160807130723.gif-1kB\"></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/866\">http://www.dengzhr.com/node-js/866</a></div>\n\n        ','2','1'),(235,'Node.js的HTTP模块','\n\n            <p>Node.js标准库提供了http模块，其中封装了一个高校的HTTP服务器和一个简单的HTTP客户端。http.Server是一个基于事件的HTTP服务器；http.request则是一个HTTP客户端工具，用于向HTTP服务器发送请求，实现内容抓取。</p>\n<h2>一. HTTP服务器</h2>\n<p>http.Server提供一套封装级别很低的API，仅仅是流控制和简单的消息解析。</p>\n<p>可以使用http.CreateServer()来创建�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>Node.js标准库提供了http模块，其中封装了一个高校的HTTP服务器和一个简单的HTTP客户端。http.Server是一个基于事件的HTTP服务器；http.request则是一个HTTP客户端工具，用于向HTTP服务器发送请求，实现内容抓取。</p>\n<h2><a id=\"_4\"></a>一. HTTP服务器</h2>\n<p>http.Server提供一套封装级别很低的API，仅仅是流控制和简单的消息解析。</p>\n<p>可以使用http.CreateServer()来创建一个http.Server实例。</p>\n<pre><code>var http = require(\'http\');\n\nhttp.createServer(function (request, response){\n  response.writeHead(200, {\'Content-Type\': \'text/html\'});\n  response。write(\"Server start!\");\n  response.end(\'Hello World\\n\');\n}).listen(8080, \"127.0.0.1\");\n\nconsole.log(\'Server running on port 8080.\');\n</code></pre>\n<p>http.createServer创建了一个http.Server实例，将一个函数作为HTTP请求处理函数。这个函数接受两个参数，分别是请求对象（req）和响应对象（res）。</p>\n<h2><a id=\"_5\"></a>二. http.ServerRequest</h2>\n<p>http.ServerRequest是HTTP请求信息。一般由http.Server的request事件发送，作为第一个参数传递。</p>\n<p>HTTP请求一般分为两部分：请求头和请求体。</p>\n<p>http.ServerRequest提供了以下3个事件用于控制请求体传输。</p>\n<p>（1） <strong>data</strong>：当请求体数据到来时，该事件被触发。该事件提供一个参数trunk，表示接收到的数据。如果该事件没有被监听，那么请求体将会被抛弃；</p>\n<p>（2） <strong>end</strong>：当请求体数据传输完成时触发；</p>\n<p>（3） <strong>close</strong>：用户当前请求结束时触发。</p>\n<h3><a id=\"_6\"></a>ServerRequest的属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>complete</td>\n<td>客户端请求是否已经发送完成。</td>\n</tr>\n<tr>\n<td>httpVersion</td>\n<td>HTTP协议版本，通常是1.0或1.1。</td>\n</tr>\n<tr>\n<td>method</td>\n<td>HTTP请求方法，如GET、POST、PUT、DELETE等。</td>\n</tr>\n<tr>\n<td>url</td>\n<td>原始的请求路径。</td>\n</tr>\n<tr>\n<td>headers</td>\n<td>HTTP请求头。</td>\n</tr>\n<tr>\n<td>trailers</td>\n<td>HTTP请求尾。</td>\n</tr>\n<tr>\n<td>connection</td>\n<td>当前HTTP连接套接字，为net.Socket的实例。</td>\n</tr>\n<tr>\n<td>socket</td>\n<td>connection属性的别名。</td>\n</tr>\n<tr>\n<td>client</td>\n<td>client属性的别名。</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_7\"></a>三. 获取GET请求内容</h2>\n<p>http.ServerRequest提供的属性没有类似于PHP语言中的$_GET或$_POST的属性，那我们该如何接受客户端的表单请求呢？由于GET请求直接被嵌入在路径中，因此可以手动解释后面的内容作为GET请求的参数。</p>\n<p>实例：</p>\n<pre><code>var http = require(\"http\");\nvar url = require(\"url\");\nvar util = require(\"util\");\n\nhttp.createServer(function(req, res) {\n    res.writeHead(200, {\"Content-Type\": \"text/html\"});\n    res.end(util.inspect(url.parse(req.url, true)));\n}).listen(3000);\n</code></pre>\n<p>在浏览器中访问http://127.0.0.1:3000/?name=deng&age=22，返回结果如下：</p>\n<pre><code>Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, \n    search: \'?name=deng&age=22\', \n    query: { name: \'deng\', age: \'22\' }, pathname: \'/\', \n    path: \'/?name=deng&age=22\', href: \'/?name=deng&age=22\' }\n</code></pre>\n<p>通过url.parse，原始的path被解释为一个对象，其中query就是请求的内容。</p>\n<h2><a id=\"_8\"></a>四. 获取POST请求内容</h2>\n<p>POST请求的全部内容都在请求体中。</p>\n<h2><a id=\"_9\"></a>五. http.ServerReponse</h2>\n<p>http.ServerReponse是返回给客户端的信息，决定了用户最终能看到的结果，一般作为http.createServer(function(req, res) {})函数中的res参数传递。</p>\n<p>http.ServerReponse有三个重要的成员函数，用于返回响应头、响应内容以及结束请求。</p>\n<p><strong>response.writeHead(statusCode, [headers])：</strong>向请求的客户端发送响应头。statusCode是HTTP状态码，headers是一个表示响应头属性的对象；</p>\n<p><strong>response.write(data, [encoding])：</strong>向请求的客户端发送相应内容。data表示要发送的内容，encoding表示编码方式（默认是utf-8）；</p>\n<p><strong>response.end([data], [encoding])：</strong>结束响应，告知客户端所有发送已经完成。当所有要返回的内容发送完毕的时候，该函数必须被调用一次。如果不调用该函数，客户端将永远处于等待状态。</p>\n<h2><a id=\"_10\"></a>六. HTTP客户端</h2>\n<p>http模块提供了两个函数http.request和http.get，作为客户端想HTTP服务器发起请求。</p>\n<h3><a id=\"_11\"></a>1. http.request()</h3>\n<p>http.request(options, callback)发起HTTP请求。</p>\n<p>其中options的常用参数如下：</p>\n<blockquote>\n<ul>\n<li>host：请求网站的域名或IP地址；</li>\n<li>port：请求网站的端口，默认是80；</li>\n<li>method：请求方法，默认是GET；</li>\n<li>path：请求的相对于根的路径，默认是”/”；</li>\n<li>headers：请求头的内容；</li>\n</ul>\n</blockquote>\n<pre><code>var http = require(\"http\");\nvar querystring = require(\"querystring\");\n\nvar contents = querystring.stringify({\n    name: \"deng\",\n    age: 22\n});\n\nvar options = {\n    host: \"dengzhr.com\",\n    method: \"POST\",\n    headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n        \"Content-Length\": contents.length\n    }\n};\n\nvar req = http.request(options, function(res) {\n    res.setEncoding(\"utf8\");\n    res.on(\"data\", function(data) {\n        console.log(data);\n    });\n});\n\nreq.write(contents);\nreq.end();\n</code></pre>\n<p>在发送POST请求时，一定不要忘记通过req.end()结束请求，否则服务器将不会收到消息。</p>\n<h3><a id=\"_12\"></a>2. http.get()</h3>\n<p>http.get(options, callback)是http模块的用于处理GET请求的更加简便的方法。不需要手动调用req.end()。</p>\n<p>实例：</p>\n<pre><code>var http = require(\"http\");\n\nhttp.get({host: \"dengzhr.com\"}, function(res) {\n    res.setEncoding(\"utf8\");\n    res.on(\"data\", function(data) {\n        console.log(data);\n    });\n});\n</code></pre>\n<p>关于Node.js的http模块官方的API文档如下：<a href=\"https://nodejs.org/api/http.html\">https://nodejs.org/api/http.html</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/639\">http://www.dengzhr.com/node-js/639</a></div>\n\n        ','2','1'),(236,'Node.js学习笔记： 文件权限和读写flag属性','\n\n            <p>老是记不住文件或目录权限的数值表达和字符表达。故整理出该笔记，方便以后查阅。</p>\n<h2>文件权限的数字类型</h2>\n<p>用数字来代表各个权限，各权限的分数对照表如下：</p>\n<ul>\n<li><strong>r: 4</strong></li>\n<li><strong>w: 2</strong></li>\n<li><strong>x: 1</strong></li>\n</ul>\n<p>文件的基本权限有9个，分别是<strong>owner、group、others</strong>三种身份各有自己的<strong>read、write、execute</strong>权限。例如文件的权限字符为”-rwxrwxrwx”这9个权限是三个三个一�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>老是记不住文件或目录权限的数值表达和字符表达。故整理出该笔记，方便以后查阅。</p>\n<h2><a id=\"_4\"></a>文件权限的数字类型</h2>\n<p>用数字来代表各个权限，各权限的分数对照表如下：</p>\n<ul>\n<li><strong>r: 4</strong></li>\n<li><strong>w: 2</strong></li>\n<li><strong>x: 1</strong></li>\n</ul>\n<p>文件的基本权限有9个，分别是<strong>owner、group、others</strong>三种身份各有自己的<strong>read、write、execute</strong>权限。例如文件的权限字符为”-rwxrwxrwx”这9个权限是三个三个一组的。每种身份（owner、group、others）各自的权限（r、w、x）分数是需要累加的。</p>\n<p>例如，当权限为[-rwxrwx—]时，分数则是：</p>\n<blockquote>\n<ul>\n<li>owner = rwx = 4 + 2 + 1 = 7</li>\n<li>group = rwx = 4 + 2 + 1 = 7</li>\n<li>others = — = 0 + 0 + 0 = 0</li>\n</ul>\n</blockquote>\n<p>所以在设置权限的更改时，该文件的权限数字就是770。</p>\n<h2><a id=\"_5\"></a>文件的读写flag属性</h2>\n<p>在读写文件时，有时候需要设置文件的读写操作属性。例如使用过readFile()方法完整读取一个文件时，</p>\n<pre><code>fs.readFile(filename [, options], callback)\n</code></pre>\n<p>其中options参数值为一个对象，在其中指定读取文件时需要使用的选项，在该参数对象中可以使用flag属性指定对该文件采取什么操作，默认值为”r”。可指定值如下：</p>\n<table>\n<thead>\n<tr>\n<th>flag</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>r</td>\n<td>读取文件。如果文件不存在时抛出异常</td>\n</tr>\n<tr>\n<td>r+</td>\n<td>读取并写入。如果文件不存在时抛出异常</td>\n</tr>\n<tr>\n<td>rs</td>\n<td>以同步方式读取文件并通知操作系统忽略本地文件系统缓存。如果文件不存在时抛出异常</td>\n</tr>\n<tr>\n<td>w</td>\n<td>写入文件。如果文件不存在时则创建该文件。如果文件已存在则清空文件内容</td>\n</tr>\n<tr>\n<td>w+</td>\n<td>读取并写入文件。如果文件不存在时则创建该文件。如果文件已存在则清空文件内容</td>\n</tr>\n<tr>\n<td>wx</td>\n<td>作用与”w”类似。但是以排他方式打开文件</td>\n</tr>\n<tr>\n<td>wx+</td>\n<td>作用与”w+”类似。但是以排他方式打开文件</td>\n</tr>\n<tr>\n<td>a</td>\n<td>以追加方式写入文件。如果文件不存在时则创建该文件</td>\n</tr>\n<tr>\n<td>a+</td>\n<td>读取并以追加方式写入文件。如果文件不存在时则创建该文件</td>\n</tr>\n<tr>\n<td>ax</td>\n<td>作用与”a”类似。但是以排他方式打开文件</td>\n</tr>\n<tr>\n<td>ax+</td>\n<td>作用与”a+”类似。但是以排他方式打开文件</td>\n</tr>\n</tbody>\n</table>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/844\">http://www.dengzhr.com/node-js/844</a></div>\n\n        ','2','1'),(237,'Node.js学习笔记：读写流Stream','\n\n            <h2>一. 可读流: stream.Readable</h2>\n<p>在Node.js中，各种实现了stream.Readable接口的对象可以将对象数据读取为流数据，所有这些对象都集成了EventEmitter类的实例对象，在读取数据的过程中，将可能触发各种事件。</p>\n<p>在Node.js中，可以使用flowing模式与非flowing模式来读取数据。当使用flowing模式时，将使用操作系统�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 可读流: stream.Readable</h2>\n<p>在Node.js中，各种实现了stream.Readable接口的对象可以将对象数据读取为流数据，所有这些对象都集成了EventEmitter类的实例对象，在读取数据的过程中，将可能触发各种事件。</p>\n<p>在Node.js中，可以使用flowing模式与非flowing模式来读取数据。当使用flowing模式时，将使用操作系统内部I/O机制来读取数据，这将允许你以最快的速度来读取数据。当使用非flowing模式时，就必须显式调用对象的read方法来读取数据。</p>\n<h3><a id=\"_5\"></a>Node.js中的各种用于读取数据的对象如下：</h3>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fs.ReadStream</td>\n<td>用于读取文件</td>\n</tr>\n<tr>\n<td>http.IncomingMessage</td>\n<td>代表客户端请求或服务器响应</td>\n</tr>\n<tr>\n<td>net.Socket</td>\n<td>代表一个socket端口对象</td>\n</tr>\n<tr>\n<td>child.stdout</td>\n<td>用于创建子进程的标准输出流。如果子进程与父进程共享输入输出流，则子进程的标准输出流被废弃</td>\n</tr>\n<tr>\n<td>child.stderror</td>\n<td>用于创建子进程的错误输出流。如果子进程与父进程共享输入输出流，则子进程的标准输出流被废弃</td>\n</tr>\n<tr>\n<td>process.stdin</td>\n<td>用于创建进程的标准输入流</td>\n</tr>\n<tr>\n<td>Gzip<br>\nDeflate<br>\nDeflateRaw</td>\n<td>用于实现数据压缩</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"_6\"></a>可读流对象将有可能触发的事件如下：</h3>\n<table>\n<thead>\n<tr>\n<th>事件名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>readable</td>\n<td>当可以从流中读出数据时触发。</td>\n</tr>\n<tr>\n<td>data</td>\n<td>当读取到来自文件、客户端、服务器端等对象的新数据时触发data事件。参数值为存放了已读取到的数据的缓存区对象或一个字符串（当对流数据指定编码格式时）。如果指定了data事件的回调函数，将使用flowing模式来读取流数据，这允许你以最快速度读出流中的数据</td>\n</tr>\n<tr>\n<td>end</td>\n<td>当读取完所有数据时触发，该事件的触发以为这data事件将不再内触发</td>\n</tr>\n<tr>\n<td>error</td>\n<td>当读取数据过程中产生错误时触发</td>\n</tr>\n<tr>\n<td>close</td>\n<td>当用于读取流数据的对象被关闭时触发。并非所有用于读取流数据的对象都会触发该事件</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"_7\"></a>可读流对象所拥有的方法如下：</h3>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>read</td>\n<td>用于读取数据</td>\n</tr>\n<tr>\n<td>setEncoding</td>\n<td>用于指定用什么编码方式读取数据</td>\n</tr>\n<tr>\n<td>pause</td>\n<td>用于通知对象停止触发data事件</td>\n</tr>\n<tr>\n<td>resume</td>\n<td>用于通知对象停止触发data事件</td>\n</tr>\n<tr>\n<td>pipe</td>\n<td>用于设置一个数据通道，然后取出所有流数据并将其输出到通道另一端所指向的目标对象中</td>\n</tr>\n<tr>\n<td>unpipe</td>\n<td>用于取消在pipe方法中设置的通道</td>\n</tr>\n<tr>\n<td>unshift</td>\n<td>当对流数据绑定了一个解析器时，可以使用unshift方法来取消该解析器的绑定，使流数据可以通过其他方式解析</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_8\"></a>二. 可写流: stream.Writeable</h2>\n<p>在Node.js中，各种实现了stream.Writeable接口的对象来将数据流写入到对象中，所有这些对象都是继承了EventEmitter类的实例对象。</p>\n<h3><a id=\"_9\"></a>各种用于写入数据的对象如下：</h3>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fs.WriteStream</td>\n<td>用于写入文件</td>\n</tr>\n<tr>\n<td>http.ClientRequest</td>\n<td>用于写入HTTP客户端请求数据</td>\n</tr>\n<tr>\n<td>http.ServerResponse</td>\n<td>用于写入HTTP服务器端响应数据</td>\n</tr>\n<tr>\n<td>net.Socket</td>\n<td>用于读写TCP流或UNIX流，可被用户创建并作为一个客户端来使用，也可被Node.js脚本程序创建并通过服务器的connection事件来传递给用户</td>\n</tr>\n<tr>\n<td>child.stdin</td>\n<td>用于创建子进程的标准输入流。使用该对象的close方法将终止子进程。如果子进程与父进程共享输入输出流，则子进程的标准输出流被废弃</td>\n</tr>\n<tr>\n<td>child.stdout</td>\n<td>用于创建子进程的错误输出流</td>\n</tr>\n<tr>\n<td>child.stderror</td>\n<td>用于创建子进程的错误输出流</td>\n</tr>\n<tr>\n<td>Gzip<br>\nDeflate<br>\nDeflateRaw</td>\n<td>用于实现数据压缩</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"_10\"></a>可写流对象将有可能触发的事件有：</h3>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>drain</td>\n<td>当用于写入数据的write方法返回false之后触发，表示操作系统缓存区中的数据已全部输出到目标对象中，可以继续向操作系统缓存区中写入数据</td>\n</tr>\n<tr>\n<td>finish</td>\n<td>当end方法被调用且数据被全部写入操作系统缓存区时触发</td>\n</tr>\n<tr>\n<td>pipe</td>\n<td>当用于读取数据的对象的pipe方法被调用时触发</td>\n</tr>\n<tr>\n<td>unpipe</td>\n<td>当用于读取数据的对象的unpipe方法被调用时触发</td>\n</tr>\n<tr>\n<td>error</td>\n<td>当写入数据的过程中产生错误时触发</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"_11\"></a>可写流对象所拥有的方法有：</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>write</td>\n<td>用于写入数据</td>\n</tr>\n<tr>\n<td>end</td>\n<td>当没有数据再被写入流中时调用该方法。这将迫使操作系统缓存区中的剩余数据被立即写入目标对象中。当该方法被调用后，将不能继续在目标对象中写入数据</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_12\"></a>三. 使用ReadStream对象读取文件</h2>\n<p>在fs模块中，可以使用createReadStream()方法创建一个将文件内容读取为流数据的ReadStream对象，该方法的使用方式如下：</p>\n<pre><code> fs.createReadStream(path [, options])\n</code></pre>\n<p>参数：</p>\n<blockquote>\n<ul>\n<li>path： 需要被读取的文件的完整路径及文件名；</li>\n<li>options： 数据类型为对象，可选，其属性值有：\n<ul>\n<li>flags: 用于指定对该文件采取什么操作，默认值为”r”；</li>\n<li>encoding： 用于指定使用什么编码格式来读取该文件。可指定属性值为”utf8″、”ascii”、”base64″。默认值为null；</li>\n<li>autoClose：用于指定是否关闭在读取文件时操作系统内部使用的文件描述符。如果属性值设置为false，则文件不会自动关闭，即使在读取文件过程中产生了错误，开发者也必须通过使用close方法或closeSync方法来手动关闭文件。如果属性值设定为true，则文件读取完毕或读取文件过程中产生错误时，文件将自动关闭。默认值为true；</li>\n<li>start： 指定文件开始读取位置（单位为字节数）；</li>\n<li>end： 指定文件结束读取位置（单位为字节数）。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3><a id=\"_13\"></a>实例一：使用ReadStream方法读取文件</h3>\n<pre><code>var fs = require(\'fs\');\n\nvar file = fs.createReadStream(\"1.js\");\nfile.on(\"open\", function(fd) {\n    console.log(\"开始读取文件：\");\n});\nfile.on(\"data\", function(data) {\n    console.log(\"读取到数据：\");\n     console.log(data);\n});\nfile.on(\"end\", function() {\n     console.log(\"文件已全部读取完毕。\");\n});\nfile.on(\"close\", function() {\n    console.log(\"文件被关闭。\");\n});\nfile.on(\"error\", function() {\n    console.log(\"读取文件失败。\");\n});\n</code></pre>\n<p>console打印值如下：</p>\n<pre><code>开始读取文件：\n读取到数据：\n<Buffer 63 6f 6e 73 74 20 6f 73 20 3d 20 72 65 71 75 69 72 65 28 27 6f 73 27 29 3b 0d 0a 0d 0a 76 61 72 20 74 79 70 65 20 3d 20 6f 73 2e 74 79 70 65 28 29 3b>\n文件已全部读取完毕。\n文件被关闭。\n</code></pre>\n<h3><a id=\"_14\"></a>实例二：使用ReadStream方法延时读取文件</h3>\n<p>打开文件后暂停文件的读取，隔3秒钟后开始读取文件并在控制台中输出文件内容：</p>\n<pre><code>var fs = require(\'fs\');\n\nvar file = fs.createReadStream(\"1.js\");\nfile.pause();\nfile.on(\"data\", function(data) {\n    console.log(\"读取到数据：\");\n     console.log(data);\n});\nsetTimeout(function() {\n    file.resume();\n}, 3000);\n</code></pre>\n<h2><a id=\"_15\"></a>四. 使用ReadStream对象读取文件</h2>\n<p>在fs模块中，可以使用createWriteStream()方法创建一个将文件内容读取为流数据的ReadStream对象，该方法的使用方式如下：</p>\n<pre><code> fs.createWriteStream(path [, options])\n</code></pre>\n<p>参数与 fs.createWriteStream()方法的类似。</p>\n<h3><a id=\"_16\"></a>write()方法：</h3>\n<p>WriteStream对象具有一个write()方法，用于将数据流写入目标对象，该方法的使用方式如下：</p>\n<pre><code>writable.write(trunk, [encoding], [callback])\n</code></pre>\n<p>其中，trunk为一个Buffer对象或一个字符串，用于指定写入的数据。 当trunk为字符串时，可以指定encoding参数值来指定将数据以何种编码方式写入文件。</p>\n<h3><a id=\"_17\"></a>end()方法</h3>\n<p>WriteStream对象还具有一个end()方法，用于将数据流写入目标对象，该方法的使用方式如下：</p>\n<pre><code>writable.end([trunk], [encoding], [callback])\n</code></pre>\n<p>其中trunk表示在文件关闭之前需要在文件中追加写入的数据。</p>\n<h3><a id=\"_18\"></a>bytesWritten属性：</h3>\n<p>另外，WriteStream对象还具有一个bytesWritten属性，属性值为当前已在文件中写入数据的字节数。</p>\n<h3><a id=\"_19\"></a>实例：文件拷贝</h3>\n<pre><code>var fs = require(\'fs\');\n\nvar file = fs.createReadStream(\"1.js\");\nvar outputFile = fs.createWriteStream(\"output.js\");\nfile.on(\"data\", function(data) {\n    outputFile.write(data);\n});\noutputFile.on(\"open\", function(fd) {\n    console.log(\"需要被写入的文件已被打开。\");\n});\nfile.on(\"end\", function() {\n    outputFile.end(\"The end.\", function() {\n        console.log(\"文件全部写入完毕。\");\n        console.log(\"共写入%d字节数据。\", outputFile.bytesWritten);\n    });\n});\n</code></pre>\n<p>console输出值如下：</p>\n<pre><code>需要被写入的文件已被打开。\n文件全部写入完毕。\n共写入206字节数据。\n</code></pre>\n<p>此时，output.js已完整拷贝了1.js中的全部内容。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/847\">http://www.dengzhr.com/node-js/847</a></div>\n\n        ','2','1'),(238,'bluebird中的常用 Promsie API整理','\n\n            <p><a href=\"https://github.com/petkaantonov/bluebird\">bluebird</a>是一个第三方的Promise类库，并且根据Promise A+规范实现，在ECMAScript 2015的基础上添加了很多扩展方法，如.spread()展开结果集、Promise.promisifyAll()将一个模块的属性方法包装成一个Promise实例。</p>\n<p>blueBird的API文档可以<a href=\"http://bluebirdjs.com/docs/api-reference.html\">查看这里</a>。</p>\n<p>本文主要列举几个常用的API，方便在熟悉阶段的时候查用。</p>\n<h2>一. 核心API</h2>\n<h3>new Promise()</h3>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p><a href=\"https://github.com/petkaantonov/bluebird\">bluebird</a>是一个第三方的Promise类库，并且根据Promise A+规范实现，在ECMAScript 2015的基础上添加了很多扩展方法，如.spread()展开结果集、Promise.promisifyAll()将一个模块的属性方法包装成一个Promise实例。</p>\n<p>blueBird的API文档可以<a href=\"http://bluebirdjs.com/docs/api-reference.html\">查看这里</a>。</p>\n<p>本文主要列举几个常用的API，方便在熟悉阶段的时候查用。</p>\n<h2><a id=\"_4\"></a>一. 核心API</h2>\n<h3><a id=\"_5\"></a>new Promise() – 创建实例</h3>\n<pre><code>new Promise(Function<function resolve, Function reject> resolver)\n</code></pre>\n<p>该方法用于创建一个新的Promise实例，与Promise A+规范的实现一致。传入函数的参数有两个：<code>resolve</code>、<code>reject</code>，分别用于执行成功和执行失败时的调用。</p>\n<h3><a id=\"_6\"></a>.then([function fullfilledHandler]. [function rejectedHandler])</h3>\n<p>Promise A+规范中的<code>.then()</code>方法相同。</p>\n<h3><a id=\"_7\"></a>.spread([Function fullfilledHandler], [Function rejectedHandler])</h3>\n<p>与.then()方法类似，但是上一个回调函数的结果值或者抛出的异常必须是一个数组。这个数组的元素将会依次作为参数传入fulfilledHandler处理函数。</p>\n<pre><code>Promise.delay(500).then(() => {\n    return [fs.readFileAsync(\'file1.txt\'),\n            fs.readFileAsync(\'file2.txt\')];\n})\n.spread((file1text, file2text) => {\n    // ...\n});\n</code></pre>\n<p>如果想整个多个不相干但是同时进行的promise，可使用<code>Promise.join()</code>。</p>\n<h3><a id=\"_8\"></a>.catch(Function handler)</h3>\n<p>从.then()调用链中产生的任何异常都会被传送到最近的.catch()函数中。</p>\n<p>这个方法有两个变体：一个用于捕获所有异常，一个用于捕获指定异常。</p>\n<p><strong>捕获所有异常：</strong></p>\n<pre><code>.catch(function(any error) handler)\n</code></pre>\n<p><strong>捕获部分异常：</strong></p>\n<pre><code>.catch(class ErrorClass|function(any error)|Object predicate..., function(any error) handler)\n</code></pre>\n<p>例如：</p>\n<pre><code>somePromsie.then(() => {\n    return add();\n}).catch(TypeError, e => {\n    // ...\n}).catch(ReferenceError, e => {\n    // ...\n}).catch(e => {\n    // ...\n});\n</code></pre>\n<h3><a id=\"_9\"></a>.error([reejectHandler])</h3>\n<p>类似.catch，但是它只捕获operational errors，而不是捕获某一特定类型的异常。</p>\n<p>当一个被promise化的函数因为运行中的某些异常被终止执行，将会触发.error()。但是如果这个异常是被throws出来的，只有.catch才能捕获。</p>\n<pre><code>.catch(isOperationalError, e => { // ... })\n\n等价于：\n\n.error(e => { // ... })\n</code></pre>\n<h3><a id=\"_10\"></a>.finally(Function handler)</h3>\n<p>无论promise调用链的情况如何，.finally都会在最后被调用。最后的返回值不能在句柄中被改变。</p>\n<h3><a id=\"_11\"></a>.bind(dynamic thisArg)</h3>\n<p>创建一个promise对象，这个对象与给定的thisArg绑定，对象内部的this将会指向被绑定的值。由于这个被绑定对象所产生的promise对象也会被绑定到thisArg。</p>\n<h3><a id=\"_12\"></a>Promise.join(Promise | Tenable | value promises …, Function handler)</h3>\n<p>用于协调多个并行的promise。当需要处理一个不定数量但是规格一致的多个promise时,<code>.all()</code>是较好的选择。但是当我们需要协调固定数量的离散的promise实例时，<code>Promise.join()</code>是一种更加简单（以及更加优雅）的方法。</p>\n<pre><code>let Promise = require(\'bluebird\');\nPromise.join(\n        getPicture(),\n        getComment(), \n        getTweets(), \n        function(pictures, comments, tweets) {\n            // ...\n        });\n</code></pre>\n<h3><a id=\"_13\"></a>Promise.try(Function fn [, Array | dynamic arguments] [, dynamic ctx])</h3>\n<p>通过<code>Promise.try</code>启动一个promise链，并将所有同步异常封装到promise的reject处理中。</p>\n<pre><code>function getUserById(id) {\n    return Promise.try(function() {\n        if (typeof id !== \"number\") {\n            throw new Error(\"id must be a number\");\n        }\n        return db.getUserById(id);\n    });\n}\n</code></pre>\n<p>经过<code>Promise.try</code>封装后，其同步和异步的异常都可以通过<code>.catch</code>来捕获。</p>\n<h3><a id=\"_14\"></a>Promsie.method(Function fn)</h3>\n<p>包装指定的函数fn，并使包装后的函数返回一个Promise实例。</p>\n<h3><a id=\"_15\"></a>Promise.resolve(dynamic value)</h3>\n<p>将对象包装成resolved状态的Promise实例。</p>\n<p>创建一个状态未resolved（已解决）的promise。如果传入的值已经是一个Promise，那么它将直接返回。如果value不可以继续调用（不是thenable对象），则将会返回一个状态未fullfilled(已完成)的Promise，其带有的返回值就是value。</p>\n<h3><a id=\"_16\"></a>Promise.reject(dynamic reason)</h3>\n<p>将对象包装成rejected状态的Promise实例。</p>\n<p>产生一个状态为rejected（已拒绝）的promise对象，返回值带有reason。</p>\n<h3><a id=\"_17\"></a>Promise.bind(dynamic thisArg)</h3>\n<p>Promise.resolue(undefined).bind(thisArg)的语法糖。</p>\n<h2><a id=\"_18\"></a>二. 集合操作</h2>\n<p>所有的集合方法在Promise对象中都有一个静态的等价方法。</p>\n<h3><a id=\"_19\"></a>.all()</h3>\n<p>将多个Promise实例包装成一个新实例。</p>\n<p>promise数组中所有的promise实例均变为resolve时，该方法才会返回resolve的Promise实例，并将所有的结果传递到结果数组中。</p>\n<p>如果promise数组中任何一个promise实例为reject的话，则整个<code>Promise.all()</code>调用就会立即终止，并返回一个状态未reject的新promise实例。</p>\n<pre><code>var files = [];\n\nfor(var i = 0; i < 10; i++) {\n    files.push(fs.writeFileAsync(\'file-\' + i + \'.txt\', \'\', \'utf-8\'));\n}\nPromise.all(files).then(function(result) {\n    // ...\n});\n</code></pre>\n<h3><a id=\"_20\"></a>.props()</h3>\n<p>类似.all()，但是针对对象属性的，而不是数组。</p>\n<p>当对象属性全部变成执行通过并返回一个resolve状态的promise对象，这个promise对象的fulfillment值是一个拥有原对象键值对应关系的对象。</p>\n<pre><code>Promise.props({\n    picture: getPictures(),\n    comments: getComments(),\n    tweets: getTweets()\n}).then(result => {\n    console.log(result.tweets, result.pictures, result.comments);\n});\n</code></pre>\n<h3><a id=\"_21\"></a>.settle()</h3>\n<p>遍历一个包含多个promise的数组，或者一个数组的promise对象。当数组中的所有元素状态均为‘已完成或者‘已拒绝’时，将会返回一个状态‘已完成’的对象。</p>\n<p>当有一个promise组成的数组，并且希望知道他们什么时候全部处理完毕，无论最终状态都是‘已完成’还是‘已拒绝’，这个方法将很有用。</p>\n<h3><a id=\"_22\"></a>.any()</h3>\n<p>类似于.some(1)。但是终值不是一个数组，而是值本身。执行成功1个promise实例，即返回resolve状态的Promise实例。</p>\n<h3><a id=\"_23\"></a>.race()</h3>\n<p>将数组中的非Promise对象，包装成Promise对象。</p>\n<p>给定一个数组，当其中任意一个元素状态变成‘已完成’或者‘已拒绝’时，都会立即返回一个Promise，带有终值或者reason。</p>\n<h3><a id=\"_24\"></a>.some(int count)</h3>\n<p>成功执行指定次数后返回一个promise实例。这个promise对象的fulfillment值是一个数组，元素是执行最快的那几个promise的终值。</p>\n<pre><code>Promise.some([\n    ping(\'ns1.example.com\'),\n    ping(\'ns2.example.com\'),\n    ping(\'ns3.example.com\'),\n    ping(\'ns4.example.com\')\n], 2).spread((first, second) => {\n    // ...\n});\n</code></pre>\n<p>如果有太多的promise的状态未‘已拒绝’，以至于最后无法完成，那么将会抛出一个AggregateError错误。</p>\n<h3><a id=\"_25\"></a>.map(Function mapper [, Object options])</h3>\n<p>遍历一个数组或者一个数组的promise，对每一个元素使用mapper函数（参数依次为item、idnex、arrayLength）。</p>\n<p>如果任何一个promise实例执行失败，则返回状态为reject的Promise实例。</p>\n<p>mapper函数会尽快被调用，即当数组的元素对应的promise被解决时。这意味着由最终解决组成的元素顺序不一定和输入时一样。.map()可以用于并发协作。</p>\n<pre><code>let fs = Promise.promisifyAll(require(\'fs\'));\nfs.readFileSync(\'.\').map(fileName => {\n    return JSON.parse\n        .catch(SyntaxError, e => {\n            e.fileName = fileName;\n            throw e;\n        });\n});\n</code></pre>\n<p>map的静态用法：</p>\n<pre><code>let fs = Promise.promisifyAll(require(\'fs\'));\nlet fileNames = [\'file1.txt\', \'file2.txt\'];\nPromise.map(fileNames, fileName => {\n    return fs.readFileSync(fileName)\n        .then(JSON.parse)\n        .catch(SyntaxError, e => {\n            e.fileName = fileName;\n            throw e;\n        });\n});\n</code></pre>\n<p>在Options参数对象中，还可以设置concurrency属性，置顶一个并发数。并发数限制了同时执行的Promise数量。</p>\n<pre><code>...map(..., {concurrency: 1});\n</code></pre>\n<p>Options.concurrency的默认值为Infinity，不限制并发数。</p>\n<p><code>Promise.map</code>还可以用于替代<code>数组.push + Promise.all</code>方法：</p>\n<pre><code>使用数组.push + Promise.all()\nvar promises = [];\nfor (var i = 0; i < fileNames.length; ++i) {\n    promises.push(fs.readFileAsync(fileNames[i]));\n}\nPromise.all(promises).then(function() {\n    console.log(\"done\");\n});\n\n使用Promise.map()：\n\nPromise.map(fileNames, function(fileName) {\n    return fs.readFileAsync(fileName);\n}).then(function() {\n    console.log(\"done\");\n});\n</code></pre>\n<h3><a id=\"_26\"></a>.reduce(Function reducer [, dynamic initialValue])</h3>\n<p>归约一个数组或一个数组的Promise。归约函数会被传入四个参数：（total, item, index, arrayLength）。</p>\n<p>如果归约函数返回了一个promise或者其他含有.then()方法的对象，那么在继续下一个循环之前，这个promise的结果会被延迟。</p>\n<p>譬如，使用Promise.reduce计算从三个文件中读取值的总和，每个文件中都有一个数字10：</p>\n<pre><code>Promise.reduce([\"file1.txt\", \"file2.txt\", \"file3.txt\"], function(total, fileName) {\n  return fs.readFileAsync(fileName, \"utf8\").then(function(contents) {\n    return total + parseInt(contents, 10);\n  });\n}, 0).then(function(total) {\n  //Total is 30\n});\n</code></pre>\n<h3><a id=\"_27\"></a>.filter(Function filterer [, Object options])</h3>\n<p>为指定promise数组执行一个过滤函数filterer，并返回经过筛选后promises数组。</p>\n<p>一种让下面的过程更加有效率的方法：</p>\n<pre><code>var Promise = require(\"bluebird\");\nvar E = require(\"core-error-predicates\");\nvar fs = Promise.promisifyAll(require(\"fs\"));\n\nfs.readdirAsync(process.cwd()).filter(function(fileName) {\n    return fs.statAsync(fileName)\n        .then(function(stat) {\n            return stat.isDirectory();\n        })\n        .catch(E.FileAccessError, function() {\n            return false;\n        });\n}).each(function(directoryName) {\n    console.log(directoryName, \" is an accessible directory\");\n});\n</code></pre>\n<h3><a id=\"_28\"></a>.each(Fucntion iterator)</h3>\n<p>依次遍历一个数组或者一个数组的promise。遍历函数会被传入四个参数：（total, item, index, arrayLength）。</p>\n<p>如果任何一个promise实例执行失败，则返回状态为reject的Promise实例。</p>\n<p>如果遍历函数返回了一个promise或者其他含有.then()方法的对象，那么在继续下一个循环之前，这个promise的结果会被延迟。</p>\n<pre><code>// Source: http://jakearchibald.com/2014/es7-async-functions/\nfunction loadStory() {\n  return getJSON(\'story.json\')\n    .then(function(story) {\n      addHtmlToPage(story.heading);\n      return story.chapterURLs.map(getJSON);\n    })\n    .each(function(chapter) { addHtmlToPage(chapter.html); })\n    .then(function() { addTextToPage(\"All done\"); })\n    .catch(function(err) { addTextToPage(\"Argh, broken: \" + err.message); })\n    .then(function() { document.querySelector(\'.spinner\').style.display = \'none\'; });\n}\n</code></pre>\n<h2><a id=\"_29\"></a>三. 函数Promise化</h2>\n<p>Promise化是指将一个不符合promise规范的API改造成返回promise的API。</p>\n<p>在Node.js中，通常的做法是使用<code>promisify</code>来包装非Promise对象，然后就可以使用符合promise规范的方法了。</p>\n<p>譬如：</p>\n<pre><code>var fs = require(\'fs\');\nPromise.promisifyAll(fs);\nfs.readFileAsync(\"file.js\", \"utf8\").then(...)\n</code></pre>\n<p>在fs模块中有一个例外，fs.existsAsync的行为不符合预期，因为fs.exists不会在第一个参数里回调错误。解决方法是使用fs.statAsync。</p>\n<h3><a id=\"_30\"></a>Promise.promisify(Function nodeFunction [, dynamic receiver])</h3>\n<p>对给定的nodeFunction进行Promise化。譬如：</p>\n<pre><code>var readFile = Promise.promisify(require(\"fs\").readFile);\n\nreadFile(\"myfile.js\", \"utf8\").then(function(contents) {\n    return eval(contents);\n}).then(function(result) {\n    console.log(\"The result of evaluating myfile.js\", result);\n}).catch(SyntaxError, function(e) {\n    console.log(\"File had syntax error\", e);\n}).catch(function(e) {\n    console.log(\"Error reading file\", e);\n});\n</code></pre>\n<pre><code>var redisGet = Promise.promisify(redisClient.get, redisClient);\nredisGet(\'foo\').then(function() {\n    //...\n});\n</code></pre>\n<p>当Promise化后的nodeFunction有多个返回值，应使用.spread API。</p>\n<pre><code>var Promise = require(\"bluebird\");\nvar request = Promise.promisify(require(\'request\'));\nrequest(\"http://www.google.com\").spread(function(response, body) {\n    console.log(body);\n}).catch(function(err) {\n    console.error(err);\n});\n</code></pre>\n<h3><a id=\"_31\"></a>Promise.promisifyAll(Object tartget [, Object options])</h3>\n<p>对tartget对象的所有属性方法进行Promise化。</p>\n<pre><code>Promise.promisifyAll(require(\"redis\"));\n\n//Later on, all redis client instances have promise returning functions:\n\nredisClient.hexistsAsync(\"myhash\", \"field\").then(function(v) {\n\n}).catch(function(e) {\n\n});\n</code></pre>\n<h3><a id=\"_32\"></a>Promise.fromNode(Function resolver)</h3>\n<p>通过使用一个节点风格的回调函数，创建一个resolved的promise。这适合那些不公开类的动态库来实现Promise化，这些不公开类的动态库不能自动使用promisifyAll来实现Promise化。</p>\n<pre><code>// TODO use real library that doesn\'t expose prototypes for promisification\nvar object = crummyLibrary.create();\nPromise.fromNode(function(callback) {\n    object.foo(\"firstArgument\", callback);\n}).then(function(result) {\n    console.log(result);\n})\n</code></pre>\n<h2><a id=\"_33\"></a>四. 计时器</h2>\n<h3><a id=\"_34\"></a>.delay(int ms)</h3>\n<p>延时执行。</p>\n<h3><a id=\"_35\"></a>.timeout(int ms [, String message])</h3>\n<p>返回一个在指定时间ms后变为失败状态的promise。</p>\n<h2><a id=\"_36\"></a>五. 同步检查</h2>\n<h3><a id=\"_37\"></a>.isFullfilled()</h3>\n<p>检查promise是否执行成功。</p>\n<h3><a id=\"_38\"></a>.isRejected()</h3>\n<p>检查promise是否执行失败。</p>\n<h3><a id=\"_39\"></a>.isPending()</h3>\n<p>检查promise是否在处理中。</p>\n<h3><a id=\"_40\"></a>.isCancelled()</h3>\n<p>检查promise是否已取消。</p>\n<h3><a id=\"_41\"></a>.value()</h3>\n<p>返回promise的执行结果。</p>\n<h3><a id=\"_42\"></a>.reason()</h3>\n<p>返回promise的执行失败的原因。</p>\n<h2><a id=\"_43\"></a>六. 参考</h2>\n<p>Bluebird API：<a href=\"http://bluebirdjs.com/docs/api-reference.html\">http://bluebirdjs.com/docs/api-reference.html</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/1278\">http://www.dengzhr.com/node-js/1278</a></div>\n\n        ','2','1'),(239,'CommonJS学习笔记','\n\n            <h2>符合CommonJS规范的包应该具备以下特征：</h2>\n<ul>\n<li>package.json必须在包的顶层目录下；</li>\n<li>二进制文件应该在bin目录下；</li>\n<li>JavaScript代码应该在lib目录下；</li>\n<li>文档应该在doc目录下；</li>\n<li>单元测试应该在test目录下；</li>\n</ul>\n<h2>package.json文件</h2>\n<p>Node.js在调用某个包时，会首先检查包中的package.json文件中的main字段，将其作为包的接…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>符合CommonJS规范的包应该具备以下特征：</h2>\n<ul>\n<li>package.json必须在包的顶层目录下；</li>\n<li>二进制文件应该在bin目录下；</li>\n<li>JavaScript代码应该在lib目录下；</li>\n<li>文档应该在doc目录下；</li>\n<li>单元测试应该在test目录下；</li>\n</ul>\n<h2><a id=\"_5\"></a>package.json文件</h2>\n<p>Node.js在调用某个包时，会首先检查包中的package.json文件中的main字段，将其作为包的接口模块。如果package.json或main字段不存在，会尝试寻找index.js或index.node作为包的接口。</p>\n<p>package.json文件应该含有以下字段：</p>\n<ul>\n<li>name：包的名称，必须是唯一的；</li>\n<li>description：包的简要说明；</li>\n<li>version：符合语义化版本识别规范的版本字符串；</li>\n<li>keywords：关键字数组，用于搜索；</li>\n<li>maintainers：维护者数组，每个元素要包含name、email（可选）、web（可选）字段；</li>\n<li>contributors：贡献者数组，格式与maintainers相同。包的作者应该是贡献者数组的第一个元素；</li>\n<li>bugs：提交bugs的地址，可以是网址或者电子邮件地址；</li>\n<li>licenses：许可证数组，每个元素要包含type（许可证的名称）和url（链接到许可证文本的地址）字段；</li>\n<li>repositories：仓库托管地址数组，每个元素要包含type（仓库的类型，如git）、url（仓库的地址）和path（相对于仓库的路径，可选）字段；</li>\n<li>dependencies：包的依赖，一个关联数组，由包名称和版本号组成；</li>\n</ul>\n<p>未完待续。。。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/835\">http://www.dengzhr.com/node-js/835</a></div>\n\n        ','2','1'),(240,'【译】node-mysql官方文档（未完结）','\n\n            <p>原文地址：<a href=\"https://github.com/mysqljs/mysql\">https://github.com/mysqljs/mysql</a></p>\n<h2>安装</h2>\n<pre><code class=\"lang-sh\">$ npm install mysql\n</code></pre>\n<p>有关前述0.9.x版本的版本信息，请访问<a href=\"https://github.com/mysqljs/mysql/tree/v0.9\">V0.9分支</a>。</p>\n<p>当有bug修正时，建议从Github上拉取最新版本代码，可执行如下命令：</p>\n<pre><code class=\"lang-sh\">$ npm install mysqljs/mysql\n</code></pre>\n<h2>介绍</h2>\n<p>这是MySQL的一个node.js驱动程序，用JavaScript编写，不需要编译，并且100%遵循MIT协议。…</p>\n        ','2019-07-10 09:08:45','0000-00-00 00:00:00',1,'1','\n\n            <p>原文地址：<a href=\"https://github.com/mysqljs/mysql\">https://github.com/mysqljs/mysql</a></p>\n<h2><a id=\"_4\"></a>安装</h2>\n<pre><code class=\"lang-sh\">$ npm install mysql\n</code></pre>\n<p>有关前述0.9.x版本的版本信息，请访问<a href=\"https://github.com/mysqljs/mysql/tree/v0.9\">V0.9分支</a>。</p>\n<p>当有bug修正时，建议从Github上拉取最新版本代码，可执行如下命令：</p>\n<pre><code class=\"lang-sh\">$ npm install mysqljs/mysql\n</code></pre>\n<h2><a id=\"_5\"></a>介绍</h2>\n<p>这是MySQL的一个node.js驱动程序，用JavaScript编写，不需要编译，并且100%遵循MIT协议。</p>\n<p>下面是一个如何使用本程序的示例：</p>\n<pre><code class=\"lang-js\">var mysql      = require(\'mysql\');\nvar connection = mysql.createConnection({\n  host     : \'localhost\',\n  user     : \'me\',\n  password : \'secret\',\n  database : \'my_db\'\n});\n\nconnection.connect();\n\nconnection.query(\'SELECT 1 + 1 AS solution\', function(err, rows, fields) {\n  if (err) throw err;\n\n  console.log(\'The solution is: \', rows[0].solution);\n});\n\nconnection.end();\n</code></pre>\n<p>从这个例子里，可以了解到：</p>\n<ul>\n<li>在connection上调用的每个方法都会加入队列，并按顺序执行；</li>\n<li>关闭connection可使用<code>end()</code>方法。它可以确保在发送数据包到mysql服务器之前将剩下的所有查询执行完成。</li>\n</ul>\n<h2><a id=\"_6\"></a>建立连接</h2>\n<p>推荐使用如下方法建立连接：</p>\n<pre><code class=\"lang-js\">var mysql      = require(\'mysql\');\nvar connection = mysql.createConnection({\n  host     : \'example.org\',\n  user     : \'bob\',\n  password : \'secret\'\n});\n\nconnection.connect(function(err) {\n  if (err) {\n    console.error(\'error connecting: \' + err.stack);\n    return;\n  }\n\n  console.log(\'connected as id \' + connection.threadId);\n});\n</code></pre>\n<p>还可以通过调用查询，来隐式建立连接：</p>\n<pre><code class=\"lang-js\">var mysql      = require(\'mysql\');\nvar connection = mysql.createConnection(...);\n\nconnection.query(\'SELECT 1\', function(err, rows) {\n  // connected! (unless `err` is set)\n});\n</code></pre>\n<p>可以根据你处理错误的习惯，来选择更合适的方法。任何类型的连接错误（握手或网络）都是致命的错误。</p>\n<h2><a id=\"_7\"></a>connection选项</h2>\n<p>建立连接时，可以设置以下选项：</p>\n<ul>\n<li><code>host</code>: 要连接的数据库的主机名。（默认： <code>localhost</code>）；</li>\n<li><code>port</code>: 连接的端口号。 （默认：<code>3306</code>）；</li>\n<li><code>localAddress</code>: TCP连接的IP地址。（可选的）；</li>\n<li><code>socketPath</code>: 连接到 Unix域套接字的路径。当使用时<code>host</code>和<code>port</code>被忽略；</li>\n<li><code>user</code>：作为身份验证的MySQL的用户名；</li>\n<li><code>password</code>：MySQL用户的密码；</li>\n<li><code>database</code>: 用于练级的数据库名称（可选）；</li>\n<li><code>charset</code>：用于连接的字符集。这就是在MySQL中所谓的“collation”级的字符集（如<code>utf8_general_ci</code>）。如果指定了一个SQL级字符集（如<code>utf8mb4</code>），则使用该字符集的默认collation值。（默认：”UTF8_GENERAL_CI’`）；</li>\n<li><code>timezone</code>：用来存放本地日期的时区。（默认：”local’`）；</li>\n<li><code>connectTimeout</code>：MySQL服务器连接超时时间，单位为毫秒。 （默认：<code>10000</code>）；</li>\n<li><code>stringifyObjects</code>：字符串化对象，而不是转化为字面量。可查看issues[#501]（https://github.com/mysqljs/mysql/issues/501）。 （默认：<code>false</code>）；</li>\n<li><code>insecureAuth</code>：允许连接到使用（不安全的）旧版本的身份验证方法的MySQL实例 。（默认：<code>false</code>）；</li>\n<li><code>typeCast</code>：column值是否应转换为本地JavaScript类型。 （默认：true）；</li>\n<li><code>queryFormat</code>：自定义查询格式功能；</li>\n<li><code>supportBigNumbers</code>：当对数据库中的大数字（<code>BIGINT</code> 和 <code>DECIMAL columns</code>）进行处理时，应启用该选项（默认：<code>false</code>）；</li>\n<li><code>bigNumberStrings</code>：可同时将<code>supportBigNumbers</code>和<code>bigNumberStrings</code>转换成大数字。 （<code>BIGINT</code>和<code>DECIMAL columns</code>）总是返回的JavaScript字符串对象（默认：<code>false</code>）。 启用<code>supportBigNumbers</code>且禁止<code>bigNumberStrings</code>，只有在不能精确地表示<a href=\"http://ecma262-5.com/ELS5_HTML.htm#Section_8.5\">JavaScript Number对象</a>（当他们超出[-2^53, 2^53]范围）时，返回大数字为String对象，否则返回Number对象。如果<code>supportBigNumbers</code>已禁用，该选项被忽略。</li>\n<li><code>dateStrings</code>：强制日期类型（TIMESTAMP，DATETIME，DATE）转换为字符串，而不是JavaScript Date对象。（默认：<code>false</code>）；</li>\n<li><code>debug</code>：打印协议细节到stdout。 （默认：<code>false</code>）</li>\n<li><code>trace</code>：生成包含函数库调用位置的<code>Error</code> 的堆栈跟踪（“长堆栈跟踪”）。大多数情况下会有轻微的性能损失。（默认：true）；</li>\n<li><code>multipleStatements</code>：允许一个查询中含有多个MySQL语句。但须谨慎使用，因为它会增加SQL注入攻击的范围。 （默认：<code>false</code>）；</li>\n<li><code>flags</code>：使用的连接标记的列表，而不是默认值。它也可以将默认值列入黑名单；</li>\n<li><code>ssl</code>：含有ssl参数中的对象，或ssl配置文件名称的字符串。</li>\n</ul>\n<p>除了将这些选项作为对象传入，你也可以使用一个url字符串。例如：</p>\n<pre><code class=\"lang-js\">var connection = mysql.createConnection(\'mysql://user:pass@host/db?debug=true&charset=BIG5_CHINESE_CI&timezone=-0700\');\n</code></pre>\n<p>注意：查询值会首先尝试解析为JSON，如果失败，则将其假定为明文字符串。</p>\n<h3><a id=\"_8\"></a>SSL 选项</h3>\n<p>在连接选项中，<code>ssl</code>选项是一个字符串或对象。当给定一个字符串，他会使用其中一个引入的预定义SSL配置文件。</p>\n<p>引入的配置文件如下：</p>\n<ul>\n<li><code>\"Amazon RDS\"</code> ：该配置文件用于连接到亚马逊RDS服务器，并包含 https://rds.amazonaws.com/doc/rds-ssl-ca-cert.pem和 https://s3.amazonaws.com/rds-downloads/rds-combined-ca-bundle.pem的证书。</li>\n</ul>\n<p>当连接到其他服务器时，您需要提供一个options对象。该options对象的格式与<a href=\"http://nodejs.org/api/crypto.html#crypto_crypto_createcredentials_details\">crypto.createCredentials</a>相同。</p>\n<p>请注意，参数为证书字符串，而不是文件名的 证书。下面是一个简单的例子：</p>\n<pre><code class=\"lang-js\">var connection = mysql.createConnection({\n  host : \'localhost\',\n  ssl  : {\n    ca : fs.readFileSync(__dirname + \'/mysql-ca.crt\')\n  }\n});\n</code></pre>\n<p>您还可以连接到一个没有提供适当的 CA信任的MySQL服务器。 <em>建议这么做</em>。</p>\n<pre><code class=\"lang-js\">var connection = mysql.createConnection({\n  host : \'localhost\',\n  ssl  : {\n    // DO NOT DO THIS\n    // set up your ca correctly to trust the connection\n    rejectUnauthorized: false\n  }\n});\n</code></pre>\n<h2><a id=\"_9\"></a>终止连接</h2>\n<p>有两种方法终止连接。</p>\n<p>终止连接是可以调用<code>end()</code> 方法来实现：</p>\n<pre><code class=\"lang-js\">connection.end(function(err) {\n  // The connection is terminated now\n});\n</code></pre>\n<p>这将确保所有队列中的查询在发送 <code>COM_QUIT</code>包到MySQL服务器之前执行。如果在<code>COM_QUIT</code>包发送前出现致命错误，<code>err</code>参数将被传到回调函数中，连接将终止。</p>\n<p>断开连接的另一种方法，是调用<code>destroy()</code>方法。 这会导致潜在的基础socket立即终止。</p>\n<p>另外<code>destroy()</code>保证没有更多的事件或回调函数来 触发连接。</p>\n<pre><code class=\"lang-js\">connection.destroy();\n</code></pre>\n<p>与<code>end()</code>不同的是，<code>destroy()</code>不需要传入一个回调参数。</p>\n<h2><a id=\"_10\"></a>池连接</h2>\n<p>直接使用连接池。</p>\n<pre><code class=\"lang-js\">var mysql = require(\'mysql\');\nvar pool  = mysql.createPool({\n  connectionLimit : 10,\n  host            : \'example.org\',\n  user            : \'bob\',\n  password        : \'secret\',\n  database        : \'my_db\'\n});\n\npool.query(\'SELECT 1 + 1 AS solution\', function(err, rows, fields) {\n  if (err) throw err;\n\n  console.log(\'The solution is: \', rows[0].solution);\n});\n</code></pre>\n<p>连接可以汇聚到连接池中，以缓解共享一个连接，或管理 多个连接。</p>\n<pre><code class=\"lang-js\">var mysql = require(\'mysql\');\nvar pool  = mysql.createPool({\n  host     : \'example.org\',\n  user     : \'bob\',\n  password : \'secret\',\n  database : \'my_db\'\n});\n\npool.getConnection(function(err, connection) {\n  // connected! (unless `err` is set)\n});\n</code></pre>\n<p>当完成一个连接时，只需要调用<code>connection.release()</code>， 连接将返回到连接池中，准备要由别人再次使用。</p>\n<pre><code class=\"lang-js\">var mysql = require(\'mysql\');\nvar pool  = mysql.createPool(...);\n\npool.getConnection(function(err, connection) {\n  // Use the connection\n  connection.query( \'SELECT something FROM sometable\', function(err, rows) {\n    // And done with the connection.\n    connection.release();\n\n    // Don\'t use the connection here, it has been returned to the pool.\n  });\n});\n</code></pre>\n<p>如果想关闭连接，并从连接池中移除它，可使用 <code>connection.destroy()</code>来代替。连接池将在下一次调用时创建一个新的连接。</p>\n<p>连接在连接池中是懒连接的。如果配置池允许 多达100个连接，但只同时使用5个，那么只有5个连接 将被创建。连接使用循环模式，从连接池的顶部开始调用，并返回到底部。</p>\n<p>当先前的连接从池中移出时，ping数据包被发送 到服务器，检查连接是否仍然良好。</p>\n<h2><a id=\"_11\"></a>连接池选项</h2>\n<p>连接池接受所有与connection相同的<a href=\"#connection-options\">options参数</a>。 当创建一个新连接时，options参数将被简单地传递给connection构造函数。除了这些options参数，连接池还接受一些额外的参数：</p>\n<ul>\n<li><code>acquireTimeout</code>： 连接超时的时间，单位为毫秒。这与<code>connectTimeout</code>略有不同，因为回收连接不总是涉及建立连接。（默认：<code>10000</code>）；</li>\n<li><code>waitForConnections</code>： 确定连接池的操作时，是否没有可用的连接并且已达到限制。如果是<code>true</code>，连接池将请求加入队列，并当其可用时进行调用调用。如果是<code>false</code>，连接池将立即返回一个错误。（默认：true）；</li>\n<li><code>connectionLimit</code>： 一次性创建的最大连接数。（默认：<code>10</code>）；</li>\n<li><code>queueLimit</code>： 从<code>getConnection</code>返回一个错误之前，连接池中加入队列的最大连接请求数。如果设置为<code>0</code>，则不限制队列中的连接请求数目。（默认：<code>0</code>）；</li>\n</ul>\n<h2><a id=\"_12\"></a>连接池 事件</h2>\n<p>… … 未完待续 … …</p>\n<hr>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/908\">http://www.dengzhr.com/node-js/908</a></div>\n\n        ','2','1'),(241,'Node.js学习笔记：文件的常规操作','\n\n            <p>Node.js的文件操作部分的官方API文档如下：<br>\n<a href=\"https://nodejs.org/api/fs.html\">https://nodejs.org/api/fs.html</a></p>\n<p>fs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等POSIX文件系统操作。与其他模块不同的是，fs模块中所有的操作都提供了异步和同步的两个版本，例如读取文件内容的函数有异步的fs.readFile()和同步的fs.readFileSync()。</p>\n<p>进行文件操作前，都�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>Node.js的文件操作部分的官方API文档如下：<br>\n<a href=\"https://nodejs.org/api/fs.html\">https://nodejs.org/api/fs.html</a></p>\n<p>fs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等POSIX文件系统操作。与其他模块不同的是，fs模块中所有的操作都提供了异步和同步的两个版本，例如读取文件内容的函数有异步的fs.readFile()和同步的fs.readFileSync()。</p>\n<p>进行文件操作前，都要导入文件系统模块（fs），语法如下：</p>\n<pre><code>var fs = require(\"fs\");\n</code></pre>\n<h2><a id=\"_4\"></a>一. 目录操作</h2>\n<h3><a id=\"_5\"></a>1. 创建目录</h3>\n<p>创建目录的语法如下：</p>\n<pre><code>fs.mkdir(path[, mode], callback) // 异步方法\nfs.mkdirSync(path[, mode])  // 同步方法\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\"fs\");\n\n// 在该文件的同一目录下建立test目录\nfs.mkdir(\'test\',function(err){\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"目录创建成功。\");\n});\n</code></pre>\n<h3><a id=\"_6\"></a>2. 读取目录</h3>\n<p>读取目录的语法如下：</p>\n<pre><code>fs.readdir(path, callback)\nfs.readdirSync(path)\n</code></pre>\n<blockquote>\n<ul>\n<li>path： 文件路径；</li>\n<li>callback： 回调函数，回调函数带有两个参数err, files。err为错误信息，files为目录下的文件数组列表。</li>\n</ul>\n</blockquote>\n<p>示例：</p>\n<pre><code>var fs = require(\"fs\");\n\nfs.readdir(\"test/\",function(err, files){\n   if (err) {\n       return console.log(err);\n   }\n   files.forEach( function (file){\n       console.log( file );\n   });\n});\n</code></pre>\n<h3><a id=\"_7\"></a>3. 删除目录</h3>\n<p>删除目录的语法如下：</p>\n<pre><code>fs.rmdir(path, callback)\nfs.rmdirSync(path)\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\"fs\");\n\nfs.rmdir(\"test/ewe\",function(err){\n   if (err) {\n       return console.log(err);\n   }\n\n   fs.readdir(\"/test/\",function(err, files){\n      if (err) {\n          return console.error(err);\n      }\n      files.forEach( function (file){\n          console.log( file );\n      });\n   });\n});\n</code></pre>\n<h2><a id=\"_8\"></a>二. 文件操作</h2>\n<h3><a id=\"_9\"></a>1. 打开文件</h3>\n<p>打开文件的语法如下：</p>\n<pre><code>fs.open(path, flags, [mode], [callback(err, fd)])\n</code></pre>\n<p>其中，path为文件的路径，flags指文件的读取方式，mode参数用于创建文件时给文件指定权限，默认是0666.回掉函数将会传递一个文件描述符fd。</p>\n<p>flags的常用参数值如下：</p>\n<table>\n<thead>\n<tr>\n<th>flags取值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>r</td>\n<td>以读取模式打开文件。</td>\n</tr>\n<tr>\n<td>r+</td>\n<td>以读写模式打开文件。</td>\n</tr>\n<tr>\n<td>w</td>\n<td>以写入模式打开文件，如果文件不存在则创建。</td>\n</tr>\n<tr>\n<td>w+</td>\n<td>以读写模式打开文件，如果文件不存在则创建。</td>\n</tr>\n<tr>\n<td>a</td>\n<td>以追加模式打开文件，如果文件不存在则创建。</td>\n</tr>\n<tr>\n<td>a+</td>\n<td>以读取追加模式打开文件，如果文件不存在则创建。</td>\n</tr>\n</tbody>\n</table>\n<p>mode参数表示的文件权限是POSIX操作系统中对文件读取和访问权限的规范，通常用一个八进制数来表示。例如0754表示文件所有者的权限是7（读、写、执行），同组的用户权限是5（读、执行），其他用户的权限是4（读）。</p>\n<p>示例：</p>\n<pre><code>var fs = require(\'fs\');\n\nfs.open(\"test.txt\",\"w\",0644,function(e,fd){\n    try{\n        fs.write(fd,\"first fs!\",0,\'utf8\',function(e){\n            fs.closeSync(fd);\n        })\n    } catch(E) {\n        throw e;\n    }\n\n});\n</code></pre>\n<h3><a id=\"_10\"></a>2. 写入文件</h3>\n<p>写入文件的语法如下：</p>\n<pre><code>fs.writeFile(file, data[, options], callback)\nfs.writeFileSync(file, data[, options])\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\"fs\");\n\nfs.writeFile(\'test.txt\', \'hello world!\',  function(err) {\n   if (err) {\n       return console.log(err);\n   }\n\n   fs.readFile(\'test.txt\', function (err, data) {\n      if (err) {\n         return console.log(err);\n      }\n      console.log(\"异步读取文件数据: \" + data.toString());\n   });\n});\n</code></pre>\n<h3><a id=\"_11\"></a>3. 读取文件</h3>\n<p>读取文件的语法如下：</p>\n<pre><code>fs.read(fd, buffer, offset, length, position, callback)\nfs.readSync(fd, buffer, offset, length, position)\n\nfs.readFile(file[, options], callback)\nfs.readFileSync(file[, options])\n</code></pre>\n<p>其中，fs.read()和fs.readSync()的参数如下：</p>\n<blockquote>\n<ul>\n<li>fd – 通过 fs.open() 方法返回的文件描述符；</li>\n<li>buffer – 数据写入的缓冲区；</li>\n<li>offset – 缓冲区写入的写入偏移量；</li>\n<li>length – 要从文件中读取的字节数；</li>\n<li>position – 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取；</li>\n<li>callback – 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象；</li>\n</ul>\n</blockquote>\n<p>fs.read()的示例如下：</p>\n<pre><code>var fs = require(\'fs\');  \nfs.open(\'test.txt\', \'r\', function(err, fd) {  \nif (err) {  \nconsole.error(err);  \nreturn;  \n}  \nvar buf = new Buffer(8);  \nfs.read(fd, buf, 0, 8, null, function(err, bytesRead, buffer) {  \nif (err) {  \nconsole.error(err);  \nreturn;  \n}  \nconsole.log(\'bytesRead: \' + bytesRead);  \nconsole.log(buffer);  \n})  \n});\n</code></pre>\n<p>fs.readFile()的示例如下：</p>\n<pre><code>var fs = require(\'fs\');  \nfs.readFile(\'test.txt\', function(err, data) {  \n    if (err) {  \n        console.log(err);  \n    } else {  \n        console.log(data.toString());  \n    }  \n});\n</code></pre>\n<h3><a id=\"_12\"></a>4. 关闭文件</h3>\n<p>关闭文件的语法如下：</p>\n<pre><code>fs.close(fd, callback)\nfs.closeSync(fd)\n</code></pre>\n<h3><a id=\"_13\"></a>5. 删除文件</h3>\n<p>删除文件的语法如下：</p>\n<pre><code>fs.unlink(path, callback)\nfs.unlinkSync(path)\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\"fs\");\n\nfs.unlink(\'test.txt\', function(err) {\n   if (err) {\n       return console.log(err);\n   }\n   console.log(\"文件删除成功！\");\n});\n</code></pre>\n<h3><a id=\"_14\"></a>6. 确定文件是否存在</h3>\n<p>确定文件是否存在的语法如下：</p>\n<pre><code>fs.exists(path, callback)\nfs.existsSync(path)\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\'fs\');\n\nfs.exists(\'test.txt\', function (exists) {\n    if(exists) {\n        console.log(\"文件存在！\");\n    }else {\n        console.log(\"文件不存在！\");\n    }\n});\n</code></pre>\n<h3><a id=\"_15\"></a>7. 追加内容至文件</h3>\n<pre><code>fs.appendFile(file, data[, options], callback)\nfs.appendFileSync(file, data[, options])\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\'fs\');\n\nfs.appendFile(\"test.txt\", \"append content\", function (err) {\n    if (err) {\n        console.log(err);\n    }else {\n        fs.readFile(\'test.txt\', function(err, data) {  \n            if (err) {  \n                console.log(err);  \n            } else {  \n                console.log(data.toString());  \n            }  \n        }); \n    }\n});\n</code></pre>\n<p>更多的文件系统操作可查看Node.js的fs模块的官方API文档：<a href=\"https://nodejs.org/api/fs.html\">https://nodejs.org/api/fs.html</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/636\">http://www.dengzhr.com/node-js/636</a></div>\n\n        ','2','1'),(242,'Node.js学习笔记：Buffer模块处理','\n\n            <h1>Node.js学习笔记：Buffer模块处理</h1>\n<p>标签（空格分隔）： node.js</p>\n<hr>\n<p><a href=\"https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html\">Buffer的官方API文档</a></p>\n<p>Buffer像一个Array对象，主要用于操作字节。它是一个典型的JavaScript与C++结合的模块，将性能相关部分用C++实现，非性能相关的部分用JavaScript实现。</p>\n<p>Buffer所占用的内存不是通过V8分配的，是在Node的C++层面实现内存的申请，属于堆外存。</p>\n<p>Node在进程启动时就已经加载了Buffer，并将其放在全局�…</p>\n        ','2019-08-05 07:27:23','0000-00-00 00:00:00',1,'1','\n\n            <h1><a id=\"_4\"></a>Node.js学习笔记：Buffer模块处理</h1>\n<p>标签（空格分隔）： node.js</p>\n<hr>\n<p><a href=\"https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html\">Buffer的官方API文档</a></p>\n<p>Buffer像一个Array对象，主要用于操作字节。它是一个典型的JavaScript与C++结合的模块，将性能相关部分用C++实现，非性能相关的部分用JavaScript实现。</p>\n<p>Buffer所占用的内存不是通过V8分配的，是在Node的C++层面实现内存的申请，属于堆外存。</p>\n<p>Node在进程启动时就已经加载了Buffer，并将其放在全局对象global上。所以使用Buffer时，无需通过require()即可直接使用。</p>\n<h2><a id=\"_5\"></a>指定Buffer大小：</h2>\n<pre><code>new Buffer(size)\n</code></pre>\n<h2><a id=\"_6\"></a>获取Buffer长度</h2>\n<pre><code>buf.length\n</code></pre>\n<h2><a id=\"_7\"></a>获取Buffer对象的字节长度</h2>\n<pre><code>Buffer.byteLength(string [, encoding])\n</code></pre>\n<h2><a id=\"_8\"></a>Buffer的转换</h2>\n<p>Buffer对象可以与字符串之间相互转换。目前支持的字符串编码类型有如下几种：</p>\n<blockquote>\n<ul>\n<li>ASCII</li>\n<li>UTF-8</li>\n<li>UTF-16LE/UCS-2</li>\n<li>Base64</li>\n<li>Binary</li>\n<li>Hex</li>\n</ul>\n</blockquote>\n<h3><a id=\"_9\"></a>字符串转Buffer</h3>\n<pre><code>new Buffer(str, [encoding]);\n</code></pre>\n<p>encoding默认值为UTF-8。</p>\n<p>一个Buffer对象可以存储不同编码类型的字符串转码的值，调用write()方法即可实现该目的：</p>\n<pre><code>buf.write(string, [offset], [length], [encoding]);\n</code></pre>\n<blockquote>\n<ul>\n<li>offset: 默认为0；</li>\n<li>length: 默认为buffer.length – offset；</li>\n<li>encoding: 默认为”utf-8″</li>\n</ul>\n</blockquote>\n<h3><a id=\"_10\"></a>Buffer转字符串</h3>\n<pre><code>buf.toString([encoding], [start], [end])\n</code></pre>\n<p>在Node.js中，还可以使用StringDecoder对象将Buffer对象中的数据转换为字符串，该对象的作用与Buffer对象的toString方法的作用相同，但是对于utf8编码格式的字符串提供更好的支持。</p>\n<h2><a id=\"_11\"></a>判断编码类型是否支持转换成Buffer</h2>\n<pre><code>Buffer.isEncoding(encoding)\n</code></pre>\n<p>如果支持转换返回值为true，否则为false。</p>\n<p>Buffer不支持GBK、GB2312和BIG-5编码。可以使用iconv和iconv-lite两个模块支持更多的编码类型转换。</p>\n<h2><a id=\"_12\"></a>Buffer的拼接</h2>\n<pre><code>Buffer.concat(list [ totalLength])\n</code></pre>\n<h2><a id=\"_13\"></a>判断Buffer对象</h2>\n<pre><code>Buffer.isBuffer(obj)\n</code></pre>\n<h2><a id=\"_14\"></a>Buffer对象的裁剪</h2>\n<pre><code>buf.slice([start], [end])\n</code></pre>\n<h2><a id=\"_15\"></a>Buffer对象的拷贝</h2>\n<pre><code>buf.copy(targetBuffer [, targetStart] [, sourceStart] [, sourceEnd])\n</code></pre>\n<h2><a id=\"_16\"></a>推荐：</h2>\n<p><a href=\"http://javascript.ruanyifeng.com/nodejs/buffer.html\">JavaScript标准参考教程：Buffer对象： http://javascript.ruanyifeng.com/nodejs/buffer.html</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/827\">http://www.dengzhr.com/node-js/827</a></div>\n\n        ','2','1'),(243,'Node.js学习笔记：获取文件信息','\n\n            <h2>一. 查看文件信息的方法：</h2>\n<h3>fs.stat() && fs.lstat()</h3>\n<p>在fs模块中，可以使用<strong>fs.stat()</strong>方法或<strong>fs.lstat()</strong>方法查看一个文件或目录的信息，如文件的大小、创建时间、权限等信息。这两个方法的唯一区别是当查看符号链接文件的信息时，必须使用<strong>fs.lstat()</strong>方法。这两个方法的使用方式如下：</p>\n<pre><code>fs.stat(path, callback)\nfs.lstat(path, callback)</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 查看文件信息的方法：</h2>\n<h3><a id=\"_5\"></a>fs.stat() && fs.lstat()</h3>\n<p>在fs模块中，可以使用<strong>fs.stat()</strong>方法或<strong>fs.lstat()</strong>方法查看一个文件或目录的信息，如文件的大小、创建时间、权限等信息。这两个方法的唯一区别是当查看符号链接文件的信息时，必须使用<strong>fs.lstat()</strong>方法。这两个方法的使用方式如下：</p>\n<pre><code>fs.stat(path, callback)\nfs.lstat(path, callback)\n</code></pre>\n<p>这两个方法分别有对应的同步方式方法：</p>\n<pre><code>fs.statSync(path)\nfs.lstatSync(path)\n</code></pre>\n<p>参数说明：</p>\n<ul>\n<li><strong>path</strong>： 被查看的文件或目录的完整路径；</li>\n<li><strong>callback</strong>：查看文件或目录信息操作完毕后执行的回调函数，如<code>function(err, stats) { // 回调函数... }</code>。在该回调函数中使用两个参数，其中err参数为操作失败时返回的错误对象，stats参数值为一个<strong>fs.Stats</strong>对象。</li>\n</ul>\n<h2><a id=\"_6\"></a>fs.fstat()</h2>\n<p>在使用<strong>fs.open()</strong>或<strong>fs.openSync()</strong>方法打开的文件并返回文件描述符后，可以使用<strong>fs.fstat()</strong>方法查询被打开文件的文件信息，使用方式如下：</p>\n<pre><code>fs.fstat(fd, callback)\nfs.fstatSync(fd)\n</code></pre>\n<p>参数说明：</p>\n<ul>\n<li>fd： 打开文件时返回的文件描述符。</li>\n</ul>\n<h2><a id=\"_7\"></a>二. fs.Stats对象</h2>\n<h3><a id=\"_8\"></a>fs.Stats对象的方法如下：</h3>\n<p>（备注： 这些方法中均不使用任何参数）</p>\n<ul>\n<li><strong>stats.isFile()</strong>： 判断被查看对象是否是一个文件。如果是标准文件，返回true。是目录、套接字、符号连接、或设备等返回false。</li>\n<li><strong>stats. isDirectory()</strong>： 判断被查看对象是否是一个目录。如果是目录，返回true。</li>\n<li><strong>stats. isBlockDevice()</strong>： 判断被查看对象是否是一个块设备文件。 如果是块设备，返回true，大多数情况下类UNIX系统的块设备都位于/dev目录下。</li>\n<li><strong>stats. isCharacterDevice()</strong>： 判断被查看对象是否是一个字符设备文件。如果是字符设备，返回true。</li>\n<li><strong>stats. isSymbolicLink()</strong>： 判断被查看对象是否是一个符号链接文件。如果是符号连接，返回true。该方法仅在fs.lstat()方法的回调函数中有效。</li>\n<li><strong>stats.isFIFO()</strong>： 判断被查看对象是否是一个FIFO文件。如果是FIFO，返回true。FIFO是UNIX中的一种特殊类型的命令管道。该方法仅在LINUX系统下有效。</li>\n<li><strong>stats. isSocket()</strong>： 判断被查看对象是否是一个socket文件。 如果是UNIX套接字，返回true。该方法仅在LINUX系统下有效。</li>\n</ul>\n<h3><a id=\"_9\"></a>fs.Stats对象的属性如下：</h3>\n<ul>\n<li><strong>dev</strong>: 文件或目录所在的设备ID。该属性值在UNIX系统下有效；</li>\n<li><strong>mode</strong>: 文件或目录的权限标志，采用数值形式表示；</li>\n<li><strong>nlink</strong>: 文件或目录的的硬连接数量；</li>\n<li><strong>uid</strong>: 文件或目录的所有者的用户ID。该属性值在UNIX系统下有效；</li>\n<li><strong>gid</strong>: 文件或目录的所有者的用户组ID。该属性值在UNIX系统下有效；</li>\n<li><strong>rdev</strong>: 字符设备文件或块设备文件所在设备ID。该属性值在UNIX系统下有效；**</li>\n<li><strong>ino</strong>: 文件或目录的索引编号。该属性值仅在UNIX系统下有效；</li>\n<li><strong>size</strong>: 文件的字节数；</li>\n<li><strong>atime</strong>: 文件或目录的访问时间；</li>\n<li><strong>mtime</strong>: 文件或目录的最后修改时间；</li>\n<li><strong>ctime</strong>: 文件或目录状态的最后修改时间；</li>\n<li><strong>birthtime</strong>: 文件创建时间，文件创建时生成。在一些不提供文件 birthtime 的文件系统中，这个字段会使用 ctime 或 1970-01-01T00:00Z 来填充；</li>\n</ul>\n<h2><a id=\"_10\"></a>三. 实例：</h2>\n<p>Node.js程序：</p>\n<pre><code>var fs = require(\'fs\');\n\nfs.stat(\'1.js\', function (err, stats) {\n    console.log(\"fs.Stats对象属性：\\n\");\n    console.log(stats);\n    console.log(\"fs.Stats对象方法：\\n\");\n\n    console.log(\"isFile: \" + stats.isFile());\n    console.log(\"isDirectory: \" + stats.isDirectory());\n    console.log(\"isBlockDevice: \" + stats.isBlockDevice());\n    console.log(\"isCharacterDevice: \" + stats.isCharacterDevice());\n    console.log(\"isFIFO: \" + stats.isFIFO());\n    console.log(\"isSocket: \" + stats.isSocket());\n});\n</code></pre>\n<p>console打印值：</p>\n<pre><code>fs.Stats对象属性：\n{ dev: -496596946,\n  mode: 33206,\n  nlink: 1,\n  uid: 0,\n  gid: 0,\n  rdev: 0,\n  blksize: undefined,\n  ino: 844424930205688,\n  size: 198,\n  blocks: undefined,\n  atime: 2016-07-14T10:08:48.737Z,\n  mtime: 2016-07-28T00:30:59.199Z,\n  ctime: 2016-07-28T00:30:59.199Z,\n  birthtime: 2016-07-14T10:08:48.612Z\n}\nfs.Stats对象方法：\nisFile: true\nisDirectory: false\nisBlockDevice: false\nisCharacterDevice: false\nisFIFO: false\nisSocket: false\n</code></pre>\n<h2><a id=\"_11\"></a>四. 参考：</h2>\n<p><a href=\"https://nodejs.org/dist/latest-v6.x/docs/api/fs.html\">Node.js的fs模块官方文档：https://nodejs.org/dist/latest-v6.x/docs/api/fs.html</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/841\">http://www.dengzhr.com/node-js/841</a></div>\n\n        ','2','1'),(244,'Node.js学习笔记：路径操作','\n\n            <p>Path模块的官方介绍在此：<a href=\"https://nodejs.org/dist/latest-v6.x/docs/api/path.html\">https://nodejs.org/dist/latest-v6.x/docs/api/path.html</a></p>\n<h2>path.normalize(path)</h2>\n<pre><code>path.normalize(path)\n</code></pre>\n<p>参数值为需要被转换的路径字符串。</p>\n<p>该方法将非标准路径字符串转换为标准路径字符串，在转换过程中执行以下处理：</p>\n<p>1) 解析路径字符串中的”..”字符串与R…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>Path模块的官方介绍在此：<a href=\"https://nodejs.org/dist/latest-v6.x/docs/api/path.html\">https://nodejs.org/dist/latest-v6.x/docs/api/path.html</a></p>\n<h2><a id=\"_4\"></a>path.normalize(path)</h2>\n<pre><code>path.normalize(path)\n</code></pre>\n<p>参数值为需要被转换的路径字符串。</p>\n<p>该方法将非标准路径字符串转换为标准路径字符串，在转换过程中执行以下处理：</p>\n<p>1) 解析路径字符串中的”..”字符串与”.”字符串，返回解析后的标准路径；</p>\n<p>2) 将多个斜杠字符串转换为一个斜杠字符串，例如将”\\\\”转换为”\\”；</p>\n<p>3) 将Windows操作系统中的反斜杠字符串转换为正斜杠字符串；</p>\n<p>4) 如果路径字符串以斜杠字符串结尾，则在转换后的完整路径字符串末尾保留该斜杠字符串。</p>\n<p>例如：</p>\n<pre><code>console.log(path.normalize(\".//a//b//d//..//c/e//..//\"));\n// a\\b\\c\n</code></pre>\n<h2><a id=\"_5\"></a>path.join()</h2>\n<pre><code>path.join([path1] [, path2] [...])\n</code></pre>\n<p>该方法将多个参数值字符串结合为一个路径字符串。</p>\n<p>例如：</p>\n<pre><code>console.log(path.join(\"a\", \"b\", \"c\", \"..\", \"d\"));\n// a\\b\\d\n</code></pre>\n<h2><a id=\"_6\"></a>path.resolve()</h2>\n<pre><code>path.resolve(path1, [, path2] [...])\n</code></pre>\n<p>该方法以应用程序根目录为起点，根据所有的参数值字符串解析出一个绝对路径。</p>\n<h2><a id=\"_7\"></a>path.relative()</h2>\n<pre><code>path.relative([from,] to)\n</code></pre>\n<p>用于获取两个路径之间的相对关系。如果在代码中降低一个路径视为当前路径，则使用相对路径来指定第二个路径时应该使用的表达式。</p>\n<p>在Windows操作系统中这两个路径应该位于同一个硬盘分区中，否则方法直接返回第二个参数值路径的绝对路径。</p>\n<p>例如：</p>\n<pre><code>path.relative(\'/data/orandea/test/aaa\', \'/data/orandea/impl/bbb\')\n// 返回\'../../impl/bbb\'\n</code></pre>\n<h2><a id=\"_8\"></a>path.dirname()</h2>\n<pre><code>path.dirname(path)\n</code></pre>\n<p>该方法用于获取一个路径中的目录名。当参数值为目录路径时，返回该目录的上层目录；当参数值为文件路径时，返回该文件所在目录。</p>\n<h2><a id=\"_9\"></a>path.basename()</h2>\n<pre><code>path.basename(path [, ext])\n</code></pre>\n<p>该方法用于获取一个路径中的文件名。</p>\n<p>例如：</p>\n<pre><code>path.basename(\'/foo/bar/baz/asdf/quux.html\', \'.html\') // 返回quux\npath.basename(\'/foo/bar/baz/asdf/quux.html\', \'html\') // 返回quux.\n</code></pre>\n<h2><a id=\"_10\"></a>path.extname()</h2>\n<pre><code>path.extname(path )\n</code></pre>\n<p>该方法用于获取一个路径中的扩展名。</p>\n<h2><a id=\"_11\"></a>path.isAbsolute()</h2>\n<pre><code>path.isAbsolute(path)\n</code></pre>\n<p>判定path是否为绝对路径。一个绝对路径总是指向一个相同的位置，无论当前工作目录是在哪里。</p>\n<p>例如：</p>\n<pre><code>path.isAbsolute(\'/foo/bar\') // true\npath.isAbsolute(\'/baz/..\')  // true\npath.isAbsolute(\'//server\')  // true\npath.isAbsolute(\'C:/foo/..\') // true\npath.isAbsolute(\'qux/\')     // false\npath.isAbsolute(\'.\')        // false\n</code></pre>\n<h2><a id=\"_12\"></a>path.sep属性</h2>\n<p>属性值为操作系统指定的文件分隔符，可能的属性值为”\\\\”（在Windows操作系统中）或”/”（在UNIX操作系统中）。</p>\n<p>*nix 上的例子:</p>\n<pre><code>\'foo/bar/baz\'.split(path.sep)\n// [\'foo\', \'bar\', \'baz\']\n</code></pre>\n<p>Windows 上的例子:</p>\n<pre><code>\'foo\\\\bar\\\\baz\'.split(path.sep)\n// [\'foo\', \'bar\', \'baz\']\n</code></pre>\n<h2><a id=\"_13\"></a>path.delimiter属性</h2>\n<p>属性值为操作系统指定的路径分隔符，可能的属性值为”;”（在Windows操作系统中）或”:”（在UNIX操作系统中）。</p>\n<p>*nix 上的例子:</p>\n<pre><code>process.env.PATH.split(path.delimiter)\n// [\'/usr/bin\', \'/bin\', \'/usr/sbin\', \'/sbin\', \'/usr/local/bin\']\n</code></pre>\n<p>Windows 上的例子:</p>\n<pre><code>console.log(process.env.PATH)\n// \'C:\\Windows\\system32;C:\\Windows;C:\\Program Files\\nodejs\\\'\n\nprocess.env.PATH.split(path.delimiter)\n// [\'C:\\Windows\\system32\', \'C:\\Windows\', \'C:\\Program Files\\nodejs\\\']\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/850\">http://www.dengzhr.com/node-js/850</a></div>\n\n        ','2','1'),(245,'在项目开发中优雅地使用ES6：Traceur & Babel','\n\n            <p>ES6于2015年6月正式发布，各大浏览器的最新版本对 ES6 的支持可以查看<a href=\"https://kangax.github.io/compat-table/es6/\">https://kangax.github.io/compat-table/es6/</a>。</p>\n<p>目前各大浏览器和开发环境对支持ES6的支持情况参差不齐，在实际项目开发中，我们仍旧不得不降级使用ES5语法以兼容各平台。幸好有几款工具可以将ES6语法转换成ES5，让我们在使用ES6新特性编写代码的同时，不需要考虑具体的兼容性情况。</p>\n<p>将ES6代码转换成ES5代…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>ES6于2015年6月正式发布，各大浏览器的最新版本对 ES6 的支持可以查看<a href=\"https://kangax.github.io/compat-table/es6/\">https://kangax.github.io/compat-table/es6/</a>。</p>\n<p>目前各大浏览器和开发环境对支持ES6的支持情况参差不齐，在实际项目开发中，我们仍旧不得不降级使用ES5语法以兼容各平台。幸好有几款工具可以将ES6语法转换成ES5，让我们在使用ES6新特性编写代码的同时，不需要考虑具体的兼容性情况。</p>\n<p>将ES6代码转换成ES5代码工具中最主流的有以下两个：</p>\n<p><strong><a href=\"https://github.com/google/traceur-compiler\">Traceur</a></strong>（Google研发）； <strong><a href=\"https://babeljs.io/\">Babel</a></strong>。</p>\n<p>下面介绍这两个工具的使用方法，以及Node.js中对ES6的支持情况。</p>\n<h2><a id=\"_4\"></a>一. Traceur转换器</h2>\n<h3><a id=\"_5\"></a>1）第一种方法：直接在页面中使用：</h3>\n<pre><code><!-- 加载Traceur编译器 -->\n<script src=\"http://google.github.io/traceur-compiler/bin/traceur.js\" type=\"text/javascript\"></script>\n<!-- 打开实验选项，否则有些特性可能编译不成功 -->\n<script>\n    traceur.options.experimental = true;\n</script>\n</code></pre>\n<p>写ES6代码，用：</p>\n<pre><code><script type=\"module\">\n    // ES6代码\n</script>\n</code></pre>\n<p>注意，script标签的type属性的值是module，而不是text/javascript。这是Traceur编译器识别ES6代码的标识。</p>\n<h3><a id=\"_6\"></a>2) 第二种方法：Traceur的在线编辑器：</h3>\n<p><a href=\"http://google.github.io/traceur-compiler/demo/repl.html\">http://google.github.io/traceur-compiler/demo/repl.html</a></p>\n<h3><a id=\"_7\"></a>3) 第三种方法：使用node.js工具：</h3>\n<p>安装：</p>\n<pre><code>$ npm install -g traceur\n</code></pre>\n<p>直接运行ES6代码：</p>\n<pre><code>$ traceur calc.js\n</code></pre>\n<p>将ES6输出为ES5脚本：</p>\n<pre><code>$ traceur --script calc.es6.js --out calc.es5.js\n</code></pre>\n<p>为了防止有些特性编译不成功，最好加上–experimental选项。</p>\n<pre><code>$ traceur --script calc.es6.js --out calc.es5.js --experimental\n</code></pre>\n<h2><a id=\"_8\"></a>二. Babel转换器</h2>\n<h3><a id=\"_9\"></a>1) 安装：</h3>\n<pre><code>$ npm install --global babel\n</code></pre>\n<h3><a id=\"_10\"></a>2) 直接运行ES6脚本：</h3>\n<pre><code>$ babel-node es6.js\n</code></pre>\n<h3><a id=\"_11\"></a>3) 将ES6编译成ES5：</h3>\n<pre><code>$ babel es6.js\n</code></pre>\n<p>-o 参数将转换后的代码，从标准输出导入文件：</p>\n<pre><code>$ babel es6.js -o es5.js\n</code></pre>\n<h2><a id=\"_12\"></a>三. Node.js支持ES6的情况：</h2>\n<p>Google公司的V8引擎已经部署了ES6的部分特性。使用Node.js 0.11版，就可以体验这些特性。在 Node.js 使用的 JS 引擎 V8 里面将不同状态 ES6 特性分成了 3 个等级：</p>\n<blockquote>\n<ul>\n<li>shipping （默认开启的特性）</li>\n<li>staged （需要使用 –harmony 参数开启的特性）</li>\n<li>in progress（不稳定或者未实现的特性， 不推荐使用）</li>\n</ul>\n</blockquote>\n<p>Node v4.4.4版本对ES6的支持情况如下：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/2fve2brfa33ayrw96dbnjhb0/image_1ap049cqqj0ualnucjun91rfu9.png\" alt=\"image_1ap049cqqj0ualnucjun91rfu9.png-43.8kB\"> 【备注：上图转自<a href=\"http://www.alloyteam.com/2016/07/nodejs-native-support-of-the-es6-features/\">http://www.alloyteam.com/2016/07/nodejs-native-support-of-the-es6-features/</a>】</p>\n<p>在Node v4和 v5版本，可能需要运行<code>node --harmony</code>命令来打开所有已经部署的ES6功能。部分特性需要在严格模式下使用，即在文件中使用<code>use strict</code>。</p>\n<p><strong>Node.js对ES6的具体支持情况可查看：</strong></p>\n<p><strong><a href=\"http://node.green/\">http://node.green/</a></strong></p>\n<h2><a id=\"_13\"></a>参考：</h2>\n<p><a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\">JavaScript ECMA-262 规范：http://www.ecma-international.org/publications/standards/Ecma-262.htm</a></p>\n<p><a href=\"https://nodejs.org/en/docs/es6/\">Node.js ES6 支持文档 https://nodejs.org/en/docs/es6/</a></p>\n<p><a href=\"https://kangax.github.io/compat-table/es6/\">ES6的各平台兼容性情况： https://kangax.github.io/compat-table/es6/</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/832\">http://www.dengzhr.com/node-js/832</a></div>\n\n        ','2','1'),(246,'[小笔记] Restify中接入Socket.io时报Error:Can’t set headers after sent.','\n\n            <p>在restify的官方文档中，接入socket.io的代码是酱汁的： <a href=\"http://restify.com/#socketio\">http://restify.com/#socketio</a></p>\n<pre><code>var server = restify.createServer();\nvar io = socketio.listen(server);\n\n// ...\n\nio.sockets.on(\'connection\', function (socket) {\n    socket.emit(\'news\', { hello: </code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在restify的官方文档中，接入socket.io的代码是酱汁的： <a href=\"http://restify.com/#socketio\">http://restify.com/#socketio</a></p>\n<pre><code>var server = restify.createServer();\nvar io = socketio.listen(server);\n\n// ...\n\nio.sockets.on(\'connection\', function (socket) {\n    socket.emit(\'news\', { hello: \'world\' });\n    socket.on(\'my other event\', function (data) {\n            console.log(data);\n    });\n});\n</code></pre>\n<p>然而，当在本地跑上面这段代码的时候，却一直报错：</p>\n<pre><code>Error: Can\'t set headers after they are sent.\n</code></pre>\n<p>可是我也没有在res.send方法之后set headers呀。百思不得其解，后来在issue中找到了解决方法：</p>\n<p><a href=\"https://github.com/restify/node-restify/issues/717\">https://github.com/restify/node-restify/issues/717</a></p>\n<pre><code>var restify = require(\'restify\');\nvar socketio = require(\'socket.io\');\n\nvar server = restify.createServer();\nvar io = socketio.listen(server.server);\n\n// ...\n</code></pre>\n<p>好的，问题就出在，socketio listen的不是 server对象，而是server.server对象。</p>\n<pre><code>var io = socketio.listen(server.server);\n</code></pre>\n<p>至此，问题解决了。</p>\n<p>看来，官方文档也是不能全信的。。。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/1376\">http://www.dengzhr.com/node-js/1376</a></div>\n\n        ','2','1'),(247,'node.js中TCP Socket多进程间的消息推送','\n\n            <p>前段时间接到了一个支付中转服务的需求，即支付数据通过http接口传到中转服务器，中转服务器将支付数据发送到异构后台（Lua）的指定tcp socket。</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/b7waqj03l8ppf0ble1hzex9j/image_1c25ihq2mmi116tlvkq1b811dg9.png\" alt=\"image_1c25ihq2mmi116tlvkq1b811dg9.png-30kB\"></p>\n<p>一开始评估的时候感觉蛮简单的，就是http server和tcp server间的通信，不是一个Event实例就能解决的状态管理问题吗？注册一个事件A…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>前段时间接到了一个支付中转服务的需求，即支付数据通过http接口传到中转服务器，中转服务器将支付数据发送到异构后台（Lua）的指定tcp socket。</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/b7waqj03l8ppf0ble1hzex9j/image_1c25ihq2mmi116tlvkq1b811dg9.png\" alt=\"image_1c25ihq2mmi116tlvkq1b811dg9.png-30kB\"></p>\n<p>一开始评估的时候感觉蛮简单的，就是http server和tcp server间的通信，不是一个Event实例就能解决的状态管理问题吗？注册一个事件A用于消息传递，在socket连接时注册唯一的ID，然后在http接收到数据时，emit事件A；在监听到事件A时，在tcp server中寻找指定ID对应的socket处理该数据即可。</p>\n<p>尽管node.js在高并发方面有不错的性能，但是单个tcp server实例的承载能力有限，为避免服务器过载，node.js 单进程的内存有上限（默认2G），能容纳的长连接客户端数不多。但随着业务的扩大，我们需要考虑多机集群部署，客户端可以连接到任一节点，并发送消息。如何做到多节点的同时推送，我们需要建立一套多节点之间的消息分发/订阅架构。常用的第三方消息管理库有 RabbitMQ和Redis等。在这里，我用的是Redis的订阅发布服务。</p>\n<p>redis.io有一个比较成熟的redis消息中转库<a href=\"https://github.com/socketio/socket.io-redis\">socket.io-redis</a>。但我们项目中异构后台用到的并非websocket，而是原生的TCP原生的Socket。用原生redis的sub/pubs实现并不难，就手写了。</p>\n<p>redis在该项目中主要起到一个消息分发中心(publish/subscribe)的作用。当http请求的支付数据发送过来时，则通过redis的publish功能往所有的channel推送消息，这样所有订阅该channel的socket server就能收到回调，然后推送到指定客户端。在应用层看跟Event事件消息的处理差不多。</p>\n<pre><code>const redis = require(\"redis\"),\n    redisClient = redis.createClient,\n    REDIS_CFG = {\n        host: \'127.0.0.1\',\n        port: 6379\n    },\n    sub = redisClient(REDIS_CFG),\n    pub = redisClient(REDIS_CFG),\n    PAY_MQ_CHANNEL = \'pay_mq_channel\';\n\n// 监听频道的消息回调\nsub.on(\'message\', function(channel, message) {\n    switch (channle){\n        case PAY_MQ_CHANNEL:\n            console.log(\'notification received:\', message);\n\n            // 广播消息到指定socket\n\n            break;\n    }\n});\n// 订阅频道\nsub.subscribe(PAY_MQ_CHANNEL);\n\n// 当接收到支付数据时，推送频道消息\npub.publish(PAY_MQ_CHANNEL, {id: \'01\', msg: `hello ${PAY_MQ_CHANNEL}!`});\n</code></pre>\n<p>由于redis的sub/pub的channel订阅数有上限，所以建议一类消息使用一个channel，一个channel下使用map、set或数组来存储订阅时的回调函数，在接收到订阅消息时遍历执行回调函数。</p>\n<p>下面是我封装好的Redis组件(RedisMQProxy.js)：</p>\n<pre><code>/*\n * redis 订阅/发布\n */\nconst _ = require(\'lodash\'),\n    redis = require(\"redis\"),\n    REDIS_CFG = {\n        host: \'127.0.0.1\',\n        port: 6379\n    },\n    sub = redisClient(REDIS_CFG),\n    pub = redisClient(REDIS_CFG);\n\nlet SubListenerFuns = {}; // channel的回调函数列表\n\nlet RedisMQProxy = {\n\n    // 订阅channel\n    on(channel, cb, errorCb, once = false) {\n        sub.subscribe(channel); // 订阅channel消息\n\n        // 将回调函数存放数组中\n        SubListenerFuns[channel] = _.isEmpty( SubListenerFuns[channel] ) ? [] : SubListenerFuns[channel];\n        SubListenerFuns[channel].push({\n            once, cb, errorCb\n        });\n    },\n\n    // 监听一次性的channel回调函数\n    once(channel, cb, errorCb) {\n        this.on(channel, cb, errorCb, true);\n    },\n\n    // 发送channel消息\n    emit(channel, message) {\n        if(!_.isString(message)) {\n            message = JSON.stringify(message);\n        }\n        pub.publish(channel, message);\n    },\n\n    // 移除channel上的监听函数\n    removeListener(channel, func) {\n        let channelHandlers = _.isEmpty( SubListenerFuns[channel] ) ? [] : SubListenerFuns[channel];\n        for(let i = 0, l = channelHandlers.length; i < l; i++) {\n            let handler = channelHandlers[i] || {};\n            let cb = handler.cb;\n            if(func && func == cb) {\n                channelHandlers.splice(i, 1);\n                return false;\n            }\n        }\n    }\n};\n\nRedisMQProxy.SubListeners = SubListenerFuns;\n\npub.on(\'error\', onError);\nsub.on(\'error\', onError);\n\n// 监听redis的订阅消息\nsub.on(\"message\", function(channel, message) {\n    // 遍历执行channel的回调函数\n    try {\n        message = JSON.parse(message);\n    } catch(e) {}\n    broadcastToChannel(channel, message);\n});\n\n// 广播消息到指定频道\nfunction broadcastToChannel(channel, message, isError) {\n    let channelHandlers = _.isEmpty( SubListenerFuns[channel] ) ? [] : SubListenerFuns[channel];\n    for(let i = 0, l = channelHandlers.length; i < l; i++) {\n        let handler = channelHandlers[i] || {};\n        let isOnce = handler.once || false;\n        let func = handler.cb;\n        let errorFunc = handler.errorCb;\n\n        _.isFunction(func) && func(message);\n        isError && _.isFunction(errorFunc) && errorFunc(message);\n\n        isOnce && channelHandlers.splice(i, 1); // 移除一次性监听的函数\n    }\n}\n\nfunction broadcastToAllChannels(message, isError) {\n    for(let channel in SubListenerFuns) {\n        broadcastToChannel(channel, message, isError);\n    }\n}\n\nfunction onError(err) {\n    err = err || {};\n    err.msg = err.msg || \'redis sub/pub fail\';\n\n    // 通知所有channel执行错误回调函数\n    broadcastToAllChannels(err, true);\n}\n\nmodule.exports = RedisMQProxy;\n</code></pre>\n<p>在使用时就可以比较方便地调用了：</p>\n<pre><code>const RedisMQProxy = require(\'./RedisMQProxy\'),\n    PAY_MQ_CHANNEL = \'pay_mq_channel\';\n\n// 订阅channel\nRedisMQ.on(PAY_MQ_CHANNEL, function(message) {\n    console.log(\'notification received:\', message);\n    // 广播消息到指定socket\n    // ...\n});\n\n// 订阅一次性的channel\nRedisMQ.once(PAY_MQ_CHANNEL, function(message) {\n    // ...\n});\n\n// 当接收到支付数据时，推送频道消息\nRedisMQ.emit(PAY_MQ_CHANNEL, {id: \'01\', msg: `hello ${PAY_MQ_CHANNEL}!`});\n</code></pre>\n<p>目前该项目已经健康运行了一个多月。由于socket server的多进程间消息推送依赖于redis的消息中转，而Redis使用的是单进程，未能充分利用CPU。当业务膨胀的时候，redis就要考虑分布集群了。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/1491\">http://www.dengzhr.com/node-js/1491</a></div>\n\n        ','2','1'),(248,'Node.js中防止错误导致的进程阻塞的方法','\n\n            <p>在Node.js中，当某个回调函数发生了错误，整个进程都会崩溃，影响后面的代码执行。</p>\n<p>Node.js这样处理，是因为在发生未被捕获的错误时，进程的状态就不确定。之后也就无法正常工作了。如果错误始终不处理的话，就回一直抛出意料之外的错误，这样不利于调试。</p>\n<p>防止错误导致的进程阻塞的方法主要有如下两种：</p>\n<h2>一. try-catch</h2>\n<p>try-catch允许进行异常捕获，并让代码继续执行下去：</p>\n<p>例如：</p>\n<p>当函数抛出错…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在Node.js中，当某个回调函数发生了错误，整个进程都会崩溃，影响后面的代码执行。</p>\n<p>Node.js这样处理，是因为在发生未被捕获的错误时，进程的状态就不确定。之后也就无法正常工作了。如果错误始终不处理的话，就回一直抛出意料之外的错误，这样不利于调试。</p>\n<p>防止错误导致的进程阻塞的方法主要有如下两种：</p>\n<h2><a id=\"_4\"></a>一. try-catch</h2>\n<p>try-catch允许进行异常捕获，并让代码继续执行下去：</p>\n<p>例如：</p>\n<p>当函数抛出错误时，代码就停止执行了：</p>\n<pre><code>(function() {\n    var a = 0;\n    a();\n    console.log(\"get here.\"); // 不执行\n})();\n</code></pre>\n<p>使用try-catch进行错误处理后，代码仍可继续执行：</p>\n<pre><code>(function() {\n    var a = 0;\n    try {\n        a();\n    } catch (e) {\n        console.log(e);\n    }\n    console.log(\"get here.\"); // get here.\n})();\n</code></pre>\n<h3><a id=\"_5\"></a>try-catch不能捕获未来执行函数错误</h3>\n<p>要捕获未来才执行到的函数所抛出的错误时不可能的。这会直接抛出未捕获的异常，并且catch代码块永远都不会被执行：</p>\n<pre><code>try {\n    setTimeout(function() {\n        throw new Error(\"here\");\n    }, 10);\n} catch(e) {\n    console.log(e);\n}\n</code></pre>\n<p>这就是为什么在Node.js中，每步豆芽正确进行错误处理的原因。</p>\n<h2><a id=\"_6\"></a>添加uncatchException处理器</h2>\n<p>若添加了 <strong>uncatchException</strong> 处理器，当函数抛出错误时，进程也不会退出。</p>\n<pre><code>process.on(\"uncatchException\", function(e) {\n    console.log(e);\n    process.exit(1);\n});\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/885\">http://www.dengzhr.com/node-js/885</a></div>\n\n        ','2','1'),(249,'学习笔记：在Ubuntu中搭建Node.js开发环境','\n\n            <h2>安装NodeJS</h2>\n<pre><code>sudo apt-get update\nsudo apt-get install nodejs\n</code></pre>\n<p>安装完成后执行<code>nodejs -v</code>，可查看Node.js是否安装成功。</p>\n<p>有待继续完善 … ……</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>安装NodeJS</h2>\n<pre><code>sudo apt-get update\nsudo apt-get install nodejs\n</code></pre>\n<p>安装完成后执行<code>nodejs -v</code>，可查看Node.js是否安装成功。</p>\n<p>有待继续完善 … …</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/880\">http://www.dengzhr.com/node-js/880</a></div>\n\n        ','2','1'),(250,'学习笔记：HTML5的File API','\n\n            <p>File API的宗旨是为Web开发人员提供一种安全的方式，以便在客户端访问用户计算机中的文件，并更好地对这些文件执行操作。</p>\n<p>HTML5虽然可以让我们访问本地文件系统，但是文件只有在用户触发了文件读取行为才能读取到File API，这通常在发生在表单文件选择和拖拽的情况下。</p>\n<h2>一. File API的兼容性</h2>\n<p>File API在各大主流浏览器中的支持情况如下图所示：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/aqe8ezvzw01tg0ca1io67azz/image_1aq4834d3116gcos1gkh156b19m19.png\" alt=\"image_1aq4834d3116gcos1gkh156b19m19.png-43kB\"></p>\n<p><em>备注：图片转载自： <a href=\"http://www.ibm.com/developerworks/cn/web/1210_jiangjj_html5log/\">http://www.ibm.com/developerworks/cn/web/1210_jiangjj_html5log/</a></em>…</p>\n        ','2019-07-10 09:23:19','0000-00-00 00:00:00',1,'1','\n\n            <p>File API的宗旨是为Web开发人员提供一种安全的方式，以便在客户端访问用户计算机中的文件，并更好地对这些文件执行操作。</p>\n<p>HTML5虽然可以让我们访问本地文件系统，但是文件只有在用户触发了文件读取行为才能读取到File API，这通常在发生在表单文件选择和拖拽的情况下。</p>\n<h2><a id=\"_4\"></a>一. File API的兼容性</h2>\n<p>File API在各大主流浏览器中的支持情况如下图所示：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/aqe8ezvzw01tg0ca1io67azz/image_1aq4834d3116gcos1gkh156b19m19.png\" alt=\"image_1aq4834d3116gcos1gkh156b19m19.png-43kB\"></p>\n<p><em>备注：图片转载自： <a href=\"http://www.ibm.com/developerworks/cn/web/1210_jiangjj_html5log/\">http://www.ibm.com/developerworks/cn/web/1210_jiangjj_html5log/</a></em></p>\n<p>浏览器对 File API 支持情况的更详细信息可以参考网站 <a href=\"http://caniuse.com/#search=File\">http://caniuse.com/#search=File</a>。</p>\n<p>可以用下面的方法检测当前浏览器是否支持File API：</p>\n<pre><code>function checkSupportFileAPI() {\n    if(window.File && window.FileList && window.FileReader) {\n        return true;\n    } else {\n        return false;\n    }\n}\n</code></pre>\n<h2><a id=\"_5\"></a>二. File对象的属性</h2>\n<p>FileAPI在表单中的文件输入字段的基础上，又添加了一些直接访问文件信息的接口。HTML5在DOM中为文件输入元素添加了一个file集合。在通过文件输入字段选择了一或多个文件时，files集合中将包含一组File对象，每个File对象对应着一个文件。每个File对象都有下列只读属性：</p>\n<ul>\n<li><code>name</code>： 本地文件系统的文件名；</li>\n<li><code>size</code>：文件的字节大小；</li>\n<li><code>type</code>：String类型，文件的MIME类型；</li>\n<li><code>lastModifiedDate</code>：String类型，文件最后被修改的时间。</li>\n</ul>\n<p>在HTML5中，通过添加<code>multiple</code>属性，file控件内允许一次放置多个文件。控件内的每一个选择的文件都是一个file对象。</p>\n<p>例子：通过监听change事件，并读取files集合就可以知道每个文件的信息：</p>\n<pre><code><input type=\"file\" name=\"\" id=\"filesList\" multiple>\n\n<script type=\"text/javascript\">\n    var filesList = document.getElementById(\"filesList\");\n    filesList.addEventListener(\"change\", function(e) {\n        var files = this.files,\n            i = 0,\n            len = 0;\n        if(files) {\n            len = files.length;\n        }\n        while(i < len) {\n            console.log(files[i].name + \"( \" + files[i].type + \", \" + files[i].size + \"bytes )\");\n            i++;\n        }\n    });\n</script>\n</code></pre>\n<p>选择三个文件后，console中输出如下：</p>\n<pre><code>a.jpg( image/jpeg, 1499704bytes )\nb.png( image/png, 395511bytes )\nc.jpg( image/jpeg, 1614001bytes )\n</code></pre>\n<h2><a id=\"_6\"></a>三. FileReader对象</h2>\n<h3><a id=\"_7\"></a>3.1 FileReader读取文件数据的方法</h3>\n<p>FileReader类型实现的是一种一部文件读取机制。可以把FileReader想象成XMLHttpRequest，区别只是它读取的是文件系统，而不是远程服务器。FileReader提供一个异步API，使用该API可以在浏览器主线程中异步访问文件系统，读取文件中的数据。为了读取文件中的数据，FileReader提供了如下几个方法：</p>\n<ul>\n<li><code>readAsText(file|blob [, encoding])</code>：以纯文本形式读取文件，将读取到的文本保存在result属性中。第二个参数用于指定编码类型，可选。</li>\n<li><code>readAsDataURL(file|blob)</code>：读取文件并将文件以数据URI的形式保存在result属性中。</li>\n<li><code>readAsBinaryString(file|blob)</code>：读取文件并将一个字符串保存在result属性中，字符串中的每个字符表示一个字节。</li>\n<li><code>readAsArrayBuffer(file|blob)</code>：读取文件并将一个包含文件内容的ArrayBuffer保存在result属性中。</li>\n<li><code>abort()</code>：中断读取操作。</li>\n</ul>\n<p>这些读取文件的方法为灵活地处理文件数据提供了极大的便利。例如，可以读取图像文件并将其保存为数据URI，一遍将其显示给用户；或者为了解析方便，可以将文件读取为文本形式。</p>\n<h3><a id=\"_8\"></a>3.2 FileReader的兼容性</h3>\n<p>实现了FileAPI的所有浏览器都支持readAsText()和readAsDataURL()方法。但是IE10 PR 2不支持readAsBinaryString()和readAsArrayBuffer()。IE9及其以下版本浏览器不支持FileReader API。</p>\n<p>检查当前浏览器是否支持FileReader API的方法如下：</p>\n<pre><code class=\"lang-JavaScript\">if(typeof FileReader == \"undefined\") {\n    alert(\"您的浏览器不支持FileReader API.\");\n} else {\n    var reader = new FileReader();\n}\n</code></pre>\n<h3><a id=\"_9\"></a>3.3 FileReader的事件</h3>\n<p>由于读取文件的过程是异步的，因此FileReader也提供了几个事件，常用的有：</p>\n<ul>\n<li><code>progress()</code> ：数据读取中。</li>\n<li><code>error()</code>：数据读取出错时触发。</li>\n<li><code>load()</code>：数据读取成功完成时触发。</li>\n<li><code>abort()</code>：数据读取中断时触发。</li>\n<li><code>loadstart()</code>：数据读取开始时触发。</li>\n<li><code>loadend()</code>：数据读取完成时触发，无论成功或失败。</li>\n</ul>\n<p>每过50ms左右，就回触发一次progress事件通过事件对象可以获得与XHR的progress事件相同的信息（属性）：lengthComputable、loaded和total。每次progress事件中都可以通过FileReader的result属性读取到文件内容。</p>\n<p>当无法读取文件时，就会触发error事件。触发error事件时，相关的信息将保存到FileReader的error属性中。这个属性将保存一个对象，该对象只有一个属性code，即错误码。这个错误码的属性值如下：</p>\n<ul>\n<li>1：表示未找到文件；</li>\n<li>2：表示安全性错误；</li>\n<li>3：表示读取中断；</li>\n<li>4：表示文件不可读；</li>\n<li>5：表示编码错误。</li>\n</ul>\n<p>文件加载成功后会触发load事件。如果发生了error事件，就不会发生load事件。</p>\n<p>例子：</p>\n<pre><code><input type=\"file\" name=\"\" id=\"filesList\">\n<div id=\"progress\"></div>\n<div id=\"output\"></div>\n\n<script type=\"text/javascript\">\n    var filesList = document.getElementById(\"filesList\");\n    filesList.addEventListener(\"change\", function(e) {\n        var info = \"\",\n        output = document.getElementById(\"output\"),\n        progress = document.getElementById(\"progress\"),\n        files = this.files,\n        type = \"default\",\n        reader = new FileReader();\n\n        if(/image/.test(files[0].type)) {\n            reader.readAsDataURL(files[0]);\n            type = \"image\";\n        } else {\n            reader.readAsText(files[0]);\n            type = \"text\";\n        }\n\n        reader.onerror = function() {\n            output.innerHTML = \"error code: \" + reader.error.code;\n        };\n        reader.onprogress = function(event) {\n            console.log(\"lengthComputable: \" + event.lengthComputable);\n            if(event.lengthComputable) {\n                progress.innerHTML = event.loaded + \"/ \" + event.total;\n            }\n        };\n        reader.onload = function() {\n            var html = \"\";\n            switch(type) {\n                case \"image\":\n                    html = \"<img src=\\\"\" + reader.result + \"\\\">\";\n                    break;\n                case \"text\":\n                    html = reader.result.toString();\n                    break;\n            }\n            output.innerHTML = html;\n        }\n    });\n</script>\n</code></pre>\n<p>在这个例子中，读取了表单字段中选择的文件，并将其内容显示在页面中如果是图片类型的文件，则将其保存为数据URI，并显示出读取的内容；如果是文件而不是图片，则以字符串形式读取并显示其内容。</p>\n<h2><a id=\"_10\"></a>四. 推荐阅读</h2>\n<p>HTML5 File API 规范（官方网站）：<a href=\"https://www.w3.org/TR/FileAPI/\">https://www.w3.org/TR/FileAPI/</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/922\">http://www.dengzhr.com/js/922</a></div>\n\n        ','2','1'),(251,'canvas中的三角运动（1） —— 三角函数基础','\n\n            <p>学习三角学，主要就是掌握各种边角关系，事实上，用于实现基本的动画90%的三角学只是都可以归结于两个函数：Math.sin()和Math.cos()。</p>\n<h2>三角函数</h2>\n<ul>\n<li><strong>Math.sin()</strong>：正弦函数</li>\n<li><strong>Math.cos()</strong>：余弦函数</li>\n<li><strong>Math.tan()</strong>：正切函数</li>\n<li><strong>Math.asin()</strong>：反正弦函数</li>\n<li><strong>Math.acos()</strong>：反余弦函数</li>\n<li><strong>Math.atan()</strong>：反正切函数</li>\n<li><strong>Math.atan2()</strong>：反正切函数</li>\n</ul>\n<h2>弧度与角度的转换</h2>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>学习三角学，主要就是掌握各种边角关系，事实上，用于实现基本的动画90%的三角学只是都可以归结于两个函数：Math.sin()和Math.cos()。</p>\n<h2><a id=\"_4\"></a>三角函数</h2>\n<ul>\n<li><strong>Math.sin()</strong>：正弦函数</li>\n<li><strong>Math.cos()</strong>：余弦函数</li>\n<li><strong>Math.tan()</strong>：正切函数</li>\n<li><strong>Math.asin()</strong>：反正弦函数</li>\n<li><strong>Math.acos()</strong>：反余弦函数</li>\n<li><strong>Math.atan()</strong>：反正切函数</li>\n<li><strong>Math.atan2()</strong>：反正切函数</li>\n</ul>\n<h2><a id=\"_5\"></a>弧度与角度的转换</h2>\n<ul>\n<li>弧度：radians = degreens * Math.PI / 180</li>\n<li>角度：degrees = radians * 180 / Math.PI</li>\n</ul>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/949\">http://www.dengzhr.com/js/949</a></div>\n\n        ','2','1'),(252,'光标位置工具函数的实现','\n\n            <pre><code>/**\n* 光标位置组件\n* ## selectRange对象的方法：\n*   （1）selectRange.of(ele)   [创建光标位置获取的新对象]\n           参数：\n                ele  {{JavaScript DOM}}  光标所在的元素，原生JavaScript DOM\n\n*   （2）selectRange.getCurPos()   [获取当前坐标位置]\n\n*   （3）selectRange.setCurPos(pos)   [设置当前光标位置]\n           参数：\n                pos  {{Int}}</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <pre><code>/**\n* 光标位置组件\n* ## selectRange对象的方法：\n*   （1）selectRange.of(ele)   [创建光标位置获取的新对象]\n           参数：\n                ele  {{JavaScript DOM}}  光标所在的元素，原生JavaScript DOM\n\n*   （2）selectRange.getCurPos()   [获取当前坐标位置]\n\n*   （3）selectRange.setCurPos(pos)   [设置当前光标位置]\n           参数：\n                pos  {{Int}}  当前光标位置\n\n*   （4）selectRange.getSelectText()   [获取选中文字]\n\n*   （5）selectRange.setSelectText(startPos, endPos)   [选中特定范围的文本（只限于textarea和input）]\n*           参数：\n                startPos  {{Int}}  起始位置\n                endPos  {{Int}}  终点位置\n\n*   （6）selectRange.insertAfterText(value)   [在光标后插入文本]\n*           参数：\n                value  {{String}}  要插入的文本\n* \n*\n* ## 使用实例：\n*       selectRange.of(EleDom).getCurPos(); // 获取当前坐标位置\n*       selectRange.of(EleDom).setCurPos(pos); // 设置当前光标位置为pos\n*       selectRange.of(EleDom).getSelectText(); // 获取选中文字\n*       selectRange.of(EleDom).setSelectText(startPos, endPos); // 选中startPos到endPos范围的文本\n*       selectRange.of(EleDom).insertAfterText(value); // 在光标后插入值为value的文本\n*/\n\nvar selectRange = function(ele){\n    this.__element = ele;\n};\n// 创建光标位置获取的新对象\nselectRange.of = function(ele){\n    if(ele) {\n        return new selectRange(ele);\n    } else {\n        return {};\n    }\n};\n\nselectRange.prototype = {\n    constructor:selectRange,\n    // 获取当前坐标位置\n    getCurPos: function() {\n        var _this = this,\n            textDom = _this.__element;\n        // 获取光标位置\n        var cursorPos = 0;\n        if (document.selection) {\n            // IE Support\n            textDom.focus();\n            var selectRange = document.selection.createRange();\n            selectRange.moveStart (\'character\', -textDom.value.length);\n            cursorPos = selectRange.text.length;\n        }else if (textDom.selectionStart || textDom.selectionStart == \'0\') {\n            // Firefox support\n            cursorPos = textDom.selectionStart;\n        }\n        return cursorPos;\n    },\n\n    /**\n    * 设置当前光标位置\n    * 参数：\n    *     pos  [Int]  当前光标位置\n    */\n    setCurPos: function(pos) {\n        var _this = this,\n            textDom = _this.__element;\n        if(textDom.setSelectionRange) {\n            // IE Support\n            textDom.focus();\n            textDom.setSelectionRange(pos, pos);\n        }else if (textDom.createTextRange) {\n            // Firefox support\n            var range = textDom.createTextRange();\n            range.collapse(true);\n            range.moveEnd(\'character\', pos);\n            range.moveStart(\'character\', pos);\n            range.select();\n        }\n    },\n\n    // 获取选中文字\n    getSelectText: function() {\n        var _this = this,\n            textDom = _this.__element,\n            userSelection,\n            text = \"\";\n        if (window.getSelection) {\n            // Firefox support\n            userSelection = window.getSelection();\n        } else if (document.selection) {\n            // IE Support\n            userSelection = document.selection.createRange();\n        }\n        if (!(text = userSelection.text)) {\n            text = userSelection;\n        }\n        return text;\n    },\n\n    /**\n    * 选中特定范围的文本（只限于textarea和input）\n    * 参数：\n    *     startPos  [Int]  起始位置\n    *     endPos  [Int]  终点位置\n    */\n    setSelectText: function(startPos, endPos) {\n        var _this = this,\n            textDom = _this.__element,\n            startPos = parseInt(startPos),\n            endPos = parseInt(endPos),\n            textLength = textDom.value.length;\n        if(textLength){\n            if(!startPos){\n                startPos = 0;\n            }\n            if(!endPos){\n                endPos = textLength;\n            }\n            if(startPos > textLength){\n                startPos = textLength;\n            }\n            if(endPos > textLength){\n                endPos = textLength;\n            }\n            if(startPos < 0){\n                startPos = textLength + startPos;\n            }\n            if(endPos < 0){\n                endPos = textLength + endPos;\n            }\n            if(textDom.createTextRange){\n                // IE Support\n                var range = textDom.createTextRange();\n                range.moveStart(\"character\",-textLength);\n                range.moveEnd(\"character\",-textLength);\n                range.moveStart(\"character\", startPos);\n                range.moveEnd(\"character\",endPos);\n                range.select();\n            }else{\n                // Firefox support\n                textDom.setSelectionRange(startPos, endPos);\n                textDom.focus();\n            }\n        }\n    },\n\n    /**\n    * 在光标后插入文本\n    * 参数：\n    *     value  [String]  要插入的文本\n    */\n    insertAfterText: function(value) {\n        var _this = this,\n            textDom = _this.__element,\n            selectRange;\n        if (document.selection) {\n            // IE Support\n            textDom.focus();\n            selectRange = document.selection.createRange();\n            selectRange.text = value;\n            textDom.focus();\n        }else if (textDom.selectionStart || textDom.selectionStart == \'0\') {\n            // Firefox support\n            var startPos = textDom.selectionStart;\n            var endPos = textDom.selectionEnd;\n            var scrollTop = textDom.scrollTop;\n            textDom.value = textDom.value.substring(0, startPos) + value + textDom.value.substring(endPos, textDom.value.length);\n            textDom.focus();\n            textDom.selectionStart = startPos + value.length;\n            textDom.selectionEnd = startPos + value.length;\n            textDom.scrollTop = scrollTop;\n        }\n        else {\n            textDom.value += value;\n            textDom.focus();\n        }\n    }\n};\n</code></pre>\n<p>例子：</p>\n<p><iframe style=\"width: 100%;\" src=\"//codepen.io/dengzhirong8344/embed/ALrBwX/?height=300&theme-id=15300&default-tab=result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong8344/pen/ALrBwX/\">ALrBwX</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong8344\">@dengzhirong8344</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1025\">http://www.dengzhr.com/js/1025</a></div>\n\n        ','2','1'),(253,'学习笔记：HTML5的拖放 API','\n\n            <p>在HTML5之前，如果要实现拖放效果，一般会使用mousedown、mousemove和mouseup三个事件进行组合来模拟出拖拽效果，比较麻烦。而HTML5规范实现了原生拖放功能，使得元素拖放的实现更加方便和高效。</p>\n<p>默认情况下，图像、链接和文本是可以拖动的。文本只有在被选中的情况下才能拖动，而图像和链接在任何时候都可以拖动。</p>\n<p>HTML5为所有的HTML元素规定了一个draggable属性，表示元�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在HTML5之前，如果要实现拖放效果，一般会使用mousedown、mousemove和mouseup三个事件进行组合来模拟出拖拽效果，比较麻烦。而HTML5规范实现了原生拖放功能，使得元素拖放的实现更加方便和高效。</p>\n<p>默认情况下，图像、链接和文本是可以拖动的。文本只有在被选中的情况下才能拖动，而图像和链接在任何时候都可以拖动。</p>\n<p>HTML5为所有的HTML元素规定了一个draggable属性，表示元素是否允许拖动。要想让其他元素也能被拖动，可以设置这个属性为true。</p>\n<h2><a id=\"_4\"></a>一. 实现拖放的步骤：</h2>\n<h3><a id=\"_5\"></a>1.1 步骤1：创建一个可拖拽对象：</h3>\n<h4><a id=\"_6\"></a>1.1.1如果想要拖动某个元素，需要设置元素的 draggable 属性为 true。</h4>\n<pre><code><img id=\"dragImg\" draggable=\"true\" />\n</code></pre>\n<h4><a id=\"_7\"></a>1.1.2给 dragstart 设置一个事件监听器存储拖拽数据。</h4>\n<pre><code>document.getElementById(\"dragImg\").addEventListener(\"dragstart\", function(event) {\n    // 存储拖拽数据和拖拽效果...\n    event.dataTransfer.setData(\"Text\",ev.target.id);\n}, false);\n</code></pre>\n<h3><a id=\"_8\"></a>1.2 步骤2：放置对象：</h3>\n<p>假设放置对象的DOM为：</p>\n<pre><code><div id=\"dragTarget\"></div>\n</code></pre>\n<h3><a id=\"_9\"></a>1.2.1 dragenter事件，用来确定放置目标是否接受放置。</h3>\n<p>如果放置被接受，那么这个事件必须取消。</p>\n<pre><code>document.getElementById(\"dragTarget\").addEventListener(\"dragenter\", function(event) {\n    // 阻止浏览器默认事件\n    event.preventDefault();\n}, false);\n</code></pre>\n<h3><a id=\"_10\"></a>1.2.2 dragover事件，用来确定给用户显示怎样的反馈信息。</h3>\n<p>如果这个事件被取消，反馈信息（通常就是光标）就会基于 dropEffect 属性的值更新。</p>\n<pre><code>document.getElementById(\"dragTarget\").addEventListener(\"dragover\", function(event) {\n    // 阻止浏览器默认事件\n    event.preventDefault();\n}, false);\n</code></pre>\n<h3><a id=\"_11\"></a>1.2.3 最后是drop事件，允许放置对象。</h3>\n<pre><code>document.getElementById(\"dragTarget\").addEventListener(\"drop\", function(event) {\n    event.preventDefault();\n    var data=event.dataTransfer.getData(\"Text\");\n    event.target.appendChild(document.getElementById(data));\n}, false);\n</code></pre>\n<h3><a id=\"_12\"></a>1.3例子：</h3>\n<p>（备注： 转载自：<a href=\"http://www.w3school.com.cn/tiy/t.asp?f=html5_draganddrop\">http://www.w3school.com.cn/tiy/t.asp?f=html5_draganddrop</a>）</p>\n<pre><code><!DOCTYPE HTML>\n<html>\n<head>\n    <style type=\"text/css\">\n        #dragTarget {width:488px;height:70px;padding:10px;border:1px solid #aaaaaa;}\n    </style>\n    <script type=\"text/javascript\">\n        function allowDrop(ev){\n            ev.preventDefault();\n        }\n        function drag(ev){\n            ev.dataTransfer.setData(\"Text\",ev.target.id);\n        }\n        function drop(ev){\n            ev.preventDefault();\n            var data=ev.dataTransfer.getData(\"Text\");\n            ev.target.appendChild(document.getElementById(data));\n        }\n    </script>\n</head>\n<body>\n    <p>请把 W3School 的图片拖放到矩形中：</p>\n    <div id=\"dragTarget\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"></div>\n    <br /> \n    <img id=\"dragImg\" src=\"http://www.w3school.com.cn/i/w3school_banner.gif\" draggable=\"true\" ondragstart=\"drag(event)\" />\n</body>\n</html>\n</code></pre>\n<h2><a id=\"_13\"></a>二. 拖放的相关事件：</h2>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>产生事件的元素</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dragstart</td>\n<td>被拖放的元素</td>\n<td>开始拖放操作</td>\n</tr>\n<tr>\n<td>drag</td>\n<td>被拖放的元素</td>\n<td>拖放过程中</td>\n</tr>\n<tr>\n<td>dragenter</td>\n<td>拖放过程中鼠标经过的元素</td>\n<td>被拖放元素开始进入本元素的范围内</td>\n</tr>\n<tr>\n<td>dragover</td>\n<td>拖放过程中鼠标经过的元素</td>\n<td>被拖放元素正在本元素范围内移动</td>\n</tr>\n<tr>\n<td>dragleave</td>\n<td>拖放过程中鼠标经过的元素</td>\n<td>被拖放元素离开本元素的范围</td>\n</tr>\n<tr>\n<td>drop</td>\n<td>拖放的目标元素</td>\n<td>有其他元素被拖放到本元素中</td>\n</tr>\n<tr>\n<td>dragend</td>\n<td>拖放的对象元素</td>\n<td>拖放操作结束</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_14\"></a>三. DataTransfer对象的属性与方法</h2>\n<h3><a id=\"_15\"></a>3.1 DataTransfer对象的属性：</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dropEffect</td>\n<td>表示拖放操作的视觉效果，允许对其进行值的设定。该效果必须在用effectAllowed属性指定的允许的视觉效果范围内，允许指定的值有：none、copy、link、move。</td>\n</tr>\n<tr>\n<td>effectAllowed</td>\n<td>用来指定当元素被拖放时所允许的视觉效果。可以指定的值有：none、copy、copyLink、copyMove、link、linkMove、all、uninitialize。</td>\n</tr>\n<tr>\n<td>files</td>\n<td>返回表示被拖拽文件的 FileList。</td>\n</tr>\n<tr>\n<td>types</td>\n<td>存入数据的MIME类型。如果任意文件被拖拽，那么其中一个类型将会是字符串”Files”。</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void setData(DOMString format, DOMString data)</td>\n<td>向DataTransfer对象存入数据。</td>\n</tr>\n<tr>\n<td>DOMString getData(DOMString data)</td>\n<td>读取DataTransfer对象中的数据。</td>\n</tr>\n<tr>\n<td>void clearData(DOMString format)</td>\n<td>清除DataTransfer对象中的数据。如果省略参数format，则清除全部数据。</td>\n</tr>\n<tr>\n<td>void setDragImage(Element image, long x, long y)</td>\n<td>用img元素来设置拖放图标。</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_16\"></a>四. draggable属性兼容性：</h2>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/cxbopjk8ctuajycpdu6urmhm/image_1aq4irg51vpoq1j1mnaa9m1dbd9.png\" alt=\"image_1aq4irg51vpoq1j1mnaa9m1dbd9.png-56.1kB\"></p>\n<p>备注：图片源自：<a href=\"http://caniuse.com/#search=drag\">http://caniuse.com/#search=drag</a></p>\n<p>各大主流浏览器的更详细的支持信息请查看： <a href=\"http://caniuse.com/#search=drag\">http://caniuse.com/#search=drag</a></p>\n<h2><a id=\"_17\"></a>五. 推荐阅读</h2>\n<p>W3C School教程 —— HTML 5 拖放： <a href=\"http://www.w3school.com.cn/html5/html_5_draganddrop.asp\">http://www.w3school.com.cn/html5/html_5_draganddrop.asp</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/927\">http://www.dengzhr.com/frontend/html/927</a></div>\n\n        ','2','1'),(254,'canvas中的三角运动（2） —— 旋转动画','\n\n            <h2>一. 需求：</h2>\n<p>来一个挑战：<strong>绘制一个物体，并让它随着鼠标旋转，使它总能指向鼠标。</strong></p>\n<p>假设这个可供旋转的对象为箭头对象，箭头的构造函数如下：</p>\n<pre><code>// 箭头绘制的构造函数\nfunction Arrow() {\n    this.x = 0;\n    this.y = 0;\n    this.color = \"#ffff00\";\n    this.rotation = 0;\n}\nArrow.prototype.draw = function(context) {\n    context.save();</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 需求：</h2>\n<p>来一个挑战：<strong>绘制一个物体，并让它随着鼠标旋转，使它总能指向鼠标。</strong></p>\n<p>假设这个可供旋转的对象为箭头对象，箭头的构造函数如下：</p>\n<pre><code>// 箭头绘制的构造函数\nfunction Arrow() {\n    this.x = 0;\n    this.y = 0;\n    this.color = \"#ffff00\";\n    this.rotation = 0;\n}\nArrow.prototype.draw = function(context) {\n    context.save();\n    context.translate(this.x, this.y);\n    context.rotate(this.rotation);\n    context.lineWidth = 2;\n    context.fillStyle = this.color;\n    context.beginPath();\n    context.moveTo(-50, -25);\n    context.lineTo(0, -25);\n    context.lineTo(0, -50);\n    context.lineTo(50, 0);\n    context.lineTo(0, 50);\n    context.lineTo(0, 25);\n    context.lineTo(-50, 25);\n    context.lineTo(-50, -25);\n    context.closePath();\n    context.fill();\n    context.stroke();\n    context.restore();\n}\n</code></pre>\n<h2><a id=\"_5\"></a>二. 解决思路：</h2>\n<p>鼠标的位置可以通过getMouse(e).x和getMouse(e).y属性获得它的坐标值。</p>\n<p>箭头的位置可以通过arrow.x和arrow.y得到。</p>\n<p>通过这两个坐标的差值，就可以计算到三角形两边的长度dx、dy。此时，只需要通过<strong>Math.atan2(dy, dx)</strong>方法即可计算出角度的大小，并将其赋值给箭头对象的rotation属性。</p>\n<p>箭头应旋转的角度如下图所示：</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/ms1ab5vzv0y84crzig282art/image_1aqjs39q1194kue1h1k1ri4kj99.png\" alt=\"image_1aqjs39q1194kue1h1k1ri4kj99.png-20.7kB\"></p>\n<p>该过程如下：</p>\n<pre><code>var dx = getMouse(e).x - arrow.x,\n    dy = getMouse(e).y - arrow.y;\n\narrow.rotation = Math.atan2(dy, dx); // 计算箭头旋转的弧度\n</code></pre>\n<p>完整代码如下：</p>\n<pre><code><canvas id=\"canvas\" width=\"200\" height=\"200\" style=\"background: #ccc;\"></canvas>\n<script type=\"text/javascript\">\n    // 箭头绘制的构造函数\n    function Arrow() {\n        this.x = 0;\n        this.y = 0;\n        this.color = \"#ffff00\";\n        this.rotation = 0;\n    }\n    Arrow.prototype.draw = function(context) {\n        context.save();\n        context.translate(this.x, this.y);\n        context.rotate(this.rotation);\n        context.lineWidth = 2;\n        context.fillStyle = this.color;\n        context.beginPath();\n        context.moveTo(-50, -25);\n        context.lineTo(0, -25);\n        context.lineTo(0, -50);\n        context.lineTo(50, 0);\n        context.lineTo(0, 50);\n        context.lineTo(0, 25);\n        context.lineTo(-50, 25);\n        context.lineTo(-50, -25);\n        context.closePath();\n        context.fill();\n        context.stroke();\n        context.restore();\n    }\n\n    var canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\"),\n        arrow = new Arrow();\n\n    arrow.x = canvas.width / 2;\n    arrow.y = canvas.height / 2;\n\n    // 鼠标跟随事件\n    canvas.addEventListener(\"mousemove\", function(e) {\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        var dx = getMouse(e).x - arrow.x,\n            dy = getMouse(e).y - arrow.y;\n\n        arrow.rotation = Math.atan2(dy, dx); // 计算箭头旋转的弧度\n        arrow.draw(context);\n    }, false);\n\n    // 获取鼠标的当前位置\n    function getMouse(event) {\n        var event = event || window.event;\n        var mouse = {};\n        var x, y;\n        if(event.pageX || event.pageY) {\n            x = event.pageX;\n            y = event.pageY;\n        } else if(event.clientX || event.clientY) {\n            var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n            var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n            x = event.clientX + scrollLeft;\n            y = event.clientY + scrollTop;\n        }\n        mouse.x = x;\n        mouse.y = y;\n        return mouse;\n    }\n</script>\n</code></pre>\n<p>演示如下：<a href=\"http://codepen.io/dengzhirong/pen/rLbkXj\">http://codepen.io/dengzhirong/pen/rLbkXj</a></p>\n<p><iframe style=\"width: 100%;\" src=\"//codepen.io/dengzhirong/embed/rLbkXj/?height=421&theme-id=15149&default-tab=result&embed-version=2\" width=\"300\" height=\"421\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong/pen/rLbkXj/\">rLbkXj</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong\">@dengzhirong</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n<h2><a id=\"_6\"></a>三. 总结：</h2>\n<p>实际上，旋转功能不限于鼠标。可以将该功能演变成强制一个物体围绕特定的点旋转。</p>\n<p>旋转动画用到的三角函数是：<code>Math.atan2(dy, dx)</code>。根据直角三角形的对边和邻边，获得角的弧度。从而计算出旋转的角度。</p>\n<p>朝鼠标（或任意一点）旋转的公式如下：</p>\n<pre><code>// 假设mouse为旋转跟随点，object为旋转物体\ndx = mouse.x - object.x;\ndy = mouse.y - object.y;\nobject.rotation = Math.atan2(dy, dx) * 180 / Math.PI;\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/953\">http://www.dengzhr.com/js/953</a></div>\n\n        ','2','1'),(255,'谈谈requestAnimationFrame的动画循环','\n\n            <h2>一. 动画的循环间隔</h2>\n<p>编写动画循环的关键，是要知道延迟时间多长合适。一方面，循环时间必须足够短，这样才能保证动画效果更平滑流畅；另一方面，循环还要足够长，这样才能保证浏览器有能力渲染产生的变化。大多数显示器的刷新频率是60Hz，相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过了这个频率，用户体验也不会有提升。</p>\n<p>因此最平滑动画的最佳循环间隔是1000ms/60，约等于17ms。以这个循环间隔重绘的�…</p>\n        ','2019-08-05 07:09:59','0000-00-00 00:00:00',2,'1','\n\n            <h2><a id=\"_4\"></a>一. 动画的循环间隔</h2>\n<p>编写动画循环的关键，是要知道延迟时间多长合适。一方面，循环时间必须足够短，这样才能保证动画效果更平滑流畅；另一方面，循环还要足够长，这样才能保证浏览器有能力渲染产生的变化。大多数显示器的刷新频率是60Hz，相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过了这个频率，用户体验也不会有提升。</p>\n<p>因此最平滑动画的最佳循环间隔是1000ms/60，约等于17ms。以这个循环间隔重绘的动画是平滑的，因为这个速度最接近浏览器的最高限速。为了适应17ms的循环间隔，多重动画可能需要加以节制，以便不会完成得太快。</p>\n<p>虽然与使用多组<code>setTimeout()</code>相比，使用<code>setInterval()</code>的动画循环效率更高。但是无论<code>setTimeout()</code>还是<code>setInterval()</code>都不十分精确。为它们传入的第二个参数，实际上只是指定了把动画代码添加到浏览器UI线程队列以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务执行完成后再执行。如果UI线程繁忙，比如忙于处理用户操作，那么即使把代码加入队列也不会立即执行。</p>\n<p>因此，知道什么时候绘制下一帧是保证动画平滑的关键。然而，面对不十分精确的<code>setTimeout(</code>)和<code>setInterval()</code>，开发人员至今都没有办法确保浏览器按时绘制下一帧。以下是几个浏览器的计时器精度：</p>\n<ul>\n<li>IE8及其以下版本浏览器： 15.6ms；</li>\n<li>IE9及其以上版本浏览器：4ms；</li>\n<li>Firefox和Safari：10ms；</li>\n<li>Chrome：4ms。</li>\n</ul>\n<p>更为复杂的是，浏览器开始限制后台标签页或不活动标签页的计数器。因此，即使你优化了循环间隔，可能仍然只能接近你想要的效果。</p>\n<h2><a id=\"_5\"></a>二. requestAnimationFrame()</h2>\n<p><strong>Mozilla</strong>的 <strong>Robert O’Callahan</strong> 指出，CSS变换动画的优势在于浏览器知道动画什么时候开始，因此会计算出正确的循环间隔，在适当的时候刷新UI。而对于JavaScript动画，浏览器就无从知晓什么时候开始。</p>\n<p>因此<strong>Robert O’Callahan</strong>的方案是，创建一个新方法<code>mozRequestAnimationFrame()</code>，通过它告诉浏览器某些代码将要执行动画。这样浏览器可以在运行某些代码后进行适当的优化。</p>\n<p>与<code>setTimeout()</code>和<code>setInterval()</code>方法不同，<code>requestAnimationFrame(</code>)不需要调用者指定帧速率，浏览器会自行决定最佳的帧效率。</p>\n<p><code>requestAnimationFrame()</code>方法接收一个参数，即在重绘屏幕前调用以个函数。这个函数负责改变下一次重绘时的DOM样式。为了创建动画循环，可以像使用<code>setTimeout()</code>一样，把多个对<code>requestAnimationFrame()</code>的调用连缀起来。如：</p>\n<pre><code>function drawFrame() {\n    window.requestAnimationFrame(drawFrame);\n    // animation code...\n}\nwindow.requestAnimationFrame(drawFrame);\n</code></pre>\n<h2><a id=\"_6\"></a>三. requestAnimationFrame()的兼容性</h2>\n<h3><a id=\"_7\"></a>3.1 requestAnimationFrame()的兼容性封装：</h3>\n<p>由于<code>mozRequestAnimationFrame()</code>是HTML5的新功能，目前各大浏览器的支持情况各异。具体兼容情况个参考<a href=\"http://caniuse.com/#search=RequestAnimationFrame\">http://caniuse.com/#search=RequestAnimationFrame</a>。如果希望代码具备更好的跨平台性，可以考虑使用下面的代码实现各平台兼容性：</p>\n<pre><code>if(!window.requestAnimationFrame) {\n    window.requestAnimationFrame = (window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    function(callback) {\n        var self = this, start, finish;\n        return window.setTimeout(function() {\n            start = +new Date();\n            callback(start);\n            finish = +new Date();\n            self.timeout = 1000/60 - (finish - start);\n        }, self.timeout);\n    });\n}\n</code></pre>\n<p>这段代码先检查了<code>window.requestAnimationFrame</code>函数的定义是否存在。如果不存在，就遍历已知的各种浏览器实现并替代该函数。如果还是找不到一个与浏览器相关的实现，它最终会采用基于JavaScript定时器的动画以每秒60帧的间隔调用<code>setTimeout</code>函数。</p>\n<p><code>mozRequestAnimationFrame()</code>会接收一个时间码（从1970年1月1日起至今的毫秒数），表示下一次重绘的实际发生时间。这样，<code>mozRequestAnimationFrame()</code>就会根据这个时间码设定将来的某个时刻进行重绘。</p>\n<p>但是<code>webkitRequestAnimationFrame()</code>和<code>msRequestAnimationFrame()</code>不会给回调函数传递时间码，因此无法知道下一次重绘将发生在什么时间。</p>\n<p>如果要计算两次重绘的时间间隔，Firefox中可以使用既有的时间码，而在Chrome和IE则可以使用不太精确地<code>Date()</code>对象。</p>\n<h3><a id=\"_8\"></a>3.2 cancelRequestAnimFrame()的兼容性封装：</h3>\n<p>W3C也提供了<code>cancelRequestAnimationFrame()</code>方法，用于取消回调函数。<code>requestAnimationFrame()</code>方法会返回一个对象，用做标识回掉函数身份。若要取消回调函数的执行，可将其传给<code>cancelRequestAnimationFrame()</code>。</p>\n<pre><code>window.cancelRequestAnimFrame = ( function() {\n    return window.cancelAnimationFrame ||\n        window.webkitCancelRequestAnimationFrame ||\n        window.mozCancelRequestAnimationFrame ||\n        window.oCancelRequestAnimationFrame ||\n        window.msCancelRequestAnimationFrame ||\n        clearTimeout;\n} )();\n</code></pre>\n<h3><a id=\"_9\"></a>3.3 requestAnimationFrame()升级版封装方法：</h3>\n<p>另外还有一种更优雅的<code>requestAnimationFrame()</code>的兼容性封装方法： （引用自：<a href=\"https://gist.github.com/paulirish/1579671\">https://gist.github.com/paulirish/1579671</a>）</p>\n<pre><code>(function() {\n    var lastTime = 0;\n    var vendors = [\'ms\', \'moz\', \'webkit\', \'o\'];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x]+\'RequestAnimationFrame\'];\n        window.cancelAnimationFrame = window[vendors[x]+\'CancelAnimationFrame\']  || window[vendors[x]+\'CancelRequestAnimationFrame\'];\n    }\n\n    if (!window.requestAnimationFrame)\n        window.requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, \n              timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n\n    if (!window.cancelAnimationFrame)\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n}());\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/937\">http://www.dengzhr.com/js/937</a></div>\n\n        ','2','1'),(256,'JS中用户交互的常见事件处理','\n\n            <p>用户交互是基于用户事件的，这些事件通常是鼠标事件、触摸事件以及键盘事件。</p>\n<h2>一. 监听器与事件处理程序</h2>\n<p>添加事件监听可以使用<strong>addEventListener()</strong>：</p>\n<pre><code>element.addEventListener(type, handler [, userCapture])\n</code></pre>\n<p>移除事件监听可以使用<strong>removeEventListener()</strong>：</p>\n<pre><code>element.removeEventListener(type, handler</code></pre>…\n        ','2019-08-05 07:29:31','0000-00-00 00:00:00',1,'1','\n\n            <p>用户交互是基于用户事件的，这些事件通常是鼠标事件、触摸事件以及键盘事件。</p>\n<h2><a id=\"_4\"></a>一. 监听器与事件处理程序</h2>\n<p>添加事件监听可以使用<strong>addEventListener()</strong>：</p>\n<pre><code>element.addEventListener(type, handler [, userCapture])\n</code></pre>\n<p>移除事件监听可以使用<strong>removeEventListener()</strong>：</p>\n<pre><code>element.removeEventListener(type, handler [, userCapture])\n</code></pre>\n<p>addEventListener()兼容IE9+浏览器和其他主流的现代浏览器，不兼容IE8及其以下版本。在IE8及其以下版本浏览器应使用attachEvent()来进行事件绑定。具体可查看：<a href=\"http://www.dengzhr.com/js/366\">JavaScript事件处理兼容性总结</a></p>\n<h3><a id=\"_5\"></a>1.1 event事件类型</h3>\n<p>event事件类型具体可参考：<a href=\"http://www.w3school.com.cn/tags/html_ref_eventattributes.asp\">http://www.w3school.com.cn/tags/html_ref_eventattributes.asp</a></p>\n<h3><a id=\"_6\"></a>1.2 event事件属性和方法</h3>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>IE</th>\n<th>非IE</th>\n<th>W3C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>altKey</td>\n<td>返回当事件被触发时，”ALT” 是否被按下。</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>button</td>\n<td>返回当事件被触发时，哪个鼠标按钮被点击。</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>clientX</td>\n<td>返回当事件被触发时，鼠标指针的水平坐标。</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>clientY</td>\n<td>返回当事件被触发时，鼠标指针的垂直坐标。</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>ctrlKey</td>\n<td>返回当事件被触发时，”CTRL” 键是否被按下。</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>metaKey</td>\n<td>返回当事件被触发时，”meta” 键是否被按下。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>relatedTarget</td>\n<td>返回与事件的目标节点相关的节点。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>screenX</td>\n<td>返回当某个事件被触发时，鼠标指针的水平坐标。</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>screenY</td>\n<td>返回当某个事件被触发时，鼠标指针的垂直坐标。</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>shiftKey</td>\n<td>返回当事件被触发时，”SHIFT” 键是否被按下。</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>bubbles</td>\n<td>返回布尔值，指示事件是否是起泡事件类型。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>cancelable</td>\n<td>返回布尔值，指示事件是否可拥可取消的默认动作。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>currentTarget</td>\n<td>返回其事件监听器触发该事件的元素。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>eventPhase</td>\n<td>返回事件传播的当前阶段。</td>\n<td></td>\n<td></td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>target</td>\n<td>返回触发此事件的元素（事件的目标节点）。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>timeStamp</td>\n<td>返回事件生成的日期和时间。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>type</td>\n<td>返回当前 Event 对象表示的事件的名称。</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>which</td>\n<td>键盘码。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>charCode</td>\n<td>键盘码。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>IE</th>\n<th>非IE</th>\n<th>W3C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>initEvent()</td>\n<td>初始化新创建的 Event 对象的属性。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>preventDefault()</td>\n<td>通知浏览器不要执行与事件关联的默认动作。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>stopPropagation()</td>\n<td>不再派发事件。</td>\n<td>No</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n</tbody>\n</table>\n<p>除了上面W3C规范所规定的属性和方法外，IE浏览器还支持以下属性。</p>\n<p><strong>event对象的属性（IE特有）：</strong></p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cancelBubble</td>\n<td>如果事件句柄想阻止事件传播到包容对象，必须把该属性设为 true。</td>\n</tr>\n<tr>\n<td>fromElement</td>\n<td>对于 mouseover 和 mouseout 事件，fromElement 引用移出鼠标的元素。</td>\n</tr>\n<tr>\n<td>keyCode</td>\n<td>对于 keypress 事件，该属性声明了被敲击的键生成的 Unicode 字符码。对于 keydown 和 keyup 事件，它指定了被敲击的键的虚拟键盘码。虚拟键盘码可能和使用的键盘的布局相关。</td>\n</tr>\n<tr>\n<td>offsetX, offsetY</td>\n<td>发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。</td>\n</tr>\n<tr>\n<td>returnValue</td>\n<td>如果设置了该属性，它的值比事件句柄的返回值优先级高。把这个属性设置为 fasle，可以取消发生事件的源元素的默认动作。</td>\n</tr>\n<tr>\n<td>srcElement</td>\n<td>对于生成事件的 Window 对象、Document 对象或 Element 对象的引用。</td>\n</tr>\n<tr>\n<td>toElement</td>\n<td>对于 mouseover 和 mouseout 事件，该属性引用移入鼠标的元素。</td>\n</tr>\n<tr>\n<td>x, y</td>\n<td>事件发生的位置的 x 坐标和 y 坐标，它们相对于用CSS动态定位的最内层包容元素。</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_7\"></a>二. 鼠标事件</h2>\n<p>鼠标事件常用的有：</p>\n<ul>\n<li><strong>mousedown</strong></li>\n<li><strong>mouseup</strong></li>\n<li><strong>click</strong></li>\n<li><strong>dbclick</strong></li>\n<li><strong>mousewheel</strong></li>\n<li><strong>mousemove</strong></li>\n<li><strong>mouseover</strong></li>\n<li><strong>mouseout</strong></li>\n<li><strong>mouseenter</strong></li>\n</ul>\n<h2><a id=\"_8\"></a>三. 鼠标位置</h2>\n<p>每个鼠标事件都有两个属性用于确定鼠标的当前位置：pageX与pageY。结合这两个属性及目标元素相对于document的偏移量，可以确定鼠标在canvas元素上的相对坐标。遗憾的是，并不是所有的浏览器都支持pageX和pageY属性，可能要用到clientX和clientY。</p>\n<p>获取鼠标位置的兼容性写法如下：</p>\n<pre><code>// 获取鼠标的当前位置\nfunction getMouse(event) {\n    var event = event || window.event;\n    var mouse = {};\n    var x, y;\n    if(event.pageX || event.pageY) {\n        x = event.pageX;\n        y = event.pageY;\n    } else if(event.clientX || event.clientY) {\n        var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n        x = event.clientX + scrollLeft;\n        y = event.clientY + scrollTop;\n    }\n    mouse.x = x;\n    mouse.y = y;\n    return mouse;\n}\n</code></pre>\n<p>使用方法如下：</p>\n<pre><code><canvas id=\"canvas\" width=\"300\" height=\"300\" style=\"background: #ccc;\"></canvas>\n\nvar canvas = document.getElementById(\"canvas\");\ncanvas.addEventListener(\"mousemove\", function(e) {\n    var x = getMouse(e).x,\n        y = getMouse(e).y;\n    console.log(\"x: \" + x + \"; y: \" + y);\n});\n\n// 获取鼠标的当前位置\nfunction getMouse(event) {\n    var event = event || window.event;\n    var mouse = {};\n    var x, y;\n    if(event.pageX || event.pageY) {\n        x = event.pageX;\n        y = event.pageY;\n    } else if(event.clientX || event.clientY) {\n        var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n        x = event.clientX + scrollLeft;\n        y = event.clientY + scrollTop;\n    }\n    mouse.x = x;\n    mouse.y = y;\n    return mouse;\n}\n</code></pre>\n<h2><a id=\"_9\"></a>四. 触摸事件</h2>\n<p>触摸事件与鼠标事件相似，一个触摸点可以被想象成一个鼠标光标。不过鼠标光标会一直停留在屏幕上，而受制却会从设备上按下、移动以及释放同一时间可能发生多点触摸，某个触摸点会保存在触摸事件的一个数组中，不过一般都建议使用第一个触摸点。</p>\n<p>常用到的触摸事件有：</p>\n<ul>\n<li><strong>touchstart</strong></li>\n<li><strong>touchend</strong></li>\n<li><strong>touchmove</strong></li>\n</ul>\n<h2><a id=\"_10\"></a>五. 触摸位置</h2>\n<p>其中，<strong>touchstart</strong>和<strong>touchmove</strong>事件的第一个触摸点位置为：</p>\n<pre><code>event.touches[0]\n</code></pre>\n<p><strong>touchend</strong>事件的第一个触摸点位置为：</p>\n<pre><code>event.changedTouches[0]\n</code></pre>\n<pre><code><canvas id=\"canvas\" width=\"300\" height=\"300\" style=\"background: #ccc;\"></canvas>\n\nvar canvas = document.getElementById(\"canvas\");\ncanvas.addEventListener(\"touchstart\", function(e) {\n    var touches = e.touches ? e.touches[0] : e;\n    touchstartPosition = {\n        x : touches.pageX,\n        y : touches.pageY\n    };\n});\n\ncanvas.addEventListener(\"touchmove\", function(e) {\n    var touches = e.touches ? e.touches[0] : e;\n    touchmovePosition = {\n        x : touches.pageX,\n        y : touches.pageY\n    };\n    console.log(touchmovePosition);\n});\n\ncanvas.addEventListener(\"touchend\", function(e) {\n    var changedTouches = e.changedTouches ? e.changedTouches[0] : e;\n    touchsEndPosition = {\n        x : changedTouches.pageX,\n        y : changedTouches.pageY\n    };\n    console.log(touchsEndPosition);\n});\n</code></pre>\n<h2><a id=\"_11\"></a>六. 键盘事件</h2>\n<p>键盘事件仅有两个：</p>\n<ul>\n<li><strong>keydown</strong></li>\n<li><strong>keyup</strong></li>\n</ul>\n<h2><a id=\"_12\"></a>七. 键盘码</h2>\n<p>在一个键盘事件中，可以通过事件对象的keyCode属性获知哪个键按下。</p>\n<p>具体的键盘码可参考： <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\">https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode</a></p>\n<h2><a id=\"_13\"></a>八. 拖拽事件</h2>\n<ul>\n<li><strong>dragstart</strong></li>\n<li><strong>drag</strong></li>\n<li><strong>dragenter</strong></li>\n<li><strong>dragover</strong></li>\n<li><strong>dragleave</strong></li>\n<li><strong>drop</strong></li>\n<li><strong>dragend</strong></li>\n</ul>\n<p>拖拽事件的具体用法可参考我的另一篇笔记：<a href=\"http://www.dengzhr.com/frontend/html/927\">http://www.dengzhr.com/frontend/html/927</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/945\">http://www.dengzhr.com/js/945</a></div>\n\n        ','2','1'),(257,'学习笔记：Video和Audio API','\n\n            <h2>一. 媒体元素</h2>\n<p><code><audio></code>标签：嵌入音频内容；</p>\n<p><code><video></code>标签：嵌入视频内容。</p>\n<p>这两个元素的用法如下：</p>\n<pre><code><!-- 嵌入视频 -->\n<video src=\"test.mp4\">Video player not available.</video>\n\n<!-- 嵌入音频 -->\n<audio src=\"test.mp3\">Audio player </code></pre>…\n        ','2019-08-05 08:04:47','0000-00-00 00:00:00',3,'1','\n\n            <h2><a id=\"_4\"></a>一. 媒体元素</h2>\n<p><code><audio></code>标签：嵌入音频内容；</p>\n<p><code><video></code>标签：嵌入视频内容。</p>\n<p>这两个元素的用法如下：</p>\n<pre><code><!-- 嵌入视频 -->\n<video src=\"test.mp4\">Video player not available.</video>\n\n<!-- 嵌入音频 -->\n<audio src=\"test.mp3\">Audio player not available.</audio>\n</code></pre>\n<p>使用这两个元素时，至少要在标签中包含src属性，指向要加载的媒体文件。还可以设置width和height属性，以指定视频播放器的大小。</p>\n<p>位于开始和结束标签的任何内容都将作为后备内容，在浏览器不支持这两个媒体元素的情况下显示。</p>\n<p>因为并非所有浏览器都支持所有媒体格式，所以可以指定多个不同的媒体来源。为此需要使用一或多个<code><source></code>元素。</p>\n<pre><code><!-- 嵌入视频 -->\n<video>\n    <source src=\"test.webm\" type=\"video/webm; codecs=\'vp8, vorbis\'\">\n    <source src=\"test.ogv\" type=\"video/ogg; codecs=\'theora, vorbis\'\">\n    <source src=\"test.mpg\">\n    Video player not available.\n</video>\n\n<!-- 嵌入音频 -->\n<audio src=\"test.mp3\">\n    <source src=\"test.ogg\" type=\"audio/ogg\">\n    <source src=\"test.mp3\" type=\"audio/mpeg\">\n    Audio player not available.\n</audio>\n</code></pre>\n<h2><a id=\"_5\"></a>二. 音频和视频的格式支持情况：</h2>\n<h3><a id=\"_6\"></a>2.1 音频</h3>\n<table>\n<thead>\n<tr>\n<th>音频</th>\n<th>字符串</th>\n<th>支持的浏览器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AAC</td>\n<td>audio/mp4; codecs=”mp4a.40.2″</td>\n<td>IE9+、Safari 4+、iOS版Safari</td>\n</tr>\n<tr>\n<td>MP3</td>\n<td>audio/mpeg</td>\n<td>IE9+、Chrome</td>\n</tr>\n<tr>\n<td>Vorbis</td>\n<td>audio/ogg; codecs=”vorbis”</td>\n<td>Firefox 3.5+、Chrome、Opera 10.5+</td>\n</tr>\n<tr>\n<td>WAV</td>\n<td>audio/wav; codecs=”1″</td>\n<td>Firefox 3.5+、Opera 10.5+、Chrome</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"_7\"></a>2.2 视频</h3>\n<table>\n<thead>\n<tr>\n<th>视频</th>\n<th>字符串</th>\n<th>支持的浏览器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>H.264</td>\n<td>video/mp4; codecs=”avc1.42E01E, mp4a.40.2″</td>\n<td>IE9+、Safari 4+、iOS版Safari、Android版Webkit</td>\n</tr>\n<tr>\n<td>Theora</td>\n<td>video/ogg; codecs=”theora”</td>\n<td>Firefox 3.5+、Opera 10.5、Chrome</td>\n</tr>\n<tr>\n<td>WebM</td>\n<td>video/webm; codes=”vp8, vorbis”</td>\n<td>Firefox 4+、Opera 10.6、Chrome</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_8\"></a>三. <code><video></video></code>和<code><audio></audio></code>的属性：</h2>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>数据类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>autoplay</td>\n<td>Boolean</td>\n<td>是否自动播放</td>\n</tr>\n<tr>\n<td>buffered</td>\n<td>时间范围</td>\n<td>表示已下载的缓冲的时间范围的对象</td>\n</tr>\n<tr>\n<td>bufferedBytes</td>\n<td>字节范围</td>\n<td>表示已下载的缓冲的字节范围的对象</td>\n</tr>\n<tr>\n<td>bufferingRate</td>\n<td>Int</td>\n<td>下载过程中每秒中平均接收到的位数</td>\n</tr>\n<tr>\n<td>bufferingThrottled</td>\n<td>Boolean</td>\n<td>表示浏览器是否对缓冲进行了节流</td>\n</tr>\n<tr>\n<td>controls</td>\n<td>Boolean</td>\n<td>是否显示或隐藏浏览器内置的控件</td>\n</tr>\n<tr>\n<td>currentLoop</td>\n<td>Int</td>\n<td>媒体文件已经循环的次数</td>\n</tr>\n<tr>\n<td>currentSrc</td>\n<td>String</td>\n<td>当前播放的媒体文件的URL</td>\n</tr>\n<tr>\n<td>currentTime</td>\n<td>Float</td>\n<td>已经播放的秒数</td>\n</tr>\n<tr>\n<td>defaultPlaybackRate</td>\n<td>Float</td>\n<td>取得或设置默认的播放速度。默认值为1.0</td>\n</tr>\n<tr>\n<td>duration</td>\n<td>Float</td>\n<td>媒体的总播放时间（秒数）</td>\n</tr>\n<tr>\n<td>ended</td>\n<td>Boolean</td>\n<td>表示媒体文件是否播放完成</td>\n</tr>\n<tr>\n<td>loop</td>\n<td>Boolean</td>\n<td>取得或设置媒体文件咋播放完成后是否再从头开始播放</td>\n</tr>\n<tr>\n<td>muted</td>\n<td>Boolean</td>\n<td>取得或设置媒体文件是否静音</td>\n</tr>\n<tr>\n<td>networkState</td>\n<td>Int</td>\n<td>表示当前媒体的网络连接状态：0表示空； 1表示正在加载； 2表示正在加载元数据； 3表示已经加载了第一帧； 4表示加载完成</td>\n</tr>\n<tr>\n<td>paused</td>\n<td>Boolean</td>\n<td>表示播放器是否暂停</td>\n</tr>\n<tr>\n<td>playbackRate</td>\n<td>Float</td>\n<td>取得或设置当前的播放速度。</td>\n</tr>\n<tr>\n<td>played</td>\n<td>时间范围</td>\n<td>到目前为止已经播放的时间范围</td>\n</tr>\n<tr>\n<td>readyState</td>\n<td>Int</td>\n<td>表示媒体文件是否可以播放。0表示数据不可用；1表示可以显示当前帧；2表示可以开始播放；3表示媒体可以从头到尾播放可以搜索的时间范围</td>\n</tr>\n<tr>\n<td>seekable</td>\n<td>时间范围</td>\n<td>可以搜索的时间范围</td>\n</tr>\n<tr>\n<td>seeking</td>\n<td>Boolean</td>\n<td>表示播放器是否正移动到媒体文件中的新位置</td>\n</tr>\n<tr>\n<td>src</td>\n<td>String</td>\n<td>媒体文件的来源</td>\n</tr>\n<tr>\n<td>start</td>\n<td>Float</td>\n<td>取得或设置媒体文件中开始播放的位置，以秒表示</td>\n</tr>\n<tr>\n<td>totalBytes</td>\n<td>Int</td>\n<td>当前资源所需的总字节数</td>\n</tr>\n<tr>\n<td>videoHeight</td>\n<td>Int</td>\n<td>返回视频高度。（只适用于<code><video></code>）</td>\n</tr>\n<tr>\n<td>videoWidth</td>\n<td>Int</td>\n<td>返回视频宽度。（只适用于<code><video></code>）</td>\n</tr>\n<tr>\n<td>volume</td>\n<td>Float</td>\n<td>取得或设置当前音量。值为0到1</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_9\"></a>四. <code><video></video></code>和<code><audio></audio></code>的事件：</h2>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>abort</td>\n<td>下载中断</td>\n</tr>\n<tr>\n<td>canplay</td>\n<td>可以播放时。readyState值为2</td>\n</tr>\n<tr>\n<td>canplaythrough</td>\n<td>播放可以继续，而且应该不会中断；readyState值为3</td>\n</tr>\n<tr>\n<td>canshowcurrentframe</td>\n<td>当前帧已经下载完成。readyState值为1</td>\n</tr>\n<tr>\n<td>dataunavailable</td>\n<td>因为没有数据而不能播放。readyState值为0</td>\n</tr>\n<tr>\n<td>durationchange</td>\n<td>duration属性的值改变</td>\n</tr>\n<tr>\n<td>emptied</td>\n<td>网络连接关闭</td>\n</tr>\n<tr>\n<td>empty</td>\n<td>发生错误阻止了媒体下载</td>\n</tr>\n<tr>\n<td>ended</td>\n<td>媒体已播放到末尾，播放停止</td>\n</tr>\n<tr>\n<td>error</td>\n<td>下载期间发生网络错误</td>\n</tr>\n<tr>\n<td>load</td>\n<td>所有媒体已加载完成。</td>\n</tr>\n<tr>\n<td>loadeddata</td>\n<td>媒体的第一帧已加载完成</td>\n</tr>\n<tr>\n<td>loadedmetadata</td>\n<td>媒体的元数据已加载完成</td>\n</tr>\n<tr>\n<td>loadstart</td>\n<td>下载已开始</td>\n</tr>\n<tr>\n<td>pause</td>\n<td>播放已暂停</td>\n</tr>\n<tr>\n<td>play</td>\n<td>媒体已到指令开始播放</td>\n</tr>\n<tr>\n<td>playing</td>\n<td>媒体已实际开始播放</td>\n</tr>\n<tr>\n<td>progress</td>\n<td>正在下载</td>\n</tr>\n<tr>\n<td>ratechange</td>\n<td>播放媒体的速度改变</td>\n</tr>\n<tr>\n<td>seeked</td>\n<td>搜索结束</td>\n</tr>\n<tr>\n<td>seeking</td>\n<td>正移动到新位置</td>\n</tr>\n<tr>\n<td>stalled</td>\n<td>浏览器尝试下载，但未接收到数据</td>\n</tr>\n<tr>\n<td>timeupdate</td>\n<td>currentTime被以不合理或意外的方式更新</td>\n</tr>\n<tr>\n<td>volumechange</td>\n<td>volume属性值或muted属性值已改变</td>\n</tr>\n<tr>\n<td>waiting</td>\n<td>播放暂停，等待下载更多数据</td>\n</tr>\n</tbody>\n</table>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1020\">http://www.dengzhr.com/js/1020</a></div>\n\n        ','2','1'),(258,'学习笔记：JavaScript数组的语法','\n\n            <h2>一. 获取数组长度</h2>\n<blockquote>\n<ul>\n<li>array.length</li>\n</ul>\n</blockquote>\n<h2>二. 检测数组</h2>\n<p>方法一：使用instanceof检测：</p>\n<pre><code>if(array instanceof Array) {\n    // 进行数组操作\n}\n</code></pre>\n<p>方法二：使用isArray()方法：</p>\n<pre><code>if(Array.isArray(array)) {\n    // 进行数组操作\n}\n</code></pre>\n<h2>三. 转换为字符串</h2>\n<blockquote>\n<ul>\n<li>toLocaleString()</li>\n<li>toString()</li>\n<li>valueOf()</li>\n</ul>\n</blockquote>\n<h2>四. 向数组中插入或删除元素</h2>\n<p>栈方法(Last in First…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 获取数组长度</h2>\n<blockquote>\n<ul>\n<li>array.length</li>\n</ul>\n</blockquote>\n<h2><a id=\"_5\"></a>二. 检测数组</h2>\n<p>方法一：使用instanceof检测：</p>\n<pre><code>if(array instanceof Array) {\n    // 进行数组操作\n}\n</code></pre>\n<p>方法二：使用isArray()方法：</p>\n<pre><code>if(Array.isArray(array)) {\n    // 进行数组操作\n}\n</code></pre>\n<h2><a id=\"_6\"></a>三. 转换为字符串</h2>\n<blockquote>\n<ul>\n<li>toLocaleString()</li>\n<li>toString()</li>\n<li>valueOf()</li>\n</ul>\n</blockquote>\n<h2><a id=\"_7\"></a>四. 向数组中插入或删除元素</h2>\n<p>栈方法(Last in First out)：</p>\n<blockquote>\n<ul>\n<li><strong>push()</strong> ：将新元素插入到数组的尾部</li>\n<li><strong>pop()</strong> ：删除最后一个元素</li>\n</ul>\n</blockquote>\n<p>堆方法(First in First out):</p>\n<blockquote>\n<ul>\n<li><strong>shift()</strong> ：将新元素插入到数组的头部</li>\n<li><strong>unshift()</strong> ：删除第一个元素</li>\n</ul>\n</blockquote>\n<h2><a id=\"_8\"></a>五. 数组重排方法</h2>\n<blockquote>\n<ul>\n<li><strong>array.sort()</strong> ： 正向排序</li>\n<li><strong>array.reverse()</strong> ： 反向排序</li>\n</ul>\n</blockquote>\n<h2><a id=\"_9\"></a>六. 合并数组</h2>\n<p>语法：</p>\n<pre><code>array.concat(anotherArray);\n</code></pre>\n<p>如果传递的是一个或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。</p>\n<h2><a id=\"_10\"></a>七. 截取，获得新数组</h2>\n<p>语法：</p>\n<pre><code>array.slice(起始位置[， 结束位置]);\n</code></pre>\n<p>slice()方法接受一或两个参数，即要返回项的起始和结束位置。</p>\n<p>在只有一个参数的情况下，slice()会返回从该参数指定位置开始到当前数组末尾的所有项。slice()不会影响原始数组。</p>\n<h2><a id=\"_11\"></a>八. 向数组中部插入数据：splice()</h2>\n<p>语法：</p>\n<pre><code>array.splice(起始位置， 删除的项数， [要插入的多个项]);\n</code></pre>\n<h3><a id=\"_12\"></a>8.1 删除：</h3>\n<p>可以删除任意数量的项，需要指定前两个参数。譬如:splice(0, 2);</p>\n<h3><a id=\"_13\"></a>8.2 插入：</h3>\n<p>只需提供3个参数：起始位置、 删除的项数(0)、 要插入的多个项。 譬如：splice(1, 0, “hello”, “world”);</p>\n<h3><a id=\"_14\"></a>8.3 替换：</h3>\n<p>可以向指定位置插入任意数量的项。需要提供三个参数。 splice()会返回一个数组，该数组包含从原始数组中删除的项（如果没有删除的项，则返回一个空数组）。</p>\n<h2><a id=\"_15\"></a>九. 位置方法</h2>\n<blockquote>\n<ul>\n<li><strong>indexOf()</strong> ： 元素在数组中的索引</li>\n<li><strong>lastIndexOf()</strong> ： 元素在数组中的反向索引</li>\n</ul>\n</blockquote>\n<p>这两个方法都接受两个参数：要查找的项和(可选的)表示查找起点位置的索引。</p>\n<p>这两个方法都返回要查找的项在数组中的位置，在没找到的情况下返回-1。</p>\n<p>兼容性：IE9+支持。</p>\n<h2><a id=\"_16\"></a>十. 迭代方法</h2>\n<blockquote>\n<ul>\n<li><strong>every()</strong>：如果该函数对每一项都返回true，则返回true；</li>\n<li><strong>filter()</strong>：返回该函数会返回true的项组成的数组；</li>\n<li><strong>forEach()</strong>：没有返回值；</li>\n<li><strong>map()</strong>：返回每次函数调用的结果组成的数组；</li>\n<li><strong>some()</strong>：如果该函数对任一项返回true，则返回true；</li>\n</ul>\n</blockquote>\n<p>以上5个方法中每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。</p>\n<p>传入这些方法的函数会接收3个参数：数组项的值、该项在数组中的位置和数组对象本身。</p>\n<p>兼容性：IE9+</p>\n<h2><a id=\"_17\"></a>十一. 归并方法</h2>\n<blockquote>\n<ul>\n<li><strong>reduce()</strong>：从数组的第一项开始，逐个遍历到最后。</li>\n<li><strong>reduceRight()</strong>：从数组的最后一项开始，向前遍历到第一项。</li>\n</ul>\n</blockquote>\n<p>作用：迭代数组的所有项，然后构建一个最终返回的值。</p>\n<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</p>\n<p>兼容性：IE9+</p>\n<p>具体实践可参考：<a href=\"http://www.dengzhr.com/js/411\">http://www.dengzhr.com/js/411</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1075\">http://www.dengzhr.com/js/1075</a></div>\n\n        ','2','1'),(259,'HTML5 拖放API 学习笔记整理','\n\n            <p>在HTML5推出拖放API之前，我们想要实现拖拽效果，一般都是使用mousedown、mousemove、mouseup鼠标事件监听来模拟出拖拽效果，代码量大，而且由于为了实时的拖拽效果而需要不断获取鼠标坐标位置和修改元素的位置，导致性能较差。而HTML5提供了原生的拖放API，无疑简单很多，而且性能较好。</p>\n<p>HTML5的拖放API的兼容性如下：</p>\n<p><a href=\"http://caniuse.com/#feat=dragndrop\">http://caniuse.com/#feat=dragndrop</a>…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在HTML5推出拖放API之前，我们想要实现拖拽效果，一般都是使用mousedown、mousemove、mouseup鼠标事件监听来模拟出拖拽效果，代码量大，而且由于为了实时的拖拽效果而需要不断获取鼠标坐标位置和修改元素的位置，导致性能较差。而HTML5提供了原生的拖放API，无疑简单很多，而且性能较好。</p>\n<p>HTML5的拖放API的兼容性如下：</p>\n<p><a href=\"http://caniuse.com/#feat=dragndrop\">http://caniuse.com/#feat=dragndrop</a></p>\n<p>截图如下：</p>\n<p><img src=\"http://www.dengzhr.com/wp-content/uploads/2015/09/drag-and-drop.png\" alt=\"此处输入图片的描述\"></p>\n<h2><a id=\"_4\"></a>一. HTML5拖放事件处理的一般步骤</h2>\n<p>实现拖放一般步骤如下：</p>\n<p>(1) 给被拖拽元素添加draggable属性；（dragable = \"true\"）</p>\n<pre><code class=\"lang-html\"><div id=\"source\" draggable=\"true\">source</div>\n</code></pre>\n<p>(2) 为目标元素添加一个dropzone属性；（可选）</p>\n<pre><code class=\"lang-html\"><div id=\"divDropZone\" dropzone=\"copy\"></div>\n</code></pre>\n<p>(3) 在拖拽元素的dragstart初始化相关的数据信息，主要是DataTransfer对象；</p>\n<pre><code class=\"lang-javascript\">source.ondragstart = function(e){\n    e.dataTransfer.setData(\'test\', \'testData\');\n};\n</code></pre>\n<p>(4) 在目标元素的dragover事件中，取消其默认操作；</p>\n<pre><code class=\"lang-javascript\">target.ondragover = function(e){\n    e.preventDefault(); \n};\n</code></pre>\n<p>(5) 在目标元素的drop事件中，处理接收到的数据；</p>\n<pre><code class=\"lang-javascript\">target.ondrop = function(e){\n    e.preventDefault();\n    var elem = document.createElement(\'p\');\n    elem.innerHTML = e.dataTransfer.getData(\'test\');\n    e.target.appendChild(elem);\n};\n</code></pre>\n<p>(6) 在被拖拽元素的dragend事件中，做善后工作；（可选）</p>\n<p>如：</p>\n<pre><code class=\"lang-html\"><!DOCTYPE html>\n<html>\n<head>\n    <title>HTML5 拖拽</title>\n    <style>\n        #source{width:200px;height:200px;border:1px solid red;}\n        #target{width:200px;height:200px;border:1px solid blue;}\n    </style>\n</head>\n<body>\n<div id=\"source\" draggable=\"true\">source</div>\n<div id=\"target\">target</div>\n\n<script>\n    var target = document.getElementById(\'target\');\n    var source = document.getElementById(\'source\');\n    source.ondragstart = function(e){\n        e.dataTransfer.effectAllowed = \'copyMove\';\n        e.dataTransfer.setData(\'test\', \'testData\');\n    };\n    target.ondragover = function(e){\n        e.dataTransfer.dropEffect = \'move\';\n        e.preventDefault(); // 阻止默认行为\n    };\n    target.ondrop = function(e){\n        e.preventDefault();\n        var elem = document.createElement(\'p\');\n        elem.innerHTML = e.dataTransfer.getData(\'test\');\n        e.target.appendChild(elem);\n    };\n</script>\n</body>\n</html>\n</code></pre>\n<h2><a id=\"_5\"></a>二. 可拖动属性 —— draggable</h2>\n<p>HTML5为所有HTML元素规定了一个draggable属性，控制元素是否可以拖动。图像、链接和被选中的文本的draggable属性默认为true，其他元素默认为false。</p>\n<p>draggable属性的值如下：</p>\n<table>\n<thead>\n<tr>\n<th>属性值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>true</td>\n<td>内容可被拖动。</td>\n</tr>\n<tr>\n<td>false</td>\n<td>内容不可被拖动。</td>\n</tr>\n<tr>\n<td>auto</td>\n<td>内容执行默认的浏览器行为（图像、链接和被选中的文本可被拖动，其他元素不能）</td>\n</tr>\n</tbody>\n</table>\n<p>支持 draggable 属性的浏览器有： IE9+、FF4+、Safari 5+、Chrome、Opera 12+。Opera 11.5- 不支持拖放功能。</p>\n<p>draggable属性的兼容性处理：</p>\n<p>(1) Firefox：需要添加ondragstart事件处理程序，并在dataTransfer中保存一些信息；</p>\n<p>(2) IE9-通过mousedown事件调用dragDrop()能够让任何元素可拖动；</p>\n<p>(3) Safari 4- 必须给相应元素设置 CSS 样式：</p>\n<pre><code class=\"lang-css\">*[draggable = true] {\n    -khtml-user-drag: element;\n}\n</code></pre>\n<h2><a id=\"_6\"></a>三. 放置目标元素属性 —— dropzone</h2>\n<p>dropzone可以创建一个放置区域。</p>\n<table>\n<thead>\n<tr>\n<th>属性值</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>copy</td>\n<td>表示将允许的元素放到该元素上时，会将拖拽数据复制到目标元素上。</td>\n</tr>\n<tr>\n<td>move</td>\n<td>表示将允许的元素放到该元素上时，会将数据移动到目标元素上。</td>\n</tr>\n<tr>\n<td>link</td>\n<td>表示将允许的元素放到该元素上时，将链接数据到目标元素上。</td>\n</tr>\n</tbody>\n</table>\n<p>dropzone属性可以使用过滤器（filter），如：f:/img/png 表明只有png格式的图片文件才可以放置在此区域。</p>\n<h2><a id=\"_7\"></a>四. 拖放事件</h2>\n<p>拖放事件触发次序：</p>\n<p>dragstart -> drag -> dragenter -> dragover -> dragleave -> drop -> dragend。</p>\n<h3><a id=\"_8\"></a>4.1 被拖动元素事件</h3>\n<p>拖动某元素时，将依次触发以下事件：</p>\n<p>dragstart：按下鼠鼠标键并开始移动时，被拖动元素上触发 dragstart 事件；</p>\n<p>drag：触发 dragstart 事件后，随即触发 drag 事件，而且元素拖动期间会持续触发该事件；</p>\n<p>dragend：拖动停止时（释放鼠标、无论放置目标是否有效）触发 dragend 事件；</p>\n<h3><a id=\"_9\"></a>4.2 放置目标元素事件</h3>\n<p>当某个元素被拖动到一个有效的放置目标元素时，依次触发下列事件：</p>\n<p>dragenter：元素进入到目标元素上时触发事件；</p>\n<p>dragover：紧随 dragover 事件，被拖动元素在目标元素范围内移动时会持续触发该事件；</p>\n<p>dragleave 或 drop：元素拖出了放置目标，则 dragover 事件不再发生，触发 dragleave 事件；如果被拖元素放到了目标元素上，则触发 drop 事件；</p>\n<h3><a id=\"_10\"></a>4.3 自定义放置目标</h3>\n<p>所有元素都支持放置目标事件，但多数元素默认是不允许放置的。重写 dragenter 和 dragover 事件的默认行为，可以把任何元素变成有效的放置目标。</p>\n<pre><code class=\"lang-javascript\">dropArea.addEventListener(\"dragenter\", preventDefault(event), false);  \ndropArea.addEventListener(\"dragover\", preventDefault(event), false);\n\n// 阻止 Firefox 打开 URL\ndropArea.addEventListener(\"drop\", preventDefault(event), false);\n\n// 阻止默认事件和事件冒泡\nfunction preventDefault(event) { \n    event = event || window.event;\n    event.stopPropagation();\n    event.preventDefault();\n}\n</code></pre>\n<p>Firefox 3.5+ 中，放置事件的默认行为是打开放到目标上的URL。如果是图像则打开图像，如果是文本则会导致无效 URL 错误（不安装拖拽插件的情况下）。所以还要取消 Firefox 中 drop 事件的默认行为，阻止它打开 URL。</p>\n<p><strong>注意1：</strong> drag和dragover是持续触发的。拖放文件到浏览器中时，需要在dragover和drop事件处理器中阻止默认行为（preventDefault()）。因为从其他应用软件或是文件中拖东西进入浏览器中，默认的行为是浏览器将当前页面重定向到被拖拽元素所指向的资源上。</p>\n<p><strong>注意2：</strong> 在被拖元素上触发dragstart事件后，则该元素的mousemove,mouseover,mouseenter,mouseleave,mouseout事件均不会被触发了。</p>\n<h2><a id=\"_11\"></a>五. dataTransfer对象</h2>\n<p>dataTransfer对象是拖放事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。</p>\n<h3><a id=\"_12\"></a>5.1 dataTransfer 对象的方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>clearData(format)</td>\n<td>清除以特定格式保存的数据 。</td>\n</tr>\n<tr>\n<td>getData(format)</td>\n<td>从 dataTransfer 对象中读取指定类型的值，参数是 MIME 类型。</td>\n</tr>\n<tr>\n<td>setData(format, data)</td>\n<td>为 dataTransfer 对象指定特定格式的数据，这些数据只能在 ondrop 处理程序中读取。</td>\n</tr>\n<tr>\n<td>setDragImage(element, x, y)</td>\n<td>指定一个元素拖动发生时显示在光标下方，三个参数分别是要显示的 HTML元素和光标在显示元素中的x、y坐标。</td>\n</tr>\n<tr>\n<td>addElement(element)</td>\n<td>为拖动操作添加一个元素（即增加作为拖动源而响应的回调对象）。如果想要让某个元素跟随被拖拽元素一同被拖拽，可使用该方法。</td>\n</tr>\n</tbody>\n</table>\n<p>IE只定义了“text”和“URL”两种有效的数据类型，而HTML5则对此加以扩展，允许指定各种MIME类型。考虑到向后兼容，HTML5也支持“text”和“URL”，但这两种类型会被映射为“text/plain”和“text/uri-list”。如下所示：</p>\n<p>text/html：文本文字格式；</p>\n<p>text/plain：HTML代码格式；</p>\n<p>text/xml：XML字符格式；</p>\n<p>text/url-list：URL格式列表；</p>\n<p>Firefox在其第5个版本之前不能正确地将“URL”和“text”映射为“text/uri-list”和“text/plain”。但是却能把“Text”映射为“text/plain”。为了更好地在跨浏览器的情况下从dataTransfer对象取得数据，最好在取得URL数据时检测两个值，而在取得文本数据时使用“text”。</p>\n<pre><code class=\"lang-javascript\">var dataTransfer = event.dataTransfer; \n//读取URL \nvar url = dataTransfer.getData(\"url\") || dataTransfer.getData(\"text/uri-list\"); \n//读取文本 \nvar text = dataTransfer.getData(\"Text\");\n</code></pre>\n<h3><a id=\"_13\"></a>5.2 dataTransfer对象的属性</h3>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dropEffect</td>\n<td>获取或设置被拖动元素能够执行哪中放置行为，不同的行为显示相应的光标。</td>\n</tr>\n<tr>\n<td>effectAllowed</td>\n<td>表示允许拖动元素的哪种 dropEffect。</td>\n</tr>\n<tr>\n<td>files</td>\n<td>返回被拖放文件的FileList对象。</td>\n</tr>\n<tr>\n<td>types</td>\n<td>返回ondragstart事件中传递的数据类型的类似数组的集合。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>dropEffect的属性值分别有：</strong></p>\n<p>(1) none：不能放置拖动元素（除文本框以外所有元素的默认值）； </p>\n<p>(2) move：应该把元素移动到放置目标； </p>\n<p>(3) copy：应该把拖动元素复制到放置目标；</p>\n<p>(4) link：应该在放置目标上打开拖动元素（拖动元素必须是有 URL 的链接）。</p>\n<p><strong>effectAllowed的属性值分别有：</strong></p>\n<p>(1) uninitialized：被拖动元素没有设置放置行为； </p>\n<p>(2) none：被拖动元素不允许有任何行为； </p>\n<p>(3) copy：只允许 copy 值的 dropEffect； </p>\n<p>(4) move：只允许 move 值的 dropEffect；</p>\n<p>(5) copeLink：copy 和 link 值的 dropEffect；</p>\n<p>(6) copeMove：copy 和 move 值的 dropEffect；</p>\n<p>(7) linkMove：link 和 move 值的 dropEffect； </p>\n<p>(8) all：允许任意 dropEffect。</p>\n<p>使用dropEffect属性时必须在ondragenter中针对放置目标设置，只有搭配effectAllowed属性时才有用。必须在ondragstart中设置 effectAllowed。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/535\">http://www.dengzhr.com/frontend/html/535</a></div>\n\n        ','2','1'),(261,'cookie的增删改操作','\n\n            <p>cookie的接口封装如下：</p>\n<pre><code>// 设置cookie\nfunction setcookie(name, value, days) {\n    var date=new Date();\n    date.setDate(date.getDate()+days);\n    document.cookie=name+\'=\'+value+\';expires=\'+date;\n}\n</code></pre>\n<pre><code>// 获取cookie\nfunction getcookie(name) {\n     var arr=document.cookie.split(\';\');</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>cookie的接口封装如下：</p>\n<pre><code>// 设置cookie\nfunction setcookie(name, value, days) {\n    var date=new Date();\n    date.setDate(date.getDate()+days);\n    document.cookie=name+\'=\'+value+\';expires=\'+date;\n}\n</code></pre>\n<pre><code>// 获取cookie\nfunction getcookie(name) {\n     var arr=document.cookie.split(\';\');\n     for(var i=0;i<arr.length;i++) {\n         var arr2=arr[i].split(\'=\');\n         if(arr2[0]==name)return arr2[1];\n     }\n     return \'\';\n}\n</code></pre>\n<pre><code>// 删除cookie\nfunction removecookie(name) {\n    setcookie(name,\'1\',-1);\n}\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1010\">http://www.dengzhr.com/js/1010</a></div>\n\n        ','2','1'),(262,'javascript获取以及设置光标位置','\n\n            <h2>一. 获取光标位置：</h2>\n<pre><code>// 获取光标位置\nfunction getCursortPosition (textDom) {\n    var cursorPos = 0;\n    if (document.selection) {\n        // IE Support\n        textDom.focus ();\n        var selectRange = document.selection.createRange();\n        selectRange.moveStart (\'character\', </code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 获取光标位置：</h2>\n<pre><code>// 获取光标位置\nfunction getCursortPosition (textDom) {\n    var cursorPos = 0;\n    if (document.selection) {\n        // IE Support\n        textDom.focus ();\n        var selectRange = document.selection.createRange();\n        selectRange.moveStart (\'character\', -textDom.value.length);\n        cursorPos = selectRange.text.length;\n    }else if (textDom.selectionStart || textDom.selectionStart == \'0\') {\n        // Firefox support\n        cursorPos = textDom.selectionStart;\n    }\n    return cursorPos;\n}\n</code></pre>\n<h2><a id=\"_5\"></a>二. 设置光标位置：</h2>\n<pre><code>// 设置光标位置\nfunction setCaretPosition(textDom, pos){\n    if(textDom.setSelectionRange) {\n        // IE Support\n        textDom.focus();\n        textDom.setSelectionRange(pos, pos);\n    }else if (textDom.createTextRange) {\n        // Firefox support\n        var range = textDom.createTextRange();\n        range.collapse(true);\n        range.moveEnd(\'character\', pos);\n        range.moveStart(\'character\', pos);\n        range.select();\n    }\n}\n</code></pre>\n<h2><a id=\"_6\"></a>三. 获取选中文字：</h2>\n<pre><code>// 获取选中文字\nfunction getSelectText() {\n    var userSelection, text;\n    if (window.getSelection) {\n        // Firefox support\n        userSelection = window.getSelection();\n    } else if (document.selection) {\n        // IE Support\n        userSelection = document.selection.createRange();\n    }\n    if (!(text = userSelection.text)) {\n        text = userSelection;\n    }\n    return text;\n}\n</code></pre>\n<h2><a id=\"_7\"></a>四. 选中特定范围的文本：</h2>\n<pre><code>/**\n* 选中特定范围的文本\n* 参数：\n*     textDom  [JavaScript DOM String] 当前对象\n*     startPos  [Int]  起始位置\n*     endPos  [Int]  终点位置\n*/\nfunction setSelectText(textDom, startPos, endPos) {\n    var startPos = parseInt(startPos),\n        endPos = parseInt(endPos),\n        textLength = textDom.value.length;\n    if(textLength){\n        if(!startPos){\n            startPos = 0;\n        }\n        if(!endPos){\n            endPos = textLength;\n        }\n        if(startPos > textLength){\n            startPos = textLength;\n        }\n        if(endPos > textLength){\n            endPos = textLength;\n        }\n        if(startPos < 0){\n            startPos = textLength + startPos;\n        }\n        if(endPos < 0){\n            endPos = textLength + endPos;\n        }\n        if(textDom.createTextRange){\n            // IE Support\n            var range = textDom.createTextRange();\n            range.moveStart(\"character\",-textLength);\n            range.moveEnd(\"character\",-textLength);\n            range.moveStart(\"character\", startPos);\n            range.moveEnd(\"character\",endPos);\n            range.select();\n        }else{\n            // Firefox support\n            textDom.setSelectionRange(startPos, endPos);\n            textDom.focus();\n        }\n    }\n}\n</code></pre>\n<h2><a id=\"_8\"></a>五. 在光标后插入文本：</h2>\n<pre><code>/**\n* 在光标后插入文本\n* 参数：\n*     textDom  [JavaScript DOM String] 当前对象\n*     value  [String]  要插入的文本\n*/\nfunction insertAfterText(textDom, value) {\n    var selectRange;\n    if (document.selection) {\n        // IE Support\n        textDom.focus();\n        selectRange = document.selection.createRange();\n        selectRange.text = value;\n        textDom.focus();\n    }else if (textDom.selectionStart || textDom.selectionStart == \'0\') {\n        // Firefox support\n        var startPos = textDom.selectionStart;\n        var endPos = textDom.selectionEnd;\n        var scrollTop = textDom.scrollTop;\n        textDom.value = textDom.value.substring(0, startPos) + value + textDom.value.substring(endPos, textDom.value.length);\n        textDom.focus();\n        textDom.selectionStart = startPos + value.length;\n        textDom.selectionEnd = startPos + value.length;\n        textDom.scrollTop = scrollTop;\n    }\n    else {\n        textDom.value += value;\n        textDom.focus();\n    }\n}\n</code></pre>\n<h2><a id=\"_9\"></a>六. 参考：</h2>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2011/04/js-range-html%E6%96%87%E6%A1%A3%E6%96%87%E5%AD%97%E5%86%85%E5%AE%B9%E9%80%89%E4%B8%AD%E3%80%81%E5%BA%93%E5%8F%8A%E5%BA%94%E7%94%A8%E4%BB%8B%E7%BB%8D/\">JS Range HTML文档/文字内容选中、库及应用介绍 —— 张鑫旭</a></p>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2010/04/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E6%8F%92%E5%85%A5%E8%AF%9D%E9%A2%98%E5%90%8E%E9%83%A8%E5%88%86%E6%96%87%E5%AD%97%E9%80%89%E4%B8%AD%E7%9A%84js%E5%AE%9E%E7%8E%B0/\">新浪微博插入话题后部分文字选中的js实现</a></p>\n<p><a href=\"http://js8.in/2010/01/29/javascript%E8%8E%B7%E5%8F%96%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E8%AE%BE%E7%BD%AE%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE/\">javascript获取光标位置以及设置光标位置</a></p>\n<p><a href=\"http://js8.in/2010/05/13/javascript%E5%9C%A8%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%86%85%E5%AE%B9/\">javascript在光标位置插入内容</a></p>\n<p><a href=\"http://www.quirksmode.org/dom/range_intro.html\">Introduction to Range</a></p>\n<p><a href=\"http://www.quirksmode.org/dom/w3c_range.html\">W3C DOM Compatibility – Range</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1013\">http://www.dengzhr.com/js/1013</a></div>\n\n        ','2','1'),(263,'canvas中的三角运动（5） —— 圆周运动和椭圆运动','\n\n            <h2>一. 圆周运动</h2>\n<h3>1.1 思路分析：</h3>\n<p>圆的方程为：</p>\n<pre><code>// (x0, y0)为圆心位置；(x, y)为圆上的点\n(x - x0) ^ 2 + (y - y0) ^ 2 = r ^ 2\ncos(angle) ^ 2 + sin(angle) ^ 2 = 1\n</code></pre>\n<p>因此，综合以上两式，可得：</p>\n<ul>\n<li><strong>x = r * cos(angle) + x0</strong></li>\n<li><strong>y = r * sin(angle) + y0</strong></li>\n</ul>\n<p>因此，应用正弦函数计算y坐标，用余弦函数计算x坐标。</p>\n<h2>1.2 实例：</h2>\n<pre><code>// cancelRequestAnimFrame的�</code></pre>…\n        ','2019-08-05 06:39:41','0000-00-00 00:00:00',1,'1','\n\n            <h2><a id=\"_4\"></a>一. 圆周运动</h2>\n<h3><a id=\"_5\"></a>1.1 思路分析：</h3>\n<p>圆的方程为：</p>\n<pre><code>// (x0, y0)为圆心位置；(x, y)为圆上的点\n(x - x0) ^ 2 + (y - y0) ^ 2 = r ^ 2\ncos(angle) ^ 2 + sin(angle) ^ 2 = 1\n</code></pre>\n<p>因此，综合以上两式，可得：</p>\n<ul>\n<li><strong>x = r * cos(angle) + x0</strong></li>\n<li><strong>y = r * sin(angle) + y0</strong></li>\n</ul>\n<p>因此，应用正弦函数计算y坐标，用余弦函数计算x坐标。</p>\n<h2><a id=\"_6\"></a>1.2 实例：</h2>\n<pre><code>// cancelRequestAnimFrame的兼容函数\nwindow.cancelRequestAnimFrame = ( function() {\n    return window.cancelAnimationFrame ||\n        window.webkitCancelRequestAnimationFrame ||\n        window.mozCancelRequestAnimationFrame ||\n        window.oCancelRequestAnimationFrame ||\n        window.msCancelRequestAnimationFrame ||\n        clearTimeout;\n} )();\n\nwindow.onload = function() {\n    var canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\"),\n        ball = new Ball(2),\n        angle = 0,\n        centerX = canvas.width / 2,\n        centerY = canvas.height / 2,\n        radius = 50,\n        speed = 0.05,\n        timer = null;\n\n        ball.lineWidth = 0;\n\n    (function drawFrame() {\n        timer = window.requestAnimationFrame(drawFrame, canvas);\n        if(angle > Math.PI * 2 && timer) {\n            window.cancelRequestAnimFrame(timer);\n            timer = null;\n        }\n        // context.clearRect(0, 0, canvas.width, canvas.height);\n        ball.y = centerY + Math.sin(angle) * radius;\n        ball.x = centerX + Math.cos(angle) * radius;\n        angle += speed;\n\n        ball.draw(context);\n    })();\n}\n</code></pre>\n<p>演示如下：<a href=\"http://codepen.io/dengzhirong/pen/akxQbx\">http://codepen.io/dengzhirong/pen/akxQbx</a></p>\n<p><iframe style=\"width: 100%;\" src=\"//codepen.io/dengzhirong/embed/akxQbx/?height=300&theme-id=15149&default-tab=result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong/pen/akxQbx/\">akxQbx</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong\">@dengzhirong</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n<h2><a id=\"_7\"></a>二. 椭圆运动</h2>\n<h3><a id=\"_8\"></a>2.1 思路分析：</h3>\n<p>椭圆的方程为：</p>\n<pre><code>// (x0, y0)为椭圆的圆心位置；(x, y)为椭圆上的点\n[(x - x0) / radiusX] ^ 2 + [(y - y0) / radiusY] ^ 2 = 1\ncos(angle) ^ 2 + sin(angle) ^ 2 = 1\n</code></pre>\n<p>因此，综合以上两式，可得：</p>\n<ul>\n<li><strong>x = radiusX * cos(angle) + x0</strong></li>\n<li><strong>y = radiusY * sin(angle) + y0</strong></li>\n</ul>\n<p>由此可得出椭圆运动的坐标值。</p>\n<h2><a id=\"_9\"></a>2.2 实例：</h2>\n<pre><code>// cancelRequestAnimFrame的兼容函数\nwindow.cancelRequestAnimFrame = ( function() {\n    return window.cancelAnimationFrame ||\n        window.webkitCancelRequestAnimationFrame ||\n        window.mozCancelRequestAnimationFrame ||\n        window.oCancelRequestAnimationFrame ||\n        window.msCancelRequestAnimationFrame ||\n        clearTimeout;\n} )();\n\nwindow.onload = function() {\n    var canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\"),\n        ball = new Ball(2),\n        angle = 0,\n        centerX = canvas.width / 2,\n        centerY = canvas.height / 2,\n        radiusX = 150,\n        radiusY = 100,\n        speed = 0.05,\n        timer = null;\n\n        ball.lineWidth = 0;\n\n    (function drawFrame() {\n        timer = window.requestAnimationFrame(drawFrame, canvas);\n        if(angle > Math.PI * 2 && timer) {\n            window.cancelRequestAnimFrame(timer);\n            timer = null;\n        }\n        // context.clearRect(0, 0, canvas.width, canvas.height);\n        ball.y = centerY + Math.sin(angle) * radiusY;\n        ball.x = centerX + Math.cos(angle) * radiusX;\n        angle += speed;\n\n        ball.draw(context);\n    })();\n}\n</code></pre>\n<p>演示如下：<a href=\"http://codepen.io/dengzhirong/pen/WxWYvX\">http://codepen.io/dengzhirong/pen/WxWYvX</a></p>\n<p><iframe style=\"width: 100%;\" src=\"//codepen.io/dengzhirong/embed/WxWYvX/?height=300&theme-id=15149&default-tab=result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong/pen/WxWYvX/\">WxWYvX</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong\">@dengzhirong</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/962\">http://www.dengzhr.com/js/962</a></div>\n\n        ','2','1'),(264,'canvas中的三角运动（3） —— 正弦波运动','\n\n            <h2>一. 需求：</h2>\n<p>要求：<strong>让小球沿着正弦波运动。</strong></p>\n<p>小球的构造函数如下：</p>\n<pre><code>// 圆球的构造函数\nfunction Ball(radius, color) {\n    if(radius === undefined) { radius = 40; }\n    if(color === undefined) { color = \"#ff0000\"; }\n    this.x = 0;\n    this.y = 0;\n    this.radius = radius;\n    this.rotation = 0;\n    this.scaleX</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 需求：</h2>\n<p>要求：<strong>让小球沿着正弦波运动。</strong></p>\n<p>小球的构造函数如下：</p>\n<pre><code>// 圆球的构造函数\nfunction Ball(radius, color) {\n    if(radius === undefined) { radius = 40; }\n    if(color === undefined) { color = \"#ff0000\"; }\n    this.x = 0;\n    this.y = 0;\n    this.radius = radius;\n    this.rotation = 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.color = color;\n    this.lineWidth = 1;\n}\nBall.prototype.draw = function(context) {\n    context.save();\n    context.translate(this.x, this.y);\n    context.rotate(this.rotation);\n    context.scale(this.scaleX, this.scaleY);\n    context.lineWidth = this.lineWidth;\n    context.fillStyle = this.color;\n    context.beginPath();\n    context.arc(0, 0, this.radius, 0, Math.PI * 2, true);\n    context.closePath();\n    context.fill();\n    if(this.lineWidth > 0) {\n        context.stroke();\n    }\n    context.restore();\n}\n</code></pre>\n<h2><a id=\"_5\"></a>二. 思路分析：</h2>\n<p>正弦波的实现可以使用正弦函数<code>Math.sin(angle)</code>绘制。其中，<strong>angle值作为变量并递增时，即可使物体按正弦曲线运动，从而实现正弦波动画</strong>。</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/wz3zl4ea2awztd3qp4ntqgwb/image_1aqk1il98unppr6st918g1b5h9.png\" alt=\"image_1aqk1il98unppr6st918g1b5h9.png-28.4kB\"></p>\n<p>过程如下：</p>\n<pre><code>(function drawFrame() {\n    window.requestAnimationFrame(drawFrame, canvas);\n    ball.y = Math.sin(angle) * range;\n    angle += speed;\n    ball.draw(context);\n})();\n</code></pre>\n<p>可以在控制台中输出以下代码，了解下正弦波的数值分布：</p>\n<pre><code>var fullRadians = Math.PI * 2;\nfor(var angle = 0; angle < fullRadians; angle += 0.01) {\n    console.log(Math.sin(angle));\n}\n</code></pre>\n<h2><a id=\"_6\"></a>三. 实例：</h2>\n<p>代码：</p>\n<pre><code><canvas id=\"canvas\" width=\"400\" height=\"400\" style=\"background: #ccc;\"></canvas>\n\nwindow.onload = function() {\n    var canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\"),\n        ball = new Ball(2),\n        angle = 0,\n        range = 50,\n        speed = 0.1,\n        isFoward = true;\n\n        ball.x = 0;\n        ball.y = canvas.height / 2;\n        ball.lineWidth = 0;\n\n    (function drawFrame() {\n        window.requestAnimationFrame(drawFrame, canvas);\n        // context.clearRect(0, 0, canvas.width, canvas.height);\n        ball.y = canvas.height / 2 + Math.sin(angle) * 100;\n        if(isFoward) {\n            ball.x += speed * 20;\n        } else {\n            ball.x -= speed * 20;\n        }\n\n        if(ball.x > canvas.width) {\n            isFoward = false;\n            context.clearRect(0, 0, canvas.width, canvas.height);\n        } else if(ball.x < 0) {\n            isFoward = true;\n            context.clearRect(0, 0, canvas.width, canvas.height);\n        }\n        angle += speed;\n        ball.draw(context);\n    })();\n};\n</code></pre>\n<p>演示如下：<a href=\"http://codepen.io/dengzhirong/pen/xOZypy\">http://codepen.io/dengzhirong/pen/xOZypy</a></p>\n<p><iframe style=\"width: 100%;\" src=\"//codepen.io/dengzhirong/embed/xOZypy/?height=300&theme-id=15149&default-tab=result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong/pen/xOZypy/\">xOZypy</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong\">@dengzhirong</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n<h2><a id=\"_7\"></a>四. 总结：</h2>\n<p>创建正弦波的方法，就是使用正弦函数<code>Math.sin(angle)</code>求值，并让弧度值angle根据运动时间递增。</p>\n<p>创建正弦波的公式如下：</p>\n<pre><code>/**\n * range：正选的波峰值\n * center：y轴的交点\n * speed：正弦波的运动速度\n * angle：弧度值，递增的变量\n*/\n(function drawFrame() {\n    window.requestAnimationFrame(drawFrame, canvas);\n\n    valeue = center + Math.sin(angle) * range;\n    angle += speed;\n})();\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/956\">http://www.dengzhr.com/js/956</a></div>\n\n        ','2','1'),(265,'Backbone.js 学习资料整理','\n\n            <p>近期想学习Backbone.js。故整理一波。</p>\n<p>Backbone.js API官方网站：<a href=\"http://backbonejs.org/\">http://backbonejs.org/</a></p>\n<p>Backbone.js API中文文档： <a href=\"http://www.css88.com/doc/backbone-0.5.3/\">http://www.css88.com/doc/backbone-0.5.3/</a></p>\n<p>Hello Backbone.js：<a href=\"http://arturadib.com/hello-backbonejs/\">http://arturadib.com/hello-backbonejs/</a></p>\n<p>What are some good resources…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>近期想学习Backbone.js。故整理一波。</p>\n<p>Backbone.js API官方网站：<a href=\"http://backbonejs.org/\">http://backbonejs.org/</a></p>\n<p>Backbone.js API中文文档： <a href=\"http://www.css88.com/doc/backbone-0.5.3/\">http://www.css88.com/doc/backbone-0.5.3/</a></p>\n<p>Hello Backbone.js：<a href=\"http://arturadib.com/hello-backbonejs/\">http://arturadib.com/hello-backbonejs/</a></p>\n<p>What are some good resources for Backbone.js：<a href=\"https://www.quora.com/What-are-some-good-resources-for-Backbone-js\">https://www.quora.com/What-are-some-good-resources-for-Backbone-js</a></p>\n<p>开始学习 Backbone：<a href=\"https://www.ibm.com/developerworks/cn/web/wa-backbonejs/\">https://www.ibm.com/developerworks/cn/web/wa-backbonejs/</a></p>\n<p>未完待续… …</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/966\">http://www.dengzhr.com/js/966</a></div>\n\n        ','2','1'),(266,'Canvas绘图API总结','\n\n            <h2>一. 绘图API总览：</h2>\n<ul>\n<li>strokeStyle</li>\n<li>fillStyle</li>\n<li>lineWidth</li>\n<li>save()</li>\n<li>restore()</li>\n<li>beginPath()</li>\n<li>closePath()</li>\n<li>stroke()</li>\n<li>lineTo(x, y)</li>\n<li>moveTo(x, y)</li>\n<li>quadraticCurveTo(cpx, cpy, x, y)</li>\n<li>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</li>\n<li>arcTo(x1, y1, x2, y2, radius)</li>\n<li>arc(x,</li></ul>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 绘图API总览：</h2>\n<ul>\n<li>strokeStyle</li>\n<li>fillStyle</li>\n<li>lineWidth</li>\n<li>save()</li>\n<li>restore()</li>\n<li>beginPath()</li>\n<li>closePath()</li>\n<li>stroke()</li>\n<li>lineTo(x, y)</li>\n<li>moveTo(x, y)</li>\n<li>quadraticCurveTo(cpx, cpy, x, y)</li>\n<li>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</li>\n<li>arcTo(x1, y1, x2, y2, radius)</li>\n<li>arc(x, y, radius, startAngle, endAngle [, anticlockwise])</li>\n<li>createLinearGradient(x0, y0, x1, y1)</li>\n<li>createRadialGradient(x0, y0, r0, x1, y1, r1)</li>\n<li>clearRect(x, y, width, height)</li>\n<li>fillReact(x, y, width, height)</li>\n</ul>\n<h2><a id=\"_5\"></a>二. canvas上下文</h2>\n<p>每个canvas元素都包含一个绘图上下文，可以通过它访问绘图API。</p>\n<pre><code>var canvas = document.getElementById(\"canvas\"),\n    context = canvas.getContext(\"2d\");\n</code></pre>\n<p><code>getContext()</code>传入字符串参数”2d”，用于指定将要使用的平面绘图API类型。</p>\n<p><code>getContext()</code>传入字符串参数”3d”，用于指定3D绘图 API，但是目前兼容性极差。</p>\n<h2><a id=\"_6\"></a>三. 消除图案</h2>\n<p>在大多数动画中，必须在绘制下一帧图案前清除canvas，通过这样来模拟出物体正在运动的效果。</p>\n<p>context.clearRect(x, y, width, height)方法会通过将像素的颜色设置为全透明的黑色擦除指定区域内的每一个像素，从而清除指定的矩形区域。</p>\n<h2><a id=\"_7\"></a>四. 设置线条的外观</h2>\n<ul>\n<li><code>strokeStyle</code>：指定线条颜色；</li>\n<li><code>lineWidth</code>：线条宽度；</li>\n<li><code>lineCap</code>：线条重点的绘制样式。可选值有：butt（默认，延长线）、round（圆的）、square（平的）；</li>\n<li><code>lineJoin</code>：两条线段的接合方式。可选值有：round、bevel、miter（默认）；</li>\n<li><code>miterLimit</code>：用于控制两条相交线外侧交点与内侧交点的距离。</li>\n</ul>\n<h2><a id=\"_8\"></a>五. 使用填充色创建图形</h2>\n<ul>\n<li><strong>context.fillStyle</strong>：填充样式。可以填充纯色、渐变色、pattern和图片。</li>\n<li><strong>context.fill()</strong>：开始填充。</li>\n</ul>\n<h2><a id=\"_9\"></a>六. 创建简便填充色</h2>\n<p><strong>线性渐变</strong>：<strong>context.createLinearGradient(x0, y0, x1, y1)</strong>：将沿点(x0, y0)与点(x1, y1)之间的直线填充渐变色。</p>\n<p><strong>放射性渐变</strong>：<strong>context.createRadialGradient(x0, y0, r0, x1, y1, r1)</strong>：从指定的空间的中心开始向各个方向扩散，从而创建一个圆形渐变。</p>\n<h3><a id=\"_10\"></a>6.1 设置渐变点的颜色</h3>\n<p>可以使用Gradient.addColorStop(ratio, color)方法为渐变色添加渐变点颜色。其中ratio是填充比例，取值范围为[0, 1]。</p>\n<p>例如：</p>\n<pre><code>var gradient = context.createLinearGradient(0, 0, 100, 100);\ngradient.addColorStop(0, \"#fff\");\ngradient.addColorStop(1, \"#000\");\n</code></pre>\n<h2><a id=\"_11\"></a>七. 绘制的样式状态切换</h2>\n<p><code>context.save()</code>和<code>context.restore()</code>方法可以实现在不同的样式间切换。</p>\n<p><code>context.save()</code>方法将canvas的当前状态存入栈中，其中包含各种样式，例如，strokeStyle、fillStyle以及应用于canvas的变换效果。</p>\n<p><code>context.restore()</code>方法可以使得当前的canvas状态出栈，转而使用下一个状态，即使用之前的状态。</p>\n<h2><a id=\"_12\"></a>八. 绘制直线</h2>\n<ul>\n<li><strong>context.beginPath()</strong>：开始绘制新路径；</li>\n<li><strong>context.moveTo(x0, y0)</strong>：移动到线条起点；</li>\n<li><strong>context.lineTo(x1, y1)</strong>：连线到线条终点；</li>\n<li><strong>context.stroke()</strong>：绘制线条。</li>\n</ul>\n<p>基于上面的绘图指令，可以创建一个简单的绘图程序，如下：</p>\n<pre><code><canvas id=\"canvas\" width=\"400\" height=\"400\" style=\"background: #ccc;\"></canvas>\n<script type=\"text/javascript\">\n    var canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\");\n\n    function onMouseMove(e) {\n        var movePosition = {\n            x: getMouse(e).x,\n            y: getMouse(e).y\n        };\n        context.lineTo(movePosition.x, movePosition.y);\n        context.stroke();\n    }\n\n    canvas.addEventListener(\"mousedown\", function(e) {\n        var curPosition = {\n            x: getMouse(e).x,\n            y: getMouse(e).y\n        };\n        context.beginPath();\n        context.moveTo(curPosition.x, curPosition.y);\n        console.log(\"curPosition: \" + curPosition.x + \"; \" + curPosition.y);\n        canvas.addEventListener(\"mousemove\", onMouseMove, false);\n    }, false);\n\n    canvas.addEventListener(\"mouseup\", function(e) {\n        canvas.removeEventListener(\"mousemove\", onMouseMove, false);\n    }, false);\n\n    // 获取鼠标的当前位置\n    function getMouse(event) {\n        var event = event || window.event;\n        var mouse = {};\n        var x, y;\n        if(event.pageX || event.pageY) {\n            x = event.pageX;\n            y = event.pageY;\n        } else if(event.clientX || event.clientY) {\n            var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n            var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n            x = event.clientX + scrollLeft;\n            y = event.clientY + scrollTop;\n        }\n        mouse.x = x;\n        mouse.y = y;\n        return mouse;\n    }\n</script>\n</code></pre>\n<p>演示如下：<a href=\"http://codepen.io/dengzhirong/pen/PzgaRk\">http://codepen.io/dengzhirong/pen/PzgaRk</a></p>\n<p><iframe style=\"width: 100%;\" src=\"//codepen.io/dengzhirong/embed/PzgaRk/?height=300&theme-id=15149&default-tab=result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong/pen/PzgaRk/\">PzgaRk</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong\">@dengzhirong</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n<h2><a id=\"_13\"></a>九. 使用quadraticCurveTo绘制曲线</h2>\n<p>二次贝塞尔曲线<strong>quadraticCurveTo(cpx, cpy, x, y)</strong>接收两个点作为参数：第一个点是控制点，用于影响曲线的形状，第二个点是曲线的终点。</p>\n<p><strong>quadraticCurveTo()</strong>的绘制方法与<strong>lineTo()</strong>类似，都是以上一次方法调用的重点或上一个<strong>context.moveTo()</strong>的位置作为起点。两者唯一的区别在于绘制出来线条的形状。</p>\n<p>例子：</p>\n<pre><code><canvas id=\"canvas\" width=\"400\" height=\"400\" style=\"background: #ccc;\"></canvas>\n<script type=\"text/javascript\">\n    var canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\");\n\n    var x0 = 100,\n        y0 = 200,\n        x2 = 300,\n        y2 = 200;\n\n    canvas.addEventListener(\"mousemove\", function(e) {\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        var x1 = getMouse(e).x;\n            y1 = getMouse(e).y;\n        context.beginPath();\n        context.moveTo(x0, y0);\n        context.quadraticCurveTo(x1, y1, x2, y2);\n        context.stroke();\n    }, false);\n\n    // 获取鼠标的当前位置\n    function getMouse(event) {\n        var event = event || window.event;\n        var mouse = {};\n        var x, y;\n        if(event.pageX || event.pageY) {\n            x = event.pageX;\n            y = event.pageY;\n        } else if(event.clientX || event.clientY) {\n            var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n            var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n            x = event.clientX + scrollLeft;\n            y = event.clientY + scrollTop;\n        }\n        mouse.x = x;\n        mouse.y = y;\n        return mouse;\n    }\n</script>\n</code></pre>\n<p>演示如下：<a href=\"http://codepen.io/dengzhirong/pen/yJAEEP\">http://codepen.io/dengzhirong/pen/yJAEEP</a></p>\n<p><iframe style=\"width: 100%;\" src=\"//codepen.io/dengzhirong/embed/yJAEEP/?height=300&theme-id=15149&default-tab=result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong/pen/yJAEEP/\">yJAEEP</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong\">@dengzhirong</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n<h3><a id=\"_14\"></a>9.1 鼠标穿过控制点</h3>\n<p>如果希望鼠标能穿过控制点，可以用下面的共识计算控制点：（假设：以(x0, y0)作为起点，(x2, y2)作为终点，(x1, y1)作为控制点，(xt, yt)为鼠标所在的点）：</p>\n<pre><code>x1 = xt * 2 - (x0 + x2) / 2;\ny1 = yt * 2 - (y0 + y2) / 2;\n</code></pre>\n<p>可以把上面的程序稍作修改后，使鼠标穿过控制点：</p>\n<p>把以下代码：</p>\n<pre><code>var x1 = getMouse(e).x;\n    y1 = getMouse(e).y;\n</code></pre>\n<p>改为：</p>\n<pre><code>var x1 = getMouse(e).x * 2 - (x0 + x2) / 2;\n    y1 = getMouse(e).y * 2 - (y0 + y2) / 2;\n</code></pre>\n<p>演示如下：<a href=\"http://codepen.io/dengzhirong/pen/QEPxBg\">http://codepen.io/dengzhirong/pen/QEPxBg</a></p>\n<p><iframe style=\"width: 100%;\" src=\"//codepen.io/dengzhirong/embed/QEPxBg/?height=300&theme-id=15149&default-tab=result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong/pen/QEPxBg/\">QEPxBg</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong\">@dengzhirong</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n<h2><a id=\"_15\"></a>十. 其他形式的曲线绘制</h2>\n<ul>\n<li><strong>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</strong>：增加一个到当前路径的点，并由三次贝塞尔曲线连接两个控制点；</li>\n<li><strong>arcTo(x1, y1, x2, y2, radius)</strong>：使用两个控制点和指定半径为连接到前一个点的直线路径添加一个弧度；</li>\n<li><strong>arc(x, y, radius, startAngle, endAngle [, anticlockwise])</strong>：为连接到前一个点的直线路径添加一个弧度，该弧度将以x、y作为圆心，以radius为半径的一个圆的一部分。该弧度的起始角度和终止角度分别由startAngle和endAngle指定。</li>\n</ul>\n<p>这些曲线的绘制方法大抵类似。以绘制圆为例子：</p>\n<pre><code>context.beginPath();\ncontext.arc(100, 100, 50, 0, (Math.PI * 2), true);\ncontext.closePath();\ncontext.stroke();\n</code></pre>\n<h2><a id=\"_16\"></a>十一. 加载并绘制图片</h2>\n<p>如果希望在动画中绘制一张外部图片，有两种方式可以用于在动画中访问外部图片：</p>\n<ul>\n<li>在脚本运行过程中加载一个URL；</li>\n<li>使用DOM接口访问一个内嵌在HTML中的图片元素。</li>\n</ul>\n<p>当图片加载完成后，再使用绘图API将其渲染到canvas。</p>\n<h3><a id=\"_17\"></a>11.1 加载图片</h3>\n<p>为了实现在运行时加载一张图片，可以创建一个Image对象，并将其src属性设置为图片文件的url路径。当图片加载完成后，它就会执行onload方法所关联的回调函数。</p>\n<p>如下：</p>\n<pre><code><canvas id=\"canvas\" width=\"180\" height=\"180\" style=\"background: #ccc;\"></canvas>\n<script type=\"text/javascript\">\n    var canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\"),\n        image = new Image();\n\n    image.src = \"http://www.dengzhr.com/wp-content/themes/dengzhr/images/logo.jpg\";\n    image.onload = function() {\n        context.drawImage(image, 0, 0);\n    };\n</script>\n</code></pre>\n<p>使用<strong>context.drawImage()</strong>方法将图片绘制到canvas元素上，该方法接受一个图片元素与canvas上的一个x、y坐标。</p>\n<p><strong>context.drawImage()</strong>方法有以下三种调用方式，分别使用多个参数：</p>\n<ul>\n<li><strong>drawImage(image, dx, dy)</strong>：在canvas的(dx, dy)坐标上绘制一张图片。(dx, dy)是图片左上角的位置。</li>\n<li><strong>drawImage(image, dx, dy, dw, dh)</strong>：分别根据dw、dh的值设定图片的宽度与高度，并将其绘制在canvas的(dx, dy)坐标。</li>\n<li><strong>drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)</strong>：将图片裁剪到矩形区域(sx, sy, dw, dh)中，并缩放至(dw, dh)，再将其绘制到(dy, dy)坐标上。</li>\n</ul>\n<h3><a id=\"_18\"></a>11.2 使用图片元素</h3>\n<pre><code><canvas id=\"canvas\" width=\"180\" height=\"180\" style=\"background: #ccc;\"></canvas>\n<img id=\"img\" src=\"http://www.dengzhr.com/wp-content/themes/dengzhr/images/logo.jpg\">\n<script type=\"text/javascript\">\n    var canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\"),\n        image = document.getElementById(\"img\");\n\n    image.onload = function() {\n        context.drawImage(image, 0, 0);\n    };\n</script>\n</code></pre>\n<h3><a id=\"_19\"></a>11.3 使用视频元素</h3>\n<p>除了可以将一幅静止的图片绘制到canvas以外，canvas还支持逐帧的视频渲染。</p>\n<p>由于视频本质上就是按顺序播放的一系列静止的图像，因此canvas元素会在一个动画循环中不断绘制视频中的当前帧。</p>\n<p>如下：</p>\n<pre><code><canvas id=\"canvas\" width=\"300\" height=\"300\" style=\"background: #ccc;\"></canvas>\n<video id=\"video\" style=\"display: none; width: 300px; height: 300px;\" autoplay>\n    <source src=\"video.mp4\" type=\"video/mp4\" />\n    <source src=\"video.webm\" type=\"video/webm\" />\n    <source src=\"video.ogv\" type=\"video/ogg\" />\n</video>\n<script type=\"text/javascript\">\n    var canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\"),\n        video = document.getElementById(\"video\");\n\n        (function drawFrame() {\n            window.requestAnimationFrame(drawFrame. canvas);\n            context.drawImage(video, 0, 0);\n        })();\n</script>\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/940\">http://www.dengzhr.com/js/940</a></div>\n\n        ','2','1'),(267,'JavaScript动画详解(一) —— 循环与事件监听','\n\n            <p>其实Web动画的实现原理跟早期的运动影片很类似，都是通过将一张张的赛璐珞片以较快速度播放，从而模拟出连贯的物体运动。而这一张张的赛璐珞片就类似于投影运动媒体的帧的概念，而几乎所有投影运动媒体都是通过帧来实现的。</p>\n<h2>动画循环</h2>\n<p>几乎所有的程序动画都会表现为某种形式的循环，我们会创建一个展现一系列图像的流程图以实现逐帧动画，其中每一帧只需要绘制出来即可。</p>\n<p>为了实现动画，需要为每一帧执行以下操作：</p>\n<p>1 . 执行该帧�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>其实Web动画的实现原理跟早期的运动影片很类似，都是通过将一张张的赛璐珞片以较快速度播放，从而模拟出连贯的物体运动。而这一张张的赛璐珞片就类似于投影运动媒体的帧的概念，而几乎所有投影运动媒体都是通过帧来实现的。</p>\n<h2><a id=\"_4\"></a>动画循环</h2>\n<p>几乎所有的程序动画都会表现为某种形式的循环，我们会创建一个展现一系列图像的流程图以实现逐帧动画，其中每一帧只需要绘制出来即可。</p>\n<p>为了实现动画，需要为每一帧执行以下操作：</p>\n<p>1 . 执行该帧所要调用到的代码；</p>\n<p>2 . 将所有对象绘制到出来；</p>\n<p>3 . 重复这一过程渲染下一帧。</p>\n<h2><a id=\"_5\"></a>动画循环函数</h2>\n<p>在H5时代，实现Web动画的方法有很多：</p>\n<p>可以使用CSS3中的animation + keyframes或者transition，可以通过SVG中的SMIL动画接口，也可以借助jQuery动画相关的API。还可以使用JavaScript中最原始window.setTimout()和window.setInterval()通过不断更新元素的状态位置等来实现动画。</p>\n<p>在HTML5中又提出了一种新的基于浏览器优化动画实现的方案 —— window.requestAnimationFrame()方法。</p>\n<p>下面主要讨论一下JavaScript中动画循环函数 —— setTimeout()、setInterval()和requestAnimationFrame()，他们的对应取消循环函数分别是clearTimeout()、clearInterval()和cancelAnimationFrame()。</p>\n<h3><a id=\"_6\"></a>setTimeout()</h3>\n<p>setTimeout实现循环动画的原理：</p>\n<pre><code class=\"lang-javascript\">(function drawFrame() {\n    var timer = null;\n    var delayTime = 1000 / 60;\n    // 帧渲染和帧绘制 ...\n    timer = setTimeout(drawFrame, delayTime);\n    // 停止循环\n    if( /* 停止条件成立 */ ) {\n        clearTimeout(timer);\n    }\n})();\n</code></pre>\n<h3><a id=\"_7\"></a>setInterval()</h3>\n<p>setInterval实现循环动画的原理：</p>\n<pre><code class=\"lang-javascript\">var timer = null;\nvar delayTime = 1000/ 60;\ntimer = setInterval(drawFrame, delayTime);\n\nfunction drawFrame() {\n    // 帧渲染和帧绘制 ...\n    // 停止循环\n    if( /* 动画停止条件成立 */ ) {\n        clearInterval(timer);\n    }\n}\n</code></pre>\n<p> setInterval却没有被所调用的函数所束缚，它只是简单地每隔一定时间就重复执行一次所调用的函数。而setTimeout受所调用函数的影响，只有执行完成该次的函数调用，才能继续执行下一次的函数调用。</p>\n<p>如果要求在每隔一个固定的时间间隔后就精确地执行某动作，那么最好使用setInterval。</p>\n<p>如果不想由于连续调用产生互相干扰的问题，尤其是每次函数的调用需要繁重的计算以及很长的处理时间，那么最好使用setTimeout。</p>\n<h3><a id=\"_8\"></a>requestAnimationFrame()</h3>\n<p>requestAnimationFrame()的原理其实与setTimeout和setInterval类似，通过递归调用同一方法来不断更新画面以达到动画效果，但它优于setTimeout和setInterval的地方在于它是由浏览器专门为动画提供优化实现的API，并且充分利用显示器的刷新机制，比较节省系统资源。显示器有固定的刷新频率（60Hz或75Hz），也就是说，每秒最多只能重绘60次或75次，requestAnimationFrame的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行页面重绘。此外，使用这个API，一旦页面不处于浏览器的当前标签，就会自动停止刷新。这就节省了CPU、GPU和电力。</p>\n<p>不过有一点需要注意，requestAnimationFrame是在主线程上完成。这意味着，如果主线程非常繁忙，requestAnimationFrame的动画效果会大打折扣。</p>\n<p>requestAnimationFrame的语法如下：</p>\n<p>requestAnimationFrame(callback)  //callback为回调函数</p>\n<p>requestAnimationFrame动画的实现原理与setTimeout类似，都是使用一个回调函数作为参数，且这个回调函数会在浏览器重绘之前调用。具体如下：</p>\n<pre><code class=\"lang-javascript\">(function drawFrame() {\n    var timer = null;\n    // 帧渲染和帧绘制 ...\n    timer = requestAnimationFrame(drawFrame);\n    // 停止循环\n    if( /* 停止条件成立 */ ) {\n        cancelAnimationFrame(timer);\n    }\n})();\n</code></pre>\n<p>由于requestAnimationFrame是HTML5新定义的API，旧版本的浏览器并不兼容，而且浏览器的实现方式不一，此时就需要考虑到兼容性问题了。常用的兼容性写法如下：</p>\n<pre><code class=\"lang-javascript\">window.requestAnimFrame = (function(){\n      return  window.requestAnimationFrame       || \n              window.webkitRequestAnimationFrame || \n              window.mozRequestAnimationFrame    || \n              window.oRequestAnimationFrame      || \n              window.msRequestAnimationFrame     || \n              function( callback ){\n                window.setTimeout(callback, 1000 / 60);\n              };\n})();\n\nwindow.cancelAnimationFrame = (function () {\n    return window.cancelAnimationFrame ||\n            window.webkitCancelAnimationFrame ||\n            window.mozCancelAnimationFrame ||\n            window.oCancelAnimationFrame ||\n            function (timer) {\n                window.clearTimeout(timer);\n            };\n})();\n</code></pre>\n<p>上面兼容性代码作用有两个，一是把各浏览器前缀进行统一，二是在浏览器没有requestAnimationFrame方法时将其指向setTimeout方法。</p>\n<p>更具体的兼容性请看这里~http://caniuse.com/#feat=requestanimationframe</p>\n<p>截个图，如下：</p>\n<p><img src=\"http://www.dengzhr.com/wp-content/uploads/2015/09/animationFrames.png\" alt=\"requestAnimationFrame兼容性\"></p>\n<h2><a id=\"_9\"></a>事件监听</h2>\n<p>在动画中我们也许常用到用户交互效果，而用户交互是基于用户事件的，这些事件通常是鼠标事件、触摸事件以及键盘事件。</p>\n<h3><a id=\"_10\"></a>事件监听器</h3>\n<p>事件监听器是监听事件的对象。最原始的时间监听是使用\"on + 事件\"的方法监听事件，如\"onclick\"等。在现在标准Web浏览器中还可以通过调用DOM元素的addEventListener()方法指定它作为某个特定时间的监听器，在IE6~8中不兼容addEventListener()，但可以使用attachEvent()来实现类似的效果。</p>\n<p>常用的兼容性写法如下：</p>\n<pre><code class=\"lang-javascript\">// eventType为不含\"on\"的事件类型\nvar bind = (function(ele, eventType, callback) {\n    if(ele.addEventListener) {\n        // W3C标准写法\n        return ele.addEventListener(eventType, callback, false);\n    }else if(ele.attachEvent) {\n        // 兼容IE6~8\n        return ele.attachEvent(eventType, callback);\n    }else {\n        // 兼容IE5-\n        return ele[\"on\" + eventType] = callback;\n    }\n})();\n\nvar unbind = (function(ele, eventType, callback) {\n    if(ele.removeEventListener) {\n        // W3C标准写法\n        return ele.removeEventListener(eventType, callback, false);\n    }else if(ele.detachEvent) {\n        // 兼容IE6~8\n        return ele.detachEvent(eventType, callback);\n    }else {\n        // 兼容IE5-\n        return ele[\"on\" + eventType] = null;\n    }\n})();\n</code></pre>\n<h2><a id=\"_11\"></a>常见的事件类型</h2>\n<h3><a id=\"_12\"></a>鼠标事件：</h3>\n<p>onmousedown, onmouseup, onclick, ondbclick, onmousewheel, onmousemove, onmouseover, onmouseout；</p>\n<h3><a id=\"_13\"></a>触摸事件：</h3>\n<p>ontouchstart, ontouchend, ontouchmove；</p>\n<h3><a id=\"_14\"></a>键盘事件：</h3>\n<p>onkeydown, onkeyup, onkeypress；</p>\n<h3><a id=\"_15\"></a>页面相关事件：</h3>\n<p>onabort(图片在下载时被用户中断), onbeforeunload(当前页面的内容将要被改变时触发), onerror(出现错误时触发), onload(内容加载完成时触发), onmove(浏览器窗口被移动时触发), onresize(浏览器的窗口大小被改变时触发), onscroll(滚动条位置发生变化时触发), onstop(浏览器的停止按钮被按下时触发此事件或者正在下载的文件被中断时触发), onunload(当前页面将被改变时触发)；</p>\n<h3><a id=\"_16\"></a>表单相关事件</h3>\n<p>onblur(元素失去焦点时触发), onchange(元素失去焦点且元素内容发生改变时触发), onfocus(元素获得焦点时触发), onreset(表单中reset属性被激活时触发), onsubmit(表单被提交时触发)；oninput(在input元素内容修改后立即被触发，兼容IE9+)</p>\n<h3><a id=\"_17\"></a>编辑事件</h3>\n<p>onbeforecopy：当页面当前的被选择内容将要复制到浏览者系统的剪贴板前触发此事件；</p>\n<p>onbeforecut：当页面中的一部分或者全部的内容将被移离当前页面[剪贴]并移动到浏览者的系统剪贴板时触发此事件；</p>\n<p>onbeforeeditfocus：当前元素将要进入编辑状态；</p>\n<p>onbeforepaste：内容将要从浏览者的系统剪贴板传送[粘贴]到页面中时触发此事件；</p>\n<p>onbeforeupdate：当浏览者粘贴系统剪贴板中的内容时通知目标对象；</p>\n<p>oncontextmenu：当浏览者按下鼠标右键出现菜单时或者通过键盘的按键触发页面菜单时触发的事件；</p>\n<p>oncopy：当页面当前的被选择内容被复制后触发此事件；</p>\n<p>oncut：当页面当前的被选择内容被剪切时触发此事件；</p>\n<p>onlosecapture：当元素失去鼠标移动所形成的选择焦点时触发此事件；</p>\n<p>onpaste：当内容被粘贴时触发此事件；</p>\n<p>onselect：当文本内容被选择时的事件；</p>\n<p>onselectstart：当文本内容选择将开始发生时触发的事件；</p>\n<h3><a id=\"_18\"></a>拖动事件</h3>\n<p>ondrag：当某个对象被拖动时触发此事件 [活动事件]；</p>\n<p>ondragdrop：一个外部对象被鼠标拖进当前窗口时触发；</p>\n<p>ondragend：当鼠标拖动结束时触发此事件；</p>\n<p>ondragenter：当对象被鼠标拖动的对象进入其容器范围内时触发此事件；</p>\n<p>ondragleave：当对象被鼠标拖动的对象离开其容器范围内时触发此事件；</p>\n<p>ondragover：当某被拖动的对象在另一对象容器范围内拖动时触发此事件；</p>\n<p>ondragstart：当某对象将被拖动时触发此事件；</p>\n<p>ondrop：在一个拖动过程中，释放鼠标键时触发此事件；</p>\n<h2><a id=\"_19\"></a>事件的常见应用</h2>\n<h3><a id=\"_20\"></a>获取鼠标位置</h3>\n<p>每个鼠标事件都有两个属性用于确定鼠标当前位置：pageX和pageY。但是IE6~8不知持这两个属性，需要用到clientX和clientY。</p>\n<p>其中，pageX和pageY的鼠标位置是相对于document文档的，而clientX和clientY的鼠标位置是相对于浏览器屏幕的。为了实现各平台统一，兼容性写法可以如下：</p>\n<pre><code class=\"lang-javascript\">// 初始化鼠标位置，这里的鼠标位置默认是相对于document文档的\nvar mouse = {\n    x: 0,\n    y: 0\n}; \nfunction getMouse(event) {\n    var event = event || window.event;\n    if(event.pageX || event.pageY) {\n        x = event.x;\n        y = event.y;\n    }else {\n        var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n        x = event.clientX + scrollLeft;\n        y = event.clientY + scrollTop;\n    }\n    mouse.x = x;\n    mouse.y = y;\n\n    return mouse;\n}\n</code></pre>\n<h3><a id=\"_21\"></a>触摸位置</h3>\n<p>一个触摸点可以被想象成鼠标光标，不过鼠标光标会一直停留在屏幕上，而手指却会从设备上按下、移动以及释放，所以某些时刻光标会从屏幕上消失。另外，触摸屏上不存在mouseover等效的触摸事件。同一时间可能发生多点触摸，某个触摸点的信息会保存在触摸事件的一个数组中。</p>\n<p>获取触摸位置的方法见下：</p>\n<pre><code class=\"lang-javascript\">// 触摸位置声明\nvar touch = {\n    x: null,\n    y: null,\n    isPress: false\n}\n\nfunction getTouch (event) {\n    var x, y, \n    touchEvent = event.touches[0]; //获取触摸位置的第一个触摸点\n    var event = event || window.event;\n    if(touchEvent.pageX || touchEvent.pageY) {\n        touchEvent.pageX;\n        y = touchEvent.pageY;\n    }else {\n        var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n        x = touchEvent.clientX + scrollLeft;\n        y = touchEvent.clientY + scrollTop;\n    }\n    touch.x = x;\n    touch.y = y;\n\n    return touch;\n}\n</code></pre>\n<p>常用的方法是，如果不存在有效的触摸点是，x和y的值应设置为null。</p>\n<pre><code class=\"lang-javascript\">element.addEventListener(\"touchstart\", function(event) {\n    touch.isPressed = true;\n}, false);\nelement.addEventListener(\"touchsend\", function(event) {\n    touch.isPressed = false;\n    touch.x = null;\n    touch.y = null;\n}, false);\nelement.addEventListener(\"touchsend\", function(event) {\n    if(touch.isPressed) {\n        getTouch (event);\n    }\n}, false);\n</code></pre>\n<h3><a id=\"_22\"></a>获取键盘码</h3>\n<p>获得键盘码可以使用event.keyCode。具体实现如下：</p>\n<pre><code class=\"lang-javascript\">var keyCode;\nfunction getKeyCode(event) {\n    var event = event || window.event;\n    keyCode = event.keyCode;\n    return keyCode;\n}\n</code></pre>\n<h3><a id=\"_23\"></a>鼠标滚轮事件的判定</h3>\n<p>见我写的另外一篇文章《<a href=\"http://www.dengzhr.com/frontend/js/440\">JavaScript滚轮事件兼容性写法</a>》</p>\n<h2><a id=\"_24\"></a>总结</h2>\n<p>多数Web动画都是由一帧帧的状态通过较快速度的播放模拟出来的，所以循环计时函数在这里就起到了连接连贯的帧状态的作用。而动画更多时候需要用户交互，所以事件和事件监听尤显重要。最后我列出了几个经常用到几个与事件相关的封装应用，方便自己查阅和调用。</p>\n<p>下一篇，我想写点关于缓动动画的。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/447\">http://www.dengzhr.com/js/447</a></div>\n\n        ','2','1'),(268,'Node.js学习笔记：文件的常规操作','\n\n            <p>Node.js的文件操作部分的官方API文档如下：<br>\n<a href=\"https://nodejs.org/api/fs.html\">https://nodejs.org/api/fs.html</a></p>\n<p>fs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等POSIX文件系统操作。与其他模块不同的是，fs模块中所有的操作都提供了异步和同步的两个版本，例如读取文件内容的函数有异步的fs.readFile()和同步的fs.readFileSync()。</p>\n<p>进行文件操作前，都�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>Node.js的文件操作部分的官方API文档如下：<br>\n<a href=\"https://nodejs.org/api/fs.html\">https://nodejs.org/api/fs.html</a></p>\n<p>fs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等POSIX文件系统操作。与其他模块不同的是，fs模块中所有的操作都提供了异步和同步的两个版本，例如读取文件内容的函数有异步的fs.readFile()和同步的fs.readFileSync()。</p>\n<p>进行文件操作前，都要导入文件系统模块（fs），语法如下：</p>\n<pre><code>var fs = require(\"fs\");\n</code></pre>\n<h2><a id=\"_4\"></a>一. 目录操作</h2>\n<h3><a id=\"_5\"></a>1. 创建目录</h3>\n<p>创建目录的语法如下：</p>\n<pre><code>fs.mkdir(path[, mode], callback) // 异步方法\nfs.mkdirSync(path[, mode])  // 同步方法\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\"fs\");\n\n// 在该文件的同一目录下建立test目录\nfs.mkdir(\'test\',function(err){\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"目录创建成功。\");\n});\n</code></pre>\n<h3><a id=\"_6\"></a>2. 读取目录</h3>\n<p>读取目录的语法如下：</p>\n<pre><code>fs.readdir(path, callback)\nfs.readdirSync(path)\n</code></pre>\n<blockquote>\n<ul>\n<li>path： 文件路径；</li>\n<li>callback： 回调函数，回调函数带有两个参数err, files。err为错误信息，files为目录下的文件数组列表。</li>\n</ul>\n</blockquote>\n<p>示例：</p>\n<pre><code>var fs = require(\"fs\");\n\nfs.readdir(\"test/\",function(err, files){\n   if (err) {\n       return console.log(err);\n   }\n   files.forEach( function (file){\n       console.log( file );\n   });\n});\n</code></pre>\n<h3><a id=\"_7\"></a>3. 删除目录</h3>\n<p>删除目录的语法如下：</p>\n<pre><code>fs.rmdir(path, callback)\nfs.rmdirSync(path)\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\"fs\");\n\nfs.rmdir(\"test/ewe\",function(err){\n   if (err) {\n       return console.log(err);\n   }\n\n   fs.readdir(\"/test/\",function(err, files){\n      if (err) {\n          return console.error(err);\n      }\n      files.forEach( function (file){\n          console.log( file );\n      });\n   });\n});\n</code></pre>\n<h2><a id=\"_8\"></a>二. 文件操作</h2>\n<h3><a id=\"_9\"></a>1. 打开文件</h3>\n<p>打开文件的语法如下：</p>\n<pre><code>fs.open(path, flags, [mode], [callback(err, fd)])\n</code></pre>\n<p>其中，path为文件的路径，flags指文件的读取方式，mode参数用于创建文件时给文件指定权限，默认是0666.回掉函数将会传递一个文件描述符fd。</p>\n<p>flags的常用参数值如下：</p>\n<table>\n<thead>\n<tr>\n<th>flags取值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>r</td>\n<td>以读取模式打开文件。</td>\n</tr>\n<tr>\n<td>r+</td>\n<td>以读写模式打开文件。</td>\n</tr>\n<tr>\n<td>w</td>\n<td>以写入模式打开文件，如果文件不存在则创建。</td>\n</tr>\n<tr>\n<td>w+</td>\n<td>以读写模式打开文件，如果文件不存在则创建。</td>\n</tr>\n<tr>\n<td>a</td>\n<td>以追加模式打开文件，如果文件不存在则创建。</td>\n</tr>\n<tr>\n<td>a+</td>\n<td>以读取追加模式打开文件，如果文件不存在则创建。</td>\n</tr>\n</tbody>\n</table>\n<p>mode参数表示的文件权限是POSIX操作系统中对文件读取和访问权限的规范，通常用一个八进制数来表示。例如0754表示文件所有者的权限是7（读、写、执行），同组的用户权限是5（读、执行），其他用户的权限是4（读）。</p>\n<p>示例：</p>\n<pre><code>var fs = require(\'fs\');\n\nfs.open(\"test.txt\",\"w\",0644,function(e,fd){\n    try{\n        fs.write(fd,\"first fs!\",0,\'utf8\',function(e){\n            fs.closeSync(fd);\n        })\n    } catch(E) {\n        throw e;\n    }\n\n});\n</code></pre>\n<h3><a id=\"_10\"></a>2. 写入文件</h3>\n<p>写入文件的语法如下：</p>\n<pre><code>fs.writeFile(file, data[, options], callback)\nfs.writeFileSync(file, data[, options])\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\"fs\");\n\nfs.writeFile(\'test.txt\', \'hello world!\',  function(err) {\n   if (err) {\n       return console.log(err);\n   }\n\n   fs.readFile(\'test.txt\', function (err, data) {\n      if (err) {\n         return console.log(err);\n      }\n      console.log(\"异步读取文件数据: \" + data.toString());\n   });\n});\n</code></pre>\n<h3><a id=\"_11\"></a>3. 读取文件</h3>\n<p>读取文件的语法如下：</p>\n<pre><code>fs.read(fd, buffer, offset, length, position, callback)\nfs.readSync(fd, buffer, offset, length, position)\n\nfs.readFile(file[, options], callback)\nfs.readFileSync(file[, options])\n</code></pre>\n<p>其中，fs.read()和fs.readSync()的参数如下：</p>\n<blockquote>\n<ul>\n<li>fd – 通过 fs.open() 方法返回的文件描述符；</li>\n<li>buffer – 数据写入的缓冲区；</li>\n<li>offset – 缓冲区写入的写入偏移量；</li>\n<li>length – 要从文件中读取的字节数；</li>\n<li>position – 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取；</li>\n<li>callback – 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象；</li>\n</ul>\n</blockquote>\n<p>fs.read()的示例如下：</p>\n<pre><code>var fs = require(\'fs\');  \nfs.open(\'test.txt\', \'r\', function(err, fd) {  \nif (err) {  \nconsole.error(err);  \nreturn;  \n}  \nvar buf = new Buffer(8);  \nfs.read(fd, buf, 0, 8, null, function(err, bytesRead, buffer) {  \nif (err) {  \nconsole.error(err);  \nreturn;  \n}  \nconsole.log(\'bytesRead: \' + bytesRead);  \nconsole.log(buffer);  \n})  \n});\n</code></pre>\n<p>fs.readFile()的示例如下：</p>\n<pre><code>var fs = require(\'fs\');  \nfs.readFile(\'test.txt\', function(err, data) {  \n    if (err) {  \n        console.log(err);  \n    } else {  \n        console.log(data.toString());  \n    }  \n});\n</code></pre>\n<h3><a id=\"_12\"></a>4. 关闭文件</h3>\n<p>关闭文件的语法如下：</p>\n<pre><code>fs.close(fd, callback)\nfs.closeSync(fd)\n</code></pre>\n<h3><a id=\"_13\"></a>5. 删除文件</h3>\n<p>删除文件的语法如下：</p>\n<pre><code>fs.unlink(path, callback)\nfs.unlinkSync(path)\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\"fs\");\n\nfs.unlink(\'test.txt\', function(err) {\n   if (err) {\n       return console.log(err);\n   }\n   console.log(\"文件删除成功！\");\n});\n</code></pre>\n<h3><a id=\"_14\"></a>6. 确定文件是否存在</h3>\n<p>确定文件是否存在的语法如下：</p>\n<pre><code>fs.exists(path, callback)\nfs.existsSync(path)\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\'fs\');\n\nfs.exists(\'test.txt\', function (exists) {\n    if(exists) {\n        console.log(\"文件存在！\");\n    }else {\n        console.log(\"文件不存在！\");\n    }\n});\n</code></pre>\n<h3><a id=\"_15\"></a>7. 追加内容至文件</h3>\n<pre><code>fs.appendFile(file, data[, options], callback)\nfs.appendFileSync(file, data[, options])\n</code></pre>\n<p>示例：</p>\n<pre><code>var fs = require(\'fs\');\n\nfs.appendFile(\"test.txt\", \"append content\", function (err) {\n    if (err) {\n        console.log(err);\n    }else {\n        fs.readFile(\'test.txt\', function(err, data) {  \n            if (err) {  \n                console.log(err);  \n            } else {  \n                console.log(data.toString());  \n            }  \n        }); \n    }\n});\n</code></pre>\n<p>更多的文件系统操作可查看Node.js的fs模块的官方API文档：<a href=\"https://nodejs.org/api/fs.html\">https://nodejs.org/api/fs.html</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/node-js/636\">http://www.dengzhr.com/node-js/636</a></div>\n\n        ','2','1'),(269,'HTML5读取拖放的本地文件','\n\n            <p>在桌面上创建了自定义的放置目标后，可以从桌面上把文件拖放到该目标。与拖放一张图片或链接类似，从桌面上把文件拖放到浏览器中也会触发drop事件。而且可以在event.dataTransfer.files中读取到被放置的文件，此时它是一个File对象，与通过文件输入字段取得的File对象一样。</p>\n<p>例子：</p>\n<pre><code><!DOCTYPE HTML>\n<html>\n<head>\n    <style</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在桌面上创建了自定义的放置目标后，可以从桌面上把文件拖放到该目标。与拖放一张图片或链接类似，从桌面上把文件拖放到浏览器中也会触发drop事件。而且可以在event.dataTransfer.files中读取到被放置的文件，此时它是一个File对象，与通过文件输入字段取得的File对象一样。</p>\n<p>例子：</p>\n<pre><code><!DOCTYPE HTML>\n<html>\n<head>\n    <style type=\"text/css\">\n        #dropTarget {width: 200px; height: 200px; background: #ccc; border: 1px solid #999;}\n    </style>\n</head>\n<body>\n<p>请把文件拖到下面的框里：</p>\n<div id=\"dropTarget\"></div>\n<div id=\"output\"></div>\n<script type=\"text/javascript\">\n    function dragHandle(event) {\n        var info = \"\",\n            outputEle = document.getElementById(\"output\"),\n            files, i, len;\n        event.preventDefault();\n        if(event.type == \"drop\") {\n            files = event.dataTransfer.files;\n            i = 0;\n            len = files.length;\n            while(i < len) {\n                info += files[i].name + \"( \" + files[i].type + \", \" + files[i].size + \" bytes) <br>\";\n                i++;\n            }\n            outputEle.innerHTML = info;\n        }\n    }\n    var dropTargetEle = document.getElementById(\"dropTarget\");\n    dropTargetEle.addEventListener(\"dragenter\", dragHandle, false);\n    dropTargetEle.addEventListener(\"dragover\", dragHandle, false);\n    dropTargetEle.addEventListener(\"drop\", dragHandle, false);\n</script>\n</body>\n</html>\n</code></pre>\n<p>与其他拖放示例一样，这里也必须取消dragenter、dragover和drop的默认行为。</p>\n<p>在drop事件中，可以通过event.dataTransfer.files读取文件信息。</p>\n<p><strong>读取拖放的文件的功能常用情景有：</strong></p>\n<ul>\n<li>结合XMLHttpRequest和拖放文件来实现上传。（最多）</li>\n<li>查看和管理本地图片。</li>\n<li>查看和管理本地音乐。</li>\n</ul>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/932\">http://www.dengzhr.com/frontend/html/932</a></div>\n\n        ','2','1'),(270,'canvas中的三角运动（4） —— 脉冲运动','\n\n            <h2>需求：</h2>\n<p><strong>模拟球形的脉冲运动</strong>。</p>\n<p>小球的构造函数如下：</p>\n<pre><code>// 圆球的构造函数\nfunction Ball(radius, color) {\n    if(radius === undefined) { radius = 40; }\n    if(color === undefined) { color = \"#ff0000\"; }\n    this.x = 0;\n    this.y = 0;\n    this.radius = radius;\n    this.rotation = 0;\n    this.scaleX = 1;\n    this.scaleY</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>需求：</h2>\n<p><strong>模拟球形的脉冲运动</strong>。</p>\n<p>小球的构造函数如下：</p>\n<pre><code>// 圆球的构造函数\nfunction Ball(radius, color) {\n    if(radius === undefined) { radius = 40; }\n    if(color === undefined) { color = \"#ff0000\"; }\n    this.x = 0;\n    this.y = 0;\n    this.radius = radius;\n    this.rotation = 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.color = color;\n    this.lineWidth = 1;\n}\nBall.prototype.draw = function(context) {\n    context.save();\n    context.translate(this.x, this.y);\n    context.rotate(this.rotation);\n    context.scale(this.scaleX, this.scaleY);\n    context.lineWidth = this.lineWidth;\n    context.fillStyle = this.color;\n    context.beginPath();\n    context.arc(0, 0, this.radius, 0, Math.PI * 2, true);\n    context.closePath();\n    context.fill();\n    if(this.lineWidth > 0) {\n        context.stroke();\n    }\n    context.restore();\n}\n</code></pre>\n<h2><a id=\"_5\"></a>二. 思路分析：</h2>\n<p>使用正弦值改变球形的比例，即可制造出脉冲效果。</p>\n<p>如下：</p>\n<pre><code><canvas id=\"canvas\" width=\"200\" height=\"200\" style=\"background: #ccc;\"></canvas>\n\nvar canvas = document.getElementById(\"canvas\"),\n    context = canvas.getContext(\"2d\"),\n    ball = new Ball(),\n    angle = 5,\n    centerScale = 1,\n    range = 0.5,\n    speed = 0.05;\n\n    ball.x = canvas.height / 2;\n    ball.y = canvas.height / 2;\n    ball.lineWidth = 0;\n\n(function drawFrame() {\n    window.requestAnimationFrame(drawFrame, canvas);\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    ball.scaleX = ball.scaleY = centerScale + Math.sin(angle) * range;\n    angle += speed;\n    ball.draw(context);\n})();\n</code></pre>\n<p>演示如下：<a href=\"http://codepen.io/dengzhirong/pen/PzgygG\">http://codepen.io/dengzhirong/pen/PzgygG</a></p>\n<p><iframe style=\"width: 100%;\" src=\"//codepen.io/dengzhirong/embed/PzgygG/?height=300&theme-id=15149&default-tab=result&embed-version=2\" width=\"300\" height=\"300\" frameborder=\"no\" scrolling=\"no\" allowfullscreen=\"allowfullscreen\">See the Pen <a href=\"http://codepen.io/dengzhirong/pen/PzgygG/\">PzgygG</a> by dengzhirong (<a href=\"http://codepen.io/dengzhirong\">@dengzhirong</a>) on <a href=\"http://codepen.io\">CodePen</a>.</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/959\">http://www.dengzhr.com/js/959</a></div>\n\n        ','2','1'),(271,'jQuery的Ajax实现方法总结','\n\n            <h2>一. jQuery中Ajax的基本语法</h2>\n<h3>1. Ajax 请求</h3>\n<h3>（1） $.ajax(url,[settings])</h3>\n<p>通过 HTTP 请求加载远程数据。$.ajax() 返回其创建的 XMLHttpRequest 对象。</p>\n<blockquote>\n<ul>\n<li>url:一个用来包含发送请求的URL字符串。</li>\n<li>settings:AJAX 请求设置。所有选项都是可选的。</li>\n</ul>\n</blockquote>\n<p>如果要处理$.ajax()得到的数据，则需要使用回调函数。回调函数主要有以下4个：</p>\n<blockquote>\n<ul>\n<li>1） beforeSend：在发送请求之前调用，并</li></ul></blockquote>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. jQuery中Ajax的基本语法</h2>\n<h3><a id=\"_5\"></a>1. Ajax 请求</h3>\n<h3><a id=\"_6\"></a>（1） $.ajax(url,[settings])</h3>\n<p>通过 HTTP 请求加载远程数据。$.ajax() 返回其创建的 XMLHttpRequest 对象。</p>\n<blockquote>\n<ul>\n<li>url:一个用来包含发送请求的URL字符串。</li>\n<li>settings:AJAX 请求设置。所有选项都是可选的。</li>\n</ul>\n</blockquote>\n<p>如果要处理$.ajax()得到的数据，则需要使用回调函数。回调函数主要有以下4个：</p>\n<blockquote>\n<ul>\n<li>1） beforeSend：在发送请求之前调用，并且传入一个XMLHttpRequest作为参数；</li>\n<li>2） error：在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话）；</li>\n<li>3） dataFilter：给Ajax返回的原始数据的进行预处理的函数。提供data和type两个参数：data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数；</li>\n<li>4） success：当请求成功之后调用。传入返回后的数据，以及包含成功代码的字符串；</li>\n<li>5） complete：当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串；</li>\n</ul>\n</blockquote>\n<p>setting的取值如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>值类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>accepts</td>\n<td>Map</td>\n<td>内容类型发送请求头，告诉服务器什么样的响应会接受返回。</td>\n</tr>\n<tr>\n<td>async</td>\n<td>Boolean</td>\n<td>表示异步或同步请求。取值为true时为异步请求（默认），取值为false为同步请求。</td>\n</tr>\n<tr>\n<td>beforeSend(XHR)</td>\n<td>Function</td>\n<td>发送请求前可修改 XMLHttpRequest 对象的函数。XMLHttpRequest 对象是唯一的参数。如果返回false可以取消本次ajax请求。</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>Boolean</td>\n<td>(默认: true,dataType为script和jsonp时默认为false)，设置为 false 将不缓存此页面。</td>\n</tr>\n<tr>\n<td>complete(XHR, TS)</td>\n<td>Function</td>\n<td>请求完成后回调函数 (请求成功或失败之后均调用)。参数： XMLHttpRequest 对象和一个描述成功请求类型的字符串。</td>\n</tr>\n<tr>\n<td>contents</td>\n<td>Map</td>\n<td>一个以\"{字符串:正则表达式}\"配对的对象，用来确定jQuery将如何解析响应，给定其内容类型。</td>\n</tr>\n<tr>\n<td>contentType</td>\n<td>String</td>\n<td>发送信息至服务器时内容编码类型。默认: \"application/x-www-form-urlencoded\"。</td>\n</tr>\n<tr>\n<td>context</td>\n<td>Object</td>\n<td>这个对象用于设置Ajax相关回调函数的上下文。</td>\n</tr>\n<tr>\n<td>converters</td>\n<td>Map</td>\n<td>一个数据类型对数据类型转换器的对象。每个转换器的值是一个函数，返回响应的转化值。默认： {\"* text\": window.String, \"text html\": true, \"text json\": jQuery.parseJSON, \"text xml\": jQuery.parseXML}</td>\n</tr>\n<tr>\n<td>crossDomain</td>\n<td>Map</td>\n<td>默认： 同域请求为false。跨域请求为true如果你想强制跨域请求（如JSONP形式）同一域，设置crossDomain为true。</td>\n</tr>\n<tr>\n<td>data</td>\n<td>Object,String</td>\n<td>发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。</td>\n</tr>\n<tr>\n<td>dataFilter</td>\n<td>Function</td>\n<td>给Ajax返回的原始数据的进行预处理的函数。提供data和type两个参数：data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。</td>\n</tr>\n<tr>\n<td>dataType</td>\n<td>String</td>\n<td>预期服务器返回的数据类型。可用值有：xml、html、script、json、jsonp、text。</td>\n</tr>\n<tr>\n<td>error</td>\n<td>Function</td>\n<td>请求失败时调用此函数。</td>\n</tr>\n<tr>\n<td>global</td>\n<td>Boolean</td>\n<td>(默认: true) 是否触发全局 AJAX 事件。设置为 false 将不会触发全局 AJAX 事件。</td>\n</tr>\n<tr>\n<td>headers</td>\n<td>Map</td>\n<td>消息头。</td>\n</tr>\n<tr>\n<td>ifModified</td>\n<td>Boolean</td>\n<td>默认:为false，表示仅在服务器数据改变时获取新数据。</td>\n</tr>\n<tr>\n<td>isLocal</td>\n<td>Map</td>\n<td>默认值取决于当前的位置协议。允许当前环境被认定为“本地”，（如文件系统）。</td>\n</tr>\n<tr>\n<td>jsonp</td>\n<td>String</td>\n<td>在一个jsonp请求中重写回调函数的名字。</td>\n</tr>\n<tr>\n<td>jsonpCallback</td>\n<td>String</td>\n<td>为jsonp请求指定一个回调函数名。这个值将用来取代jQuery自动生成的随机函数名。</td>\n</tr>\n<tr>\n<td>mimeType</td>\n<td>String</td>\n<td>一个mime类型用来覆盖XHR的 MIME类型。</td>\n</tr>\n<tr>\n<td>password</td>\n<td>String</td>\n<td>用于响应HTTP访问认证请求的密码。</td>\n</tr>\n<tr>\n<td>processData</td>\n<td>Boolean</td>\n<td>通过data选项传递进来的数据是否被转换处理。默认为true。</td>\n</tr>\n<tr>\n<td>scriptCharset</td>\n<td>String</td>\n<td>只有当请求时dataType为\"jsonp\"或\"script\"，并且type是\"GET\"，才会用于强制修改charset。通常只在本地和远程的内容编码不同时使用。</td>\n</tr>\n<tr>\n<td>statusCode</td>\n<td>Map</td>\n<td>一组数值的HTTP代码和函数对象，当响应时调用了相应的代码。</td>\n</tr>\n<tr>\n<td>success(data, textStatus, jqXHR)</td>\n<td>Function,Array</td>\n<td>请求成功后的回调函数。</td>\n</tr>\n<tr>\n<td>traditional</td>\n<td>Boolean</td>\n<td>如果想要用传统的方式来序列化数据，那么就设置为true。</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>Number</td>\n<td>设置请求超时时间（毫秒）。</td>\n</tr>\n<tr>\n<td>type</td>\n<td>String</td>\n<td>请求方式有\"POST\" 和 \"GET\"， 默认为 \"GET\"。</td>\n</tr>\n<tr>\n<td>url</td>\n<td>String</td>\n<td>(默认: 当前页地址) 发送请求的地址。</td>\n</tr>\n<tr>\n<td>username</td>\n<td>String</td>\n<td>用于响应HTTP访问认证请求的用户名。</td>\n</tr>\n<tr>\n<td>xhr</td>\n<td>Function</td>\n<td>需要返回一个XMLHttpRequest 对象。默认在IE下是ActiveXObject 而其他情况下是XMLHttpRequest 。用于重写或者提供一个增强的XMLHttpRequest 对象。</td>\n</tr>\n<tr>\n<td>xhrFields</td>\n<td>Map</td>\n<td>一对“文件名-文件值”在本机设置XHR对象。例如，如果需要的话，你可以用它来设置withCredentials为true的跨域请求。</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"_7\"></a>（2） load(url, [data], [callback])</h3>\n<p>载入远程 HTML 文件代码并插入至 DOM 中。参数如下：</p>\n<blockquote>\n<ul>\n<li>url:待装入 HTML 网页网址。</li>\n<li>data:发送至服务器的 key/value 数据。</li>\n<li>callback:载入成功时回调函数。</li>\n</ul>\n</blockquote>\n<p>实例：</p>\n<pre><code class=\"lang-javascript\">$(\"#feeds\").load(\"login.aspx\", {limit: 25}, function(){\n   // ...\n });\n</code></pre>\n<h3><a id=\"_8\"></a>（3） $.get(url,[data],[fn],[type])</h3>\n<p>通过远程 HTTP GET 请求载入信息。这是一个简单的 GET 请求功能以取代复杂 $.ajax 。请求成功时可调用回调函数。</p>\n<p>实例：</p>\n<pre><code class=\"lang-javascript\">$.get(\"login.aspx\", { name: \"John\", time: \"2pm\" },\n  function(data){\n    // ...\n  });\n</code></pre>\n<h3><a id=\"_9\"></a>（4） $.getJSON(url,[data],[fn])</h3>\n<p>通过 HTTP GET 请求载入 JSON 数据。您可以通过使用JSONP形式的回调函数来加载其他网域的JSON数据，如 \"myurl?callback=?\"。jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 注意：此行以后的代码将在这个回调函数执行前执行。</p>\n<p>实例：</p>\n<pre><code class=\"lang-javascript\">$.getJSON(\"test.js\", { name: \"John\", time: \"2pm\" }, function(json){\n  alert(\"JSON Data: \" + json.users[3].name);\n});\n</code></pre>\n<h3><a id=\"_10\"></a>（5） $.getScript(url,[callback])</h3>\n<p>通过 HTTP GET 请求载入并执行一个 JavaScript 文件。可以跨域调用 JavaScript 文件。</p>\n<p>实例：</p>\n<pre><code class=\"lang-javascript\">$.getScript(\"test.js\");\n</code></pre>\n<h3><a id=\"_11\"></a>（6） $.post(url,[data],[fn],[type])</h3>\n<p>通过远程 HTTP POST 请求载入信息。这是一个简单的 POST 请求功能以取代复杂 $.ajax 。请求成功时可调用回调函数。</p>\n<p>实例：</p>\n<pre><code class=\"lang-javascript\">$.post(\"login.aspx\", { name: \"John\", time: \"2pm\" },\n   function(data){\n     // ...\n   });\n</code></pre>\n<h3><a id=\"_12\"></a>2. Ajax 事件</h3>\n<h3><a id=\"_13\"></a>（1） ajaxComplete(callback)</h3>\n<p>AJAX 请求完成时执行函数。XMLHttpRequest 对象和设置作为参数传递给回调函数。</p>\n<p>实例：</p>\n<pre><code class=\"lang-javascript\">$(\"#msg\").ajaxComplete(function(event,request, settings){\n   $(this).append(\"<li>请求完成.</li>\");\n });\n</code></pre>\n<h3><a id=\"_14\"></a>（2） ajaxError(callback)</h3>\n<p>AJAX 请求发生错误时执行函数。XMLHttpRequest 对象和设置作为参数传递给回调函数。捕捉到的错误可作为最后一个参数传递。</p>\n<p>实例：</p>\n<pre><code class=\"lang-javascript\">$(\"#msg\").ajaxError(function(event,request, settings){\n     $(this).append(\"<li>出错页面:\" + settings.url + \"</li>\");\n});\n</code></pre>\n<h3><a id=\"_15\"></a>（3） ajaxSend(callback)</h3>\n<p>AJAX 请求发送前执行函数。</p>\n<h3><a id=\"_16\"></a>（4） ajaxStart(callback)</h3>\n<p>AJAX 请求开始时执行函数。</p>\n<h3><a id=\"_17\"></a>（5） ajaxStop(callback)</h3>\n<p>AJAX 请求结束时执行函数。</p>\n<h3><a id=\"_18\"></a>（6） ajaxSuccess(callback)</h3>\n<p>AJAX 请求成功时执行函数。</p>\n<h3><a id=\"_19\"></a>3. 其它</h3>\n<h3><a id=\"_20\"></a>（1） $.ajaxPrefilter([type],fn)</h3>\n<p>指定预先处理Ajax参数选项的回调函数。 </p>\n<h3><a id=\"_21\"></a>（2） $.ajaxSetup([options])</h3>\n<p>设置全局 AJAX 默认选项。参数与 \'$.ajax\'相同。</p>\n<h3><a id=\"_22\"></a>（3） serialize()</h3>\n<p>序列表化表单内容为字符串。</p>\n<h3><a id=\"_23\"></a>（4） serializearray()</h3>\n<p>序列化表单元素(类似 \'.serialize()\' 方法) 返回 JSON 数据结构数据。此方法返回的是JSON对象而非JSON字符串。</p>\n<h2><a id=\"_24\"></a>二. jQuery的Ajax实现方法</h2>\n<h3><a id=\"_25\"></a>1. $.get()</h3>\n<p>采用GET方式向服务器请求数据，并通过方法中回调函数的参数返回请求的数据。一般通过超链接的方式传递数据。</p>\n<p>语法： <strong>$.get(url,[callback])</strong></p>\n<p>实例：</p>\n<pre><code class=\"lang-javascript\">$.get(\"login.aspx?id=1&name=lemoo\",function(data,status){\n    alert(\"Data: \" + data + \"\\nStatus: \" + status);\n  });\n</code></pre>\n<h3><a id=\"_26\"></a>2. $.post()</h3>\n<p>post()方法多用于以POST方式向服务器发送数据，服务器接收到数据之后，进行处理，并将处理结果返回页面。</p>\n<p>语法： <strong>$.post(url,[data],[callback])</strong></p>\n<p>实例：</p>\n<pre><code class=\"lang-javascript\">$.post(\"login.aspx\", {id: 1, name: lemoo}, function (data) {\n  alert(data);\n});\n</code></pre>\n<h3><a id=\"_27\"></a>3. $.ajax</h3>\n<p>ajax()方法是最底层、功能最强大的请求服务器数据的方法，它不仅可以获取服务器返回的数据，还能向服务器发送请求并传递数值。</p>\n<p>语法： <strong>$.ajax([settings])</strong></p>\n<p>实例：</p>\n<pre><code class=\"lang-javascript\">$.ajax({\n  type:\"post\",\n  url:\"login.aspx\",\n  data: {id: 1, name: lemoo},\n  dataType:\"text\",\n  success: function (data) {\n    alert(data);\n  }\n});\n</code></pre>\n<h3><a id=\"_28\"></a>4. getJSON()</h3>\n<p>使用getJSON()方法可以通过Ajax异步请求的方式，获取服务器中的数组，并对获取的数据进行解析。可以用$.each()来遍历数据。</p>\n<p>语法： <strong>$.getJSON(url,[data],[callback])</strong></p>\n<p>实例：</p>\n<pre><code class=\"lang-javascript\">$.getJSON(\"login.aspx\",function(data){\n  $.each(data, function (index, sport) {\n    if(index==3)\n      $(\"ul\").append(\"<li>\" + sport[\"name\"] + \"</li>\");\n  });\n});\n</code></pre>\n<h2><a id=\"_29\"></a>三. Ajax在Chrome浏览器下的调试</h2>\n<p>在运行Ajax的页面按F12进入控制台，进入“Network”选项卡，点击\"XHR\"过滤器，然后触发Ajax的事件，进入Ajax详情页。<br>\n<img src=\"http://www.dengzhr.com/wp-content/uploads/2015/10/ajax-f12-1.png\" alt=\"此处输入图片的描述\"></p>\n<blockquote>\n<ul>\n<li><strong>Request URL</strong>：查看请求的地址；</li>\n<li><strong>Request Method</strong>：请求的方式，查看是GET或者POST，GET请求的参数一致的话会有缓存；</li>\n<li><strong>Status Code</strong>：返回状态码；</li>\n</ul>\n</blockquote>\n<p>如果向后台发送数据，在“Headers”选项下还会有“<strong>Query String Parameters</strong>”目录，是向后台发送的数据，一般这里看参数是否有问题，格式及命名是否正确。</p>\n<p>点击“Response”选项就可以查看服务器返回的数据了，一般在这里查看返回是否正常，格式是否正确。</p>\n<p><img src=\"http://www.dengzhr.com/wp-content/uploads/2015/10/ajax-f12-2.png\" alt=\"此处输入图片的描述\"></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/jquery/579\">http://www.dengzhr.com/js/jquery/579</a></div>\n\n        ','2','1'),(272,'正则表达式 学习笔记整理','\n\n            <h2>一. 正则表达式语法</h2>\n<h2>1. 元字符</h2>\n<h3>1.1 匹配字符</h3>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td>匹配除换行符以外的任意字；</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母、数字、下划线或行字</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配任意非字母、数字、下划线或汉字的字符</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任意的空白符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任意非空白符的字符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配数字</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配任意非数字的字符</td>\n</tr>\n</tbody>\n</table>\n<h3>1.2 匹配位置</h3>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\b</td>\n<td>匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配不是单词开口或结束的位置</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配字符串的开始</td>\n</tr>\n<tr>\n<td>\\$</td>\n<td>匹配字符串的结束</td>\n</tr>\n<tr>\n<td>\\G</td>\n<td>上一个匹配的结尾（本次匹配开始）</td>\n</tr>\n<tr>\n<td>\\A</td>\n<td>字符串开头（类�</td></tr></tbody></table>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>一. 正则表达式语法</h2>\n<h2><a id=\"_5\"></a>1. 元字符</h2>\n<h3><a id=\"_6\"></a>1.1 匹配字符</h3>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td>匹配除换行符以外的任意字；</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母、数字、下划线或行字</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配任意非字母、数字、下划线或汉字的字符</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任意的空白符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任意非空白符的字符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配数字</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配任意非数字的字符</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"_7\"></a>1.2 匹配位置</h3>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\b</td>\n<td>匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配不是单词开口或结束的位置</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配字符串的开始</td>\n</tr>\n<tr>\n<td>\\$</td>\n<td>匹配字符串的结束</td>\n</tr>\n<tr>\n<td>\\G</td>\n<td>上一个匹配的结尾（本次匹配开始）</td>\n</tr>\n<tr>\n<td>\\A</td>\n<td>字符串开头（类似^，但不受处理多行选项的影响）</td>\n</tr>\n<tr>\n<td>\\Z</td>\n<td>字符串结尾或行尾（不受多行选项的影响）</td>\n</tr>\n<tr>\n<td>\\z</td>\n<td>字符串结尾（类似$，但不受处理多行选项的影响）</td>\n</tr>\n</tbody>\n</table>\n<h3><a id=\"_8\"></a>1.3 重复</h3>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td>重复匹配零次或更多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td>重复匹配一次或多次</td>\n</tr>\n<tr>\n<td>?</td>\n<td>重复匹配零次或一次</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>重复匹配n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>重复匹配n次或更多次</td>\n</tr>\n<tr>\n<td>{n, m}</td>\n<td>重复匹配n到m次</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_9\"></a>2. 字符转义</h2>\n<p>需要转义的字符有：$, (, ), *, +, ., [, ], ?, \\, ^, {, }, |。</p>\n<h2><a id=\"_10\"></a>3. 字符类</h2>\n<table>\n<thead>\n<tr>\n<th>特殊字符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\0hh</td>\n<td>8进制值所表示的字符</td>\n</tr>\n<tr>\n<td>\\xhh</td>\n<td>16进制值hh所表示的字符</td>\n</tr>\n<tr>\n<td>\\uhhhh</td>\n<td>16进制值hhhh所表示的Unicode字符</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>制表符（Tab键）</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>垂直制表符</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行符</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车符</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>换页符</td>\n</tr>\n<tr>\n<td>\\e</td>\n<td>Escape</td>\n</tr>\n<tr>\n<td>\\cN</td>\n<td>ASCII控制字符</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_11\"></a>4. 零宽断言</h2>\n<p>零宽断言表示匹配字符的时候再添加一些定位条件，使匹配更精准。</p>\n<table>\n<thead>\n<tr>\n<th>正则表达式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\w+(?=ing)</td>\n<td>匹配以ing结尾的多个字符（不包括ing）</td>\n</tr>\n<tr>\n<td>\\w+(?!ing)</td>\n<td>匹配不是以ing结尾的多个字符</td>\n</tr>\n<tr>\n<td>(?<=re)\\w+</td>\n<td>匹配不是以re开头的多个字符（不包括re）</td>\n</tr>\n<tr>\n<td>(?<!re)\\w+</td>\n<td>匹配不是以re开头的多个字符</td>\n</tr>\n<tr>\n<td>(?<=\\s)\\d+(?=\\s)</td>\n<td>匹配两边是空白符的数字，不包括空白符</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_12\"></a>5. 贪婪与懒惰</h2>\n<p>贪婪： 匹配尽可能长的字符串；</p>\n<p>懒惰：匹配尽可能短的字符串；</p>\n<p>懒惰模式的启用只需在重复元字符之后加上?即可。</p>\n<table>\n<thead>\n<tr>\n<th>正则表达式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*?</td>\n<td>重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>+?</td>\n<td>重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>??</td>\n<td>重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n, m}?</td>\n<td>重复n到m次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>重复n次以上，但尽可能少重复</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_13\"></a>二. JavaScript中正则表达式的处理</h2>\n<p>JavaScript中在String和RegEx对象中，实现正则<br>\n表达式处理的方法有以下几个：</p>\n<h3><a id=\"_14\"></a>1. String方法</h3>\n<p><strong>match(searchvalue | regexp)</strong>：在字符串内检索指定的值，返回匹配结果的数组；</p>\n<p><strong>replace(regexp/substr,replaceText)</strong>：在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串；返回一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的；</p>\n<p><strong>search(regexp)</strong>：检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，返回字符串中第一个与 regexp 相匹配的子串的起始位置，如果没有找到任何匹配的子串则返回 -1；</p>\n<p><strong>split(separator,arrayMaxLength)</strong>：把一个字符串分割成字符串数组，返回分割后的字符串数组；</p>\n<h3><a id=\"_15\"></a>2. RegEx方法</h3>\n<p><strong>exec(string)</strong>：检索字符串中的正则表达式的匹配，返回一个匹配结果的数组。如果未找到匹配，则返回值为 null；</p>\n<p><strong>test(string)</strong>：检测一个字符串是否匹配某个模式，返回Boolean值；</p>\n<h2><a id=\"_16\"></a>三. 正则表达式的应用例子</h2>\n<p><strong>匹配中文字符：</strong>  \\u4e00-\\u9fa5</p>\n<p><strong>匹配空行：</strong>  \\n[\\s| ]*\\r</p>\n<p><strong>匹配HTML标记：</strong>  <(.<em>)>.</em><\\/\\1>|<(.* \\/)></p>\n<p><strong>匹配首尾空格：</strong>  (^\\s<em>)|(\\s</em>$)</p>\n<p><strong>验证Email地址：</strong>  ^\\w+[-+.]\\w+<em>@\\w+([-.]\\w+)</em>.\\w+([-.]\\w+)*$</p>\n<p><strong>验证网址URL：</strong>  </p>\n<p><strong>验证电话号码：</strong>  ^((\\d{3,4})|\\d{3,4}-)?\\d{7,8}$</p>\n<p>【备注：电话号码的正确格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX】</p>\n<p><strong>验证Html 16进制颜色值：</strong>  ^#?([a-f]|[A-F]|[0-9]){3}(([a-f]|[A-F]|[0-9]){3})?$</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/539\">http://www.dengzhr.com/js/539</a></div>\n\n        ','2','1'),(273,'jQuery动态创建元素的事件绑定问题解决方法','\n\n            <p>最近项目需要，希望能用jQuery实现To Do List的效果。想着这功能应该很简单呀，不就是一个节点的动态增删嘛。刷刷刷的代码就写出来了，如下：</p>\n<p>HTML代码：</p>\n<pre><code class=\"lang-html\"><ul class=\"pageList\" id=\"pageList\">\n</ul>\n<span id=\"addPage\" class=\"addPage\">Add</span></code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>最近项目需要，希望能用jQuery实现To Do List的效果。想着这功能应该很简单呀，不就是一个节点的动态增删嘛。刷刷刷的代码就写出来了，如下：</p>\n<p>HTML代码：</p>\n<pre><code class=\"lang-html\"><ul class=\"pageList\" id=\"pageList\">\n</ul>\n<span id=\"addPage\" class=\"addPage\">Add</span>\n<script src=\"jquery.min.js\"></script>\n</code></pre>\n<p>jQuery代码：</p>\n<pre><code class=\"lang-javascript\">$(\"#addPage\").click(function() {\n    // 刷新当前页列表\n    function getCurrentPageCount() {\n        return $(\"#pageList li\").length;\n    }\n\n    // 添加列表项\n    var pageListItemDeleteBtn = $(\"<span>\").addClass(\"page-delete\");\n    var pageListItem = $(\"<li>\").addClass(\"active\").html(\"Page\" + (getCurrentPageCount() + 1)).append(pageListItemDeleteBtn);\n    $(\"#pageList\").append(pageListItem);\n});\n\n$(\".page-delete\").click(deletePageListItem);\n\n// 删除上级节点\nfunction deletePageListItem() {\n    $(this).parent().remove();\n}\n</code></pre>\n<p>加上修饰版的CSS，显示效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/LpXNrR/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/LpXNrR/\'>LpXNrR</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p>新增列表没问题。但是！新添加的列表都不能通过点击删除按钮删除当前列表项。</p>\n<p>尝试将动态生成的DOM改成页面加载时静态载入，即直接在ul#pageList节点下直接添加“<code><li class=\"active\">Page1<span class=\"page-delete\"></span></li></code>”，发现删除按钮确实有删除功能的。</p>\n<p>猜想动态创建的元素不能自动绑定事件，所以导致了新常见的PageListItem中动态创建的pageListItemDeleteBtn元素并没有绑定<code>$(\".page-delete\")</code>的click事件，因此功能失效。</p>\n<p>于是尝试为动态创建的ageListItemDeleteBtn元素增添click事件绑定<code>pageListItemDeleteBtn.click(deletePageListItem)</code>后，动态创建的删除按钮也具有了删除列表项功能。</p>\n<p>所以，jQuery动态创建的元素不能自动绑定事件。</p>\n<p>最好的方法是，<strong>在动态创建元素的时候，就给每一个元素重复绑定事件。</strong></p>\n<p>如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/BoGzaq/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/BoGzaq/\'>BoGzaq</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/jquery/632\">http://www.dengzhr.com/js/jquery/632</a></div>\n\n        ','2','1'),(274,'JavaScript动画详解(三) —— 弹动动画','\n\n            <p>缓动和弹动都是那对象从已有位置移动到目标位置的方法。但是缓动是指物体滑动到目标点就停下来；而弹动是指物体来回反弹一段时间后，最终停在目标点的运动。</p>\n<p>弹动，大多数时候，物体的加速度与它到目标点的距离是成比例的。</p>\n<p>来看一个在现实中弹动的例子：在橡皮筋的一头系上一个小球，另一头固定起来。小球的目标点就是它初始静止悬空的那个位置点。将小球拉开一小段距离然后松开，刚松手那一瞬间，它的速�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>缓动和弹动都是那对象从已有位置移动到目标位置的方法。但是缓动是指物体滑动到目标点就停下来；而弹动是指物体来回反弹一段时间后，最终停在目标点的运动。</p>\n<p>弹动，大多数时候，物体的加速度与它到目标点的距离是成比例的。</p>\n<p>来看一个在现实中弹动的例子：在橡皮筋的一头系上一个小球，另一头固定起来。小球的目标点就是它初始静止悬空的那个位置点。将小球拉开一小段距离然后松开，刚松手那一瞬间，它的速度为0，但是橡皮筋给它施加了外力，把它拉向目标点；如果小球尽可能地拉远，橡皮筋对它施加的外力就会变得越大。松手后，小球会急速飞过目标点。但是，当它飞过目标点以后，橡皮筋又把它往回拉，使其加速度减小，它飞得越远，橡皮筋施加的力就越大；最终，它的速度降为0，又掉头往回飞。由于受到摩擦力的影响，反复几次后，小球的运动逐渐慢下来，停在目标点上。</p>\n<h2><a id=\"_4\"></a>一. 一维坐标上的弹动</h2>\n<p>1 . 首先需要一个变量存储弹性比例系数，取值为0~1，较大的弹性比例常熟会表现出较硬的弹簧效果。</p>\n<pre><code>var spring = 0.1,\n    targetX = canvas.width / 2,\n    vx = 0;\n</code></pre>\n<p>2 . 接下来，计算小球到目标点的距离</p>\n<pre><code class=\"lang-javascript\">var dx = targetX - ball.x;\n</code></pre>\n<p>3 . 计算加速度。在这个例子中，我们设置小球的加速度与距离成正比，即加速度 = 小球到目标点的距离 × 弹性比例系数。</p>\n<pre><code class=\"lang-javascript\">var ax = dx * spring;\n</code></pre>\n<p>4 . 把加速度累加到速度上，然后把速度累加到小球的当前位置上：</p>\n<pre><code class=\"lang-javascript\">vx += ax;\nball.x += vx;\n</code></pre>\n<p>在开始写代码前，先模拟一下整个过程，假设ball.x = 0，初速度vx = 0，目标点的位置targetX = 100，弹性比例系数spring = 0.1。下面是执行过程：</p>\n<p>(1) 第一轮，加速度ax = (100 – 0) * 0.1 = 10，把ax加载vx上得速度vx = 10，把vx加在小球的当前位置上得到ball.x = 10；</p>\n<p>(2) 第二轮，加速度ax = (100 – ball.x) * 0.1 = 9，由此得到vx = 10 + 9 = 19，ball.x = 10 + 19 = 29；</p>\n<p>(3) 第三轮，ax = 7.1， vx = 26.1，ball.x = 55.1；</p>\n<p>(4) 第四轮， ax = 4.49，vx = 30.59，ball.x = 85.69;</p>\n<p>(5) 第五轮， ax = 1.431，vx = 44.9，ball.x = 130.69:</p>\n<p>(6) 第六轮，ax = -3.069，vx = 41.831，ball.x = 88.859；</p>\n<p>… …</p>\n<p>随着小球一帧一帧地靠近目标，加速度变得越来越小，但是速度一直在增加；</p>\n<p>五轮过后，小球越过了目标点后，加速度变成反向加速度，并且逐渐增加，导致速度逐渐减小，最终速度为0后，反向加速度达到极大值。此时速度将变成反向速度。</p>\n<p>HTML代码如下：</p>\n<pre><code class=\"lang-html\"><canvas id=\"canvas\" width=\"600\" height=\"100\"></canvas>\n</code></pre>\n<p>JavaScript代码如下：</p>\n<pre><code class=\"lang-javascript\">// requestAnimationFrame的兼容性写法\nwindow.requestAnimFrame = (function(){\n    return  window.requestAnimationFrame       ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame    ||\n            window.oRequestAnimationFrame      ||\n            window.msRequestAnimationFrame     ||\n            function( callback ){\n                window.setTimeout(callback, 1000 / 60);\n            };\n})();\n\n// cancelAnimationFrame的兼容性写法\nwindow.cancelAnimationFrame = (function () {\n    return window.cancelAnimationFrame ||\n            window.webkitCancelAnimationFrame ||\n            window.mozCancelAnimationFrame ||\n            window.oCancelAnimationFrame ||\n            function (timer) {\n                window.clearTimeout(timer);\n            };\n})();\n\n// 创建画球函数\nfunction Ball() {\n    this.x = 0;\n    this.y = 0;\n    this.radius = 10;\n    this.fillStyle = \"#f85455\";\n    this.draw = function(cxt) {\n        cxt.fillStyle = this.fillStyle;\n        cxt.beginPath();\n        cxt.arc(this.x, this.y, this.radius,  0, 2 * Math.PI, true);\n        cxt.closePath();\n        cxt.fill();\n    }\n}\n\nvar canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\"),\n        ball = new Ball(),\n        spring = 0.1,\n        targetX = canvas.width / 2,\n        vx = 0;\nball.x = 20;\nball.y = 20;\n\n// 缓动动画函数\nvar animRequest = null;\n(function drawFrame() {\n    animRequest = window.requestAnimationFrame(drawFrame, canvas);\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    // 小球当前位置与目标点的距离\n    var dx = targetX - ball.x;\n    // 小球的加速度\n    var ax = dx * spring;\n    // 小球的速度\n    vx += ax;\n    // 计算出小球当前的位置\n    ball.x += vx;\n    ball.draw(context);\n})();\n</code></pre>\n<p>实现的效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/EVNWqL/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/EVNWqL/\'>EVNWqL</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p>但是！但是，问题是小球永远都不会停下来，因为小球的摆动幅度不变。而我们希望实现的例子中，小球的弹动会越来越慢，直到停止下来。在实际生活中，小球的弹动势能大多是由于摩擦力的存在而转化成内能，最后使小球停下。所以，在这里，我们也模拟摩擦力，创建摩擦力系数friction，取值范围为0~1。</p>\n<pre><code class=\"lang-javascript\">var friction = 0.95;\n</code></pre>\n<p>然后把vx * friction，得到当前的速度vx。</p>\n<pre><code class=\"lang-javascript\">vx * = friction;\n</code></pre>\n<p>最终效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/GpNmRR/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/GpNmRR/\'>GpNmRR</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p>【备注：请按F5刷新，或者点击“Result”面板上悬浮的\"Return\"按钮后查看效果】</p>\n<h2><a id=\"_5\"></a>二. 二维坐标上的弹动</h2>\n<p>上面一个例子是让小球在x轴上运动。如果我们想让小球同时在x轴和y轴上运动，就需要引入二维坐标上的弹动。事实上很简单，只需要把目标点、速度和加速度扩展到二维坐标系上即可。</p>\n<p>代码与上面例子雷同不再重复，直接上效果：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/ojYWgm/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/ojYWgm/\'>ojYWgm</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p>【备注：请按F5刷新，或者点击“Result”面板上悬浮的\"Return\"按钮后查看效果】</p>\n<p>与前一个例子唯一不同的是增加了一条y轴。但是现在小球看起来仍然像是一维运动，虽然小球同时在x轴和y轴上运动，但它仍然是一条直线。原因是它的初速度为0，也仅受一个把它拉向目标点的外力，所以它沿着直线运动。为了动画更丰富一点，可以尝试修改vx、vy或者不同x、y轴的friction值。自己尝试一下吧。</p>\n<h2><a id=\"_6\"></a>三. 目标点移动的弹动</h2>\n<p>目标点移动，我们很容易就想到把鼠标当成目标点。在上一篇介绍缓动动画时，有一个小球跟随鼠标的缓动动画。让小球跟随鼠标弹动同样很简单，只要把targetX和targetY替换为当前坐标即可。效果很炫酷，但是代码基本没变。只要在前面的例子中改动如下两行：</p>\n<pre><code class=\"lang-javascript\">var dx = targetX - ball.x;\nvar dy = targetY - ball.y;\n</code></pre>\n<p>修改为：</p>\n<pre><code class=\"lang-javascript\">var dx = mouse.x - ball.x;\nvar dy = mouse.y - ball.y;\n</code></pre>\n<p>当然，我们还需要写一个获得当前鼠标位置的函数，可以参考我写的博文《<a href=\"http://www.dengzhr.com/frontend/js/447\">JavaScript动画详解(一) —— 循环与事件监听</a>》</p>\n<p>完整代码如下：</p>\n<p>HTML代码：</p>\n<pre><code class=\"lang-html\"><canvas id=\"canvas\" width=\"400\" height=\"400\"></canvas>\n</code></pre>\n<p>JavaScript代码：</p>\n<pre><code class=\"lang-javascript\">// requestAnimationFrame的兼容性写法\nwindow.requestAnimFrame = (function(){\n    return  window.requestAnimationFrame       ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame    ||\n            window.oRequestAnimationFrame      ||\n            window.msRequestAnimationFrame     ||\n            function( callback ){\n                window.setTimeout(callback, 1000 / 60);\n            };\n})();\n\n// cancelAnimationFrame的兼容性写法\nwindow.cancelAnimationFrame = (function () {\n    return window.cancelAnimationFrame ||\n            window.webkitCancelAnimationFrame ||\n            window.mozCancelAnimationFrame ||\n            window.oCancelAnimationFrame ||\n            function (timer) {\n                window.clearTimeout(timer);\n            };\n})();\n\n// 获得当前鼠标位置\nfunction getMouse(ev) {\n    var mouse = {\n        x: 0,\n        y: 0\n    };\n    var event = ev || window.event;\n    if(event.pageX || event.pageY) {\n        x = event.x;\n        y = event.y;\n    }else {\n        var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n        x = event.clientX + scrollLeft;\n        y = event.clientY + scrollTop;\n    }\n    mouse.x = x;\n    mouse.y = y;\n\n    return mouse;\n}\n\n// 创建画球函数\nfunction Ball() {\n    this.x = 0;\n    this.y = 0;\n    this.radius = 10;\n    this.fillStyle = \"#f85455\";\n    this.draw = function(cxt) {\n        cxt.fillStyle = this.fillStyle;\n        cxt.beginPath();\n        cxt.arc(this.x, this.y, this.radius,  0, 2 * Math.PI, true);\n        cxt.closePath();\n        cxt.fill();\n    }\n}\n\nvar canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\"),\n        ball = new Ball(),\n        spring = 0.05,\n        vx = 0,\n        vy = 0,\n        targetX = 0,\n        targetY = 0,\n        friction = 0.95;\nball.x = 20;\nball.y = 20;\nvar mouse = {x: 0, y: 0};\n\ncanvas.addEventListener(\"mousemove\", function(ev) {\n    mouse = getMouse(ev);\n    targetX = mouse.x;\n    targetY = mouse.y;\n    console.log(targetX + \" , \" + targetY);\n}, false);\n// 缓动动画函数\nvar animRequest = null;\n(function drawFrame() {\n    animRequest = window.requestAnimationFrame(drawFrame, canvas);\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    // 小球当前位置与目标点的距离\n    var dx = targetX - ball.x;\n    var dy = targetY - ball.y;\n    // 小球的加速度\n    var ax = dx * spring;\n    var ay = dy * spring;\n    // 小球的速度\n    vx += ax;\n    vy += ay;\n    vx *= friction;\n    vy *= friction;\n    // 计算出小球当前的位置\n    ball.x += vx;\n    ball.y += vy;\n    ball.draw(context);\n})();\n</code></pre>\n<p>效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/LpbyGq/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/LpbyGq/\'>LpbyGq</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p>【备注：把鼠标移上去试试~】</p>\n<p>好吧，上面这个例子不够带劲儿，希望使小球看起来像是栓在橡皮筋上，此时只要在上面的基础上再小球圆心与当前鼠标位置画线即可。</p>\n<pre><code class=\"lang-javascript\">context.beginPath();\ncontext.strokeStyle = \"#71A4AD\";\ncontext.moveTo(ball.x, ball.y);\ncontext.lineTo(mouse.x, mouse.y);\ncontext.stroke();\n</code></pre>\n<p>效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/NGbjRd/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/NGbjRd/\'>NGbjRd</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<h2><a id=\"_7\"></a>四. 总结</h2>\n<p>弹动和缓动非常类似，都是使用循环函数逐帧绘制从当前位置到目标位置的运动效果。不同的是缓动是指速度与距离成比例，而弹动是加速度与距离成比例关系。但是要模拟出更加真实的弹动，可能需要加入类似摩擦力系数的因子，把速度逐渐降下，直到停止运动。</p>\n<p>相关文章：</p>\n<p>1 . 《<a href=\"http://www.dengzhr.com/frontend/html/494\">JavaScript动画详解(二) —— 缓动动画</a>》</p>\n<p>2 . 《<a href=\"http://www.dengzhr.com/frontend/js/447\">JavaScript动画详解(一) —— 循环与事件监听</a>》</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/501\">http://www.dengzhr.com/frontend/html/501</a></div>\n\n        ','2','1'),(275,'JavaScript用户交互：移动物体','\n\n            <p>交互动画的一个主要目标是创建出流畅的用户体验，其中大多数的用户交互都是通过鼠标和触摸屏实现的。</p>\n<p>在这篇博文中，我想分享一些JS对于物体移动的常见用法，包括拖拽和投掷效果。</p>\n<h2>一. 使用鼠标事件</h2>\n<p>可以将一个鼠标单击事件分解成两个事件：鼠标按下事件和按键弹起事件。通常情况下这两个事件是同时发生的。不过，有时鼠标按下后，鼠标还会移动一段时间才弹起，这种操作称为拖曳，即按下、移动、在释放。</p>\n<p>在canvas动画中，�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>交互动画的一个主要目标是创建出流畅的用户体验，其中大多数的用户交互都是通过鼠标和触摸屏实现的。</p>\n<p>在这篇博文中，我想分享一些JS对于物体移动的常见用法，包括拖拽和投掷效果。</p>\n<h2><a id=\"_4\"></a>一. 使用鼠标事件</h2>\n<p>可以将一个鼠标单击事件分解成两个事件：鼠标按下事件和按键弹起事件。通常情况下这两个事件是同时发生的。不过，有时鼠标按下后，鼠标还会移动一段时间才弹起，这种操作称为拖曳，即按下、移动、在释放。</p>\n<p>在canvas动画中，鼠标事件只能被HTML DOM树上的canvas元素所捕获，因此，我们需要手动计算出鼠标事件在canvas上的发生位置，并判断出它是否发生在哪个绘制到canvas的物体上。需要关注的鼠标事件有：mousedown、mousemove和mouseup。具体细节可参考我的相关博文《<a href=\"http://www.dengzhr.com/frontend/js/447\">JavaScript动画详解(一) —— 循环与事件监听</a>》。</p>\n<h2><a id=\"_5\"></a>二. 使用触摸事件</h2>\n<p>随着触摸屏设备的流行，我们很可能需要在动画中捕捉用户的触摸事件。虽然触摸屏与鼠标是不同的设备，但幸运的是，在DOM树上捕捉触摸事件与捕捉鼠标事件的差别不大。</p>\n<p>与鼠标事件mousedown、mousemove和mouseup相对应的触摸事件分别是touchstart、touchend与touchmove。</p>\n<p>使用手指与鼠标的一个比较大的区别在于，鼠标始终出现在屏幕上，而手指却不是一直处于触摸状态。常见的做法是，引入自定义属性isPressed，用来告诉我们屏幕上是否有手指在触摸。具体细节可参考我的相关博文《<a href=\"http://www.dengzhr.com/frontend/js/447\">JavaScript动画详解(一) —— 循环与事件监听</a>》。</p>\n<h2><a id=\"_6\"></a>三. 拖拽事件</h2>\n<p>拖拽事件包含了三个子事件：鼠标按下、移动、释放。通过不断更新物体的坐标位置使其追随鼠标指针的位置，就可以实现在canvas元素上拖拽物体。另外还需要一个自定义属性isPressed来标示当前鼠标是否按下，默认为false表示鼠标为弹起状态。实现代码包含以下过程：</p>\n<p>1 . 捕捉mousedown事件，判断当前鼠标是否在物体内。当鼠标在物体内按下时，设置isPressed = true；</p>\n<p>2 . 捕捉mousemove事件，在处理程序内判断当isPressed = true时，通过不断更新物体的坐标位置使其追随鼠标指针的位置来模拟出鼠标拖拽效果；</p>\n<p>3 . 捕捉mouseup事件，将isPressed设置为false；</p>\n<p>HTML代码如下：</p>\n<pre><code class=\"lang-html\"><canvas id=\"canvas\" width=\"400\" height=\"400\"></canvas>\n</code></pre>\n<p>JavaScript代码如下：</p>\n<pre><code class=\"lang-javascript\">// 创建画球函数\nfunction Ball() {\n    this.x = 0;\n    this.y = 0;\n    this.radius = 20;\n    this.fillStyle = \"#f85455\";\n    this.draw = function(cxt) {\n        cxt.fillStyle = this.fillStyle;\n        cxt.beginPath();\n        cxt.arc(this.x, this.y, this.radius,  0, 2 * Math.PI, true);\n        cxt.closePath();\n        cxt.fill();\n    }\n}\n// 获得当前鼠标位置\nfunction getMouse(ev) {\n    var mouse = {\n        x: 0,\n        y: 0\n    };\n    var event = ev || window.event;\n    if(event.pageX || event.pageY) {\n        x = event.x;\n        y = event.y;\n    }else {\n        var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n        x = event.clientX + scrollLeft;\n        y = event.clientY + scrollTop;\n    }\n    mouse.x = x;\n    mouse.y = y;\n\n    return mouse;\n}\n\nvar canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\"),\n        ball = new Ball(),\n        mouse = {x: 0, y: 0},\n        isPressed = false;\nball.x = 20;\nball.y = 20;\n\n// 渲染小球\nball.draw(context);\n\n// 小球拖拽事件\ncanvas.addEventListener(\"mousedown\", mouseDown, false);\ncanvas.addEventListener(\"mousemove\", mouseMove, false);\ncanvas.addEventListener(\"mouseup\", mouseUp, false);\n\nfunction mouseDown(ev) {\n    // 判断当前鼠标是否在小球内\n    mouse = getMouse(ev);\n    if(Math.pow(mouse.x - ball.x, 2) + Math.pow(mouse.y - ball.y, 2) <= Math.pow(ball.radius, 2)) {\n        isPressed = true;\n    }\n}\n\nfunction mouseMove(ev) {\n    if(isPressed) {\n        mouse = getMouse(ev);\n\n        ball.x = mouse.x;\n        ball.y = mouse.y;\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        ball.draw(context);\n    }\n}\n\nfunction mouseUp(ev) {\n    // 标示鼠标弹起事件\n    isPressed = false;\n}\n</code></pre>\n<p>来个例子：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/wKoqmw/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/wKoqmw/\'>wKoqmw</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p>【备注：把鼠标移上去拖动红色小球试试~】</p>\n<p>但是，这个例子是有bug的！很快你就能发现，在拖拽的时候，小球的中心位置都在鼠标位置上，特别是当鼠标单击小球边缘时，会看见小球的中心点突然就跳动到了鼠标光标的位置上了。显然，这显得有点唐突。</p>\n<p>我们可以稍作改良：</p>\n<p>在鼠标按下的时候记录当前鼠标位置与小球中心点位置的偏移量；</p>\n<pre><code class=\"lang-javascript\">// 记录鼠标按下时，鼠标与小球圆心的偏移量\ndx = mouse.x - ball.x;\ndy = mouse.y - ball.y;\n</code></pre>\n<p>在鼠标移动时，用鼠标的当前位置减去鼠标按下时记录的偏移量</p>\n<pre><code class=\"lang-javascript\">ball.x = mouse.x - dx;\nball.y = mouse.y - dy;\n</code></pre>\n<p>效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/zvodLP/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/zvodLP/\'>zvodLP</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p>【备注：把鼠标移上去拖动红色小球试试~】</p>\n<h2><a id=\"_7\"></a>四. 投掷事件</h2>\n<p>在动画中如何表现投掷呢？用鼠标选中一个物体，拖拽着它向某个方向移动，松开鼠标后，物体沿着拖拽的方向继续移动。</p>\n<p>在投掷物体时，必须在拖拽物体的过程中计算物体的速度向量，并在释放物体时将这个速度向量赋给物体。实际上，计算拖拽时物体的速度向量的过程，恰好与对物体应用速度向量的过程相反。在对物体应用速度向量时，将速度追加到物体原来所在的位置上，从而计算出物体的新位置，这个公式可以写成：<strong>旧的位置 + 速度向量 = 新的位置</strong>，即<strong>速度向量 = 新的位置 – 旧的位置</strong>。</p>\n<p>为了实现投掷行为，需要对前面的代码做一些改动。首先，检查鼠标是否按下，如果按下，用oldX和oldY变量保存小球旧的x、y坐标位置，并更新小球的拖拽速度。</p>\n<p>具体JavaScript代码实现如下：</p>\n<pre><code class=\"lang-javascript\">// 创建画球函数\nfunction Ball() {\n    this.x = 0;\n    this.y = 0;\n    this.radius = 20;\n    this.fillStyle = \"#f85455\";\n    this.draw = function(cxt) {\n        cxt.fillStyle = this.fillStyle;\n        cxt.beginPath();\n        cxt.arc(this.x, this.y, this.radius,  0, 2 * Math.PI, true);\n        cxt.closePath();\n        cxt.fill();\n    }\n}\n// 获得当前鼠标位置\nfunction getMouse(ev) {\n    var mouse = {\n        x: 0,\n        y: 0\n    };\n    var event = ev || window.event;\n    if(event.pageX || event.pageY) {\n        x = event.x;\n        y = event.y;\n    }else {\n        var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n        x = event.clientX + scrollLeft;\n        y = event.clientY + scrollTop;\n    }\n    mouse.x = x;\n    mouse.y = y;\n\n    return mouse;\n}\n\nvar canvas = document.getElementById(\"canvas\"),\n        context = canvas.getContext(\"2d\"),\n        ball = new Ball(),\n        mouse = {x: 0, y: 0},\n        isPressed = false,\n        oldX = 0,\n        oldY = 0,\n        currentX = 0,\n        currentY = 0,\n        vx = 0,\n        vy = 0;\nball.x = 200;\nball.y = 200;\n\n// 声明鼠标按下时，鼠标与小球圆心的距离\nvar dx = 0,\n        dy = 0;\n\n// 渲染小球\nball.draw(context);\n\n// 小球拖拽事件\ncanvas.addEventListener(\"mousedown\", mouseDown, false);\ncanvas.addEventListener(\"mousemove\", mouseMove, false);\ncanvas.addEventListener(\"mouseup\", mouseUp, false);\n\nfunction mouseDown(ev) {\n    // 判断当前鼠标是否在小球内\n    mouse = getMouse(ev);\n    if(Math.pow(mouse.x - ball.x, 2) + Math.pow(mouse.y - ball.y, 2) <= Math.pow(ball.radius, 2)) {\n        isPressed = true;\n        // 记录鼠标按下时，鼠标与小球圆心的距离\n        dx = mouse.x - ball.x;\n        dy = mouse.y - ball.y;\n        // 获得小球拖拽前的位置\n        mouse = getMouse(ev);\n        oldX = mouse.x;\n        oldY = mouse.y;\n    }\n}\n\nfunction mouseMove(ev) {\n    if(isPressed) {\n        mouse = getMouse(ev);\n        ball.x = mouse.x - dx;\n        ball.y = mouse.y - dy;\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        ball.draw(context);\n    }\n}\n\nfunction mouseUp(ev) {\n    // 标示鼠标弹起事件\n    isPressed = false;\n    // 把鼠标与圆心的距离位置恢复初始值\n    dx = 0;\n    dy = 0;\n    // 获得小球拖拽后的位置\n    mouse = getMouse(ev);\n    currentX = mouse.x;\n    currentY = mouse.y;\n\n    // 更新速度向量：速度向量 = 新的位置 - 旧的位置\n    vx = (currentX - oldX) * 0.05;\n    vy = (currentY - oldY) * 0.05;\n\n    drawFrame();\n}\n\n// 缓动动画\nfunction drawFrame() {\n    animRequest = window.requestAnimationFrame(drawFrame, canvas);\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    if(ball.x >= canvas.width - 30 || ball.x <= 30 || ball.y >= canvas.height - 30 || ball.y <= 30) {\n        window.cancelAnimationFrame(animRequest);\n    }\n    ball.x += vx;\n    ball.y += vy;\n    ball.draw(context);\n}\n</code></pre>\n<p>效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/wKoqZK/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/wKoqZK/\'>wKoqZK</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p>【备注：把鼠标移上去拖动红色小球试试~】</p>\n<p>这个Demo的边界判断还有一些bug，过些日子再修复。好累哇今天~</p>\n<h2><a id=\"_8\"></a>五. 总结</h2>\n<p>物体移动事件可以有很多总运动形式，但是都可以分解为三个单独的事件来控制：按下、移动、释放，在鼠标事件中分别对应的是mousedown、mousemove和mouseup，在触摸事件中分别对应的是touchstart、touchmove和touchend。通过不断更新物体的坐标位置使其追随鼠标指针的位置，就可以实现在canvas元素上拖拽和投掷的效果。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/511\">http://www.dengzhr.com/frontend/html/511</a></div>\n\n        ','2','1'),(276,'JavaScript动画详解(二) —— 缓动动画','\n\n            <p>最普通的动画就是匀速的动画，每次增加固定的值。但是生活中很多运动并不是匀速运动的，而是有加速度改变的运动。在Web动画中，缓动动画有时候会让网站增色不少。</p>\n<p>在CSS3中可以使用ease, ease-in, ease-out, ease-in-out 或者 cubic-bezier(n,n,n,n)来实现缓动动画。而且目前也有一些jQuery封装了缓动动画的Move.js, Velocity.js和Tween.js等。在实际项目中使用这些库文件或者CSS3属性可以大大…</p>\n        ','2019-08-09 07:52:17','0000-00-00 00:00:00',1,'1','\n\n            <p>最普通的动画就是匀速的动画，每次增加固定的值。但是生活中很多运动并不是匀速运动的，而是有加速度改变的运动。在Web动画中，缓动动画有时候会让网站增色不少。</p>\n<p>在CSS3中可以使用ease, ease-in, ease-out, ease-in-out 或者 cubic-bezier(n,n,n,n)来实现缓动动画。而且目前也有一些jQuery封装了缓动动画的Move.js, Velocity.js和Tween.js等。在实际项目中使用这些库文件或者CSS3属性可以大大提高开发效率。但是在学习中，为了了解JS缓动动画的真正原理，我觉得有必要尝试用原生的JS实现之。</p>\n<p>总的来说，缓动动画都是把对象从已有位置移动到目标位置的过程，在这个过程中，加速度或者速度会随与目标位置的远近而变化。</p>\n<p>缓动动画的一些具体动画曲线可以查看这里《<a href=\"http://easings.net/zh-cn\">缓动函数</a>》，感受一下~</p>\n<h2><a id=\"_4\"></a>一. 一般实现缓动的策略如下：</h2>\n<p> 1 . 为运动确定一个比例系数，这是一个小于1且大于0的小数；</p>\n<p> 2 . 确定目标点；</p>\n<p> 3 . 计算出物体当前位置与目标点位置的距离；</p>\n<p> 4 . 计算速度，例如缓入动画中，速度 = 距离 × 比例系数，这时比例系数为运动的加速度；</p>\n<p> 5 . 用当前位置加上速度来计算新的位置；</p>\n<p> 6 . 重复第3到第5步，知道物体到达目标；</p>\n<h3><a id=\"_5\"></a>1.1 例子：缓入动画</h3>\n<p> 来个缓入动画例子我们分析一下，效果如下：</p>\n<p> <iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/bVBwXp/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/bVBwXp/\'>bVBwXp</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe><br>\n【备注：请刷新后查看，或者点击Result中的“return”按钮】</p>\n<p>先看看这些代码片段以及他们的含义：</p>\n<p>1 . 确定一个小数作为比例系数，这个比例系数为加速度（标量）。当系数越接近于1，物体移动得越快；当系数越接近于0，物体移动得越慢。</p>\n<pre><code class=\"lang-javascript\">var easing = 0.05;\n</code></pre>\n<p>2 . 确定目标点。这里用targetX和targetY来定义：</p>\n<pre><code class=\"lang-javascript\">var targetX = canvas.width / 2,\n    targetY = canvas.height / 2;\n</code></pre>\n<p>3 . 计算物体到目标点的距离。创建小球名为ball，用ball的x、y减去目标点的x、y就能得到距离。</p>\n<pre><code class=\"lang-javascript\">var dx = targetX - ball.x,\n    dy= targetY - ball.y;\n</code></pre>\n<p>4 . 速度 = 距离 × 比例系数。</p>\n<pre><code class=\"lang-javascript\">var vx = dx * easing,\n    vy= dy * easing;\n</code></pre>\n<p>5 . 用当前位置加上速度来计算新的位置。</p>\n<pre><code class=\"lang-javascript\">ball.x += vx;\nball.y += vy;\n</code></pre>\n<p>6 . 因为最后几步需要重复执行，所以会把这些代码放在drawFrame函数里面。</p>\n<p>完整代码如下：</p>\n<p>HTML代码：</p>\n<pre><code class=\"lang-html\"><canvas id=\"canvas\" width=\"400\" height=\"100\"></canvas>\n</code></pre>\n<p>JavaScript代码：</p>\n<pre><code class=\"lang-javascript\">// 创建画球函数\nfunction Ball() {\n  this.x = 0;\n  this.y = 0;\n  this.radius = 10;\n  this.fillStyle = \"#f85455\";\n  this.draw = function(cxt) {\n    cxt.fillStyle = this.fillStyle;\n    cxt.beginPath();\n    cxt.arc(this.x, this.y, this.radius,  0, 2 * Math.PI, true);\n    cxt.closePath();\n    cxt.fill();\n  }\n}\n\n// requestAnimationFrame的兼容性写法\nwindow.requestAnimFrame = (function(){\n  return  window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame    ||\n    window.oRequestAnimationFrame      ||\n    window.msRequestAnimationFrame     ||\n    function( callback ){\n    window.setTimeout(callback, 1000 / 60);\n  };\n})();\n\nwindow.cancelAnimationFrame = (function () {\n    return window.cancelAnimationFrame ||\n            window.webkitCancelAnimationFrame ||\n            window.mozCancelAnimationFrame ||\n            window.oCancelAnimationFrame ||\n            function (timer) {\n                window.clearTimeout(timer);\n            };\n})();\n\nvar canvas = document.getElementById(\"canvas\"),\n    context = canvas.getContext(\"2d\"),\n    ball = new Ball(),\n    easing = 0.05,\n    targetX = canvas.width - 10,\n    targetY = canvas.height / 2;\n    ball.x = 5;\n    ball.y = 5;\n\n// 缓动动画函数\nvar animRequest = null;\n(function drawFrame() {\n    animRequest = window.requestAnimationFrame(drawFrame, canvas);\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    var vx = (targetX - ball.x) * easing;\n    var vy = (targetY - ball.y) * easing;\n\n    ball.x += vx;\n    ball.y += vy;\n    ball.draw(context);\n})();\n</code></pre>\n<h3><a id=\"_6\"></a>1.2 改进版缓入动画：加入拖拽效果</h3>\n<p>加入了小球的鼠标移入判断和拖拽动画判断，然后就有了下面这个改进版的缓动动画了。效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/GpNNrp/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/GpNNrp/\'>GpNNrp</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe><br>\n【备注：请刷新后查看，或者点击Result中的“return”按钮】</p>\n<h2><a id=\"_7\"></a>二. 何时停止缓动动画</h2>\n<p>当计算一个单目标点的简单缓动时，物体最终会到达这个目标点，缓动也就完成了。但是，即使在前面的几个例子里，即使该物体看起来已经停止了，计算缓动动画的代码还是一直在执行（不信的可以在缓动动画中加入打印代码如console.log(\"hello world!\")，打开控制台就会看到健步如飞的\"hello world!\"会打印出来~）。这样比较浪费系统资源。一旦物体到达了目标点，代码就应该不再执行了。这个功能很简单，只需要在动画循环里面判断一下物体是否到达目标点即可。如：</p>\n<pre><code class=\"lang-javascript\">if(ball.x === targetX && ball.y === targetY) {\n    // 停止缓动动画代码\n    window.cancelAnimationFrame(animRequest);\n}\n</code></pre>\n<p>事实上，由于ball.x和ball.y可能是小数，随着vx和vy越来越小越趋近于0，事实上它离目标点越来越近，但是理论上永远不会到达目标点，而是无穷趋于目标点的小数。一般分辨率的电脑的显示的最小精度是1px（除了一些高分屏精度为0.1px），不能精确显示无穷多位小数的距离。到底多近才是足够近？这就需要判断物体到目标点的距离是否小于特定值了。我们可以根据实际情况使用Math.ceil()、Math.floor()或Math.round()来对小数进行取整操作，以取接近目标点的值。</p>\n<p>所以上面的代码可改写为：</p>\n<pre><code class=\"lang-javascript\">if(Math.ceil(ball.x) === targetX && Math.ceil(ball.y) === targetY) {\n    // 停止缓动动画代码\n    window.cancelAnimationFrame(animRequest);\n}\n</code></pre>\n<h2><a id=\"_8\"></a>三. 移动的目标点</h2>\n<p>在前面的例子中，目标点只有一个，并且是固定的。</p>\n<p>然而目标点可以是移动的。我们在每一帧都会重新计算距离，然后根据距离计算速度，代码并不关心物体是否到否目标点或者目标点是否在移动，它只需在播放的每一帧的时候知道目标点的位置，然后计算距离和速度。</p>\n<h3><a id=\"_9\"></a>3.1 例子：小球跟随鼠标运动</h3>\n<p>小球跟随鼠标运动的例子中，我们把鼠标位置作为目标点，只需要把前面例子中的targetX和targetY分别替换为鼠标的位置mouse.x和mouse.y即可。</p>\n<p>效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/PPbbEG/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/PPbbEG/\'>PPbbEG</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe><br>\n【备注：请刷新后查看，或者点击Result中的“return”按钮】</p>\n<h2><a id=\"_10\"></a>四. 缓动的其他应用</h2>\n<p>缓动不仅仅适用于运动，还可以操作很多其他属性。只要这个属性是可以用数字表示的，就可以操作它。例如：</p>\n<h3><a id=\"_11\"></a>4.1 Demo1. 颜色缓动动画</h3>\n<p>尝试在24位颜色上使用缓动，要设置红、绿、蓝的初始值和目标值，用缓动改变每一种单独的颜色，然后再把他么合并为单个颜色。</p>\n<p>如下：</p>\n<pre><code class=\"lang-javascript\">// 初始化变量\nvar red = 255,\n    green = 0,\n    blue = 0,\n    redTarget = 0,\n    greenTarget = 0,\n    blueTarget = 255;\n\n// 使用缓动动画\nred += Math.ceil((redTarget - red) * easing);\ngreen += Math.ceil((greenTarget - green) * easing);\nblue += Math.ceil((blueTarget - blue) * easing);\n\n// 最后把这三个单色值合并成一个颜色\nball.fillStyle = \"rgb(\" + red +\",\" + green + \",\" + blue + \")\";\n</code></pre>\n<p>效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/MabbPq/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/MabbPq/\'>MabbPq</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe><br>\n【备注：请刷新后查看，或者点击Result中的“return”按钮】</p>\n<h3><a id=\"_12\"></a>4.2 Demo2. 透明度缓动动画</h3>\n<p>将缓动应用在alpha上，设置alpha的初始值和目标值，然后使用缓动动画实现淡入淡出的效果，最后把它拼接成一个RGBA字符串：</p>\n<pre><code class=\"lang-javascript\">var alpha = 0,\n    targetAlpha = 1;\n\n// 使用缓动动画\nalpha += (targetAlpha - alpha) * easing;\nball.fillStyle = \"rgba(\" + red +\",\" + green + \",\" + blue + \",\" + alpha + \")\";\n</code></pre>\n<p>效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/WQooLd/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/WQooLd/\'>WQooLd</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe><br>\n【备注：请刷新后查看，或者点击Result中的“return”按钮】</p>\n<h2><a id=\"_13\"></a>五. 高级缓动</h2>\n<p>我们上面用到的都是简单缓动，即物体只有一个加速度easing。而事实上我们可以完全可以通过使easing为非定值，来实现自定义物体的任意运动状态，譬如先加速且接近物体时减速等。</p>\n<p>一些高级缓动函数可以参考：</p>\n<p>1 . Tween.js的源码：<a href=\"https://github.com/tweenjs/tween.js/blob/master/src/Tween.js\">https://github.com/tweenjs/tween.js/blob/master/src/Tween.js</a></p>\n<p>2 . jquery.easing.js的源码：<a href=\"https://github.com/gdsmith/jquery.easing/blob/master/jquery.easing.js\">https://github.com/gdsmith/jquery.easing/blob/master/jquery.easing.js</a></p>\n<h2><a id=\"_14\"></a>六. 总结</h2>\n<p>缓动动画是比例速度，通过修改每一帧的速度来计算出当前值，通过加速度easing可以控制独特的动画效果。简单缓动动画不难，关键是要动手练习。高级缓动动画，可以自己实验出一种特效，或者多看看Tween.js和jquery.easing.js等一些类库的缓动动画实现以汲取经验。</p>\n<p></p>\n<p>下一篇想写一下弹动动画。就酱纸。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/494\">http://www.dengzhr.com/frontend/html/494</a></div>\n\n        ','2','1'),(277,'缓动函数 学习笔记','\n\n            <p>大一的时候就知道有缓动函数这种东东（这种炫酷的特技是促使我后来走上IT路的原因之一，~( ╯□╰ )~），但是当时语法不通而且觉得公式推导太深奥了，未详学。最近在整理缓动动画的实现方式，看了古松师兄写的《<a href=\"http://blog.cgsdream.org/2015/09/19/tweenslow-motion-formula/\">缓动公式小析</a>》，于是，便决定整理一下Web前端中使用的缓动函数知识，方便以后调用。</p>\n<h2>一. 缓动函数效果种类</h2>\n<p>【备注：其中 f(x) 表示动画进度，t 表示时间。】</p>\n<p>Linear：无缓动效果，f(t) = t；</p>\n<p>Quadratic：二次方…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>大一的时候就知道有缓动函数这种东东（这种炫酷的特技是促使我后来走上IT路的原因之一，~( ╯□╰ )~），但是当时语法不通而且觉得公式推导太深奥了，未详学。最近在整理缓动动画的实现方式，看了古松师兄写的《<a href=\"http://blog.cgsdream.org/2015/09/19/tweenslow-motion-formula/\">缓动公式小析</a>》，于是，便决定整理一下Web前端中使用的缓动函数知识，方便以后调用。</p>\n<h2><a id=\"_4\"></a>一. 缓动函数效果种类</h2>\n<p>【备注：其中 f(x) 表示动画进度，t 表示时间。】</p>\n<p>Linear：无缓动效果，f(t) = t；</p>\n<p>Quadratic：二次方的缓动，f(t) = t^2；</p>\n<p>Cubic：三次方的缓动，f(t) = t^3；</p>\n<p>Quartic：四次方的缓动，f(t) = t^4；</p>\n<p>Quintic：五次方的缓动，f(t) = t^5；</p>\n<p>Sinusoidal：正弦曲线的缓动，f(t) = sin(t)；</p>\n<p>Exponential：指数曲线的缓动，f(t) = 2^t；</p>\n<p>Circular：圆形曲线的缓动，f(t) = sqrt(1 – t^2)；</p>\n<p>Elasitc：指数衰减的正弦曲线缓动；</p>\n<p>Back：超过范围的三次方缓动，f(t) = (s + 1) <em> t^3 – 3 </em> t^2；</p>\n<p>Bounce：指数衰减的反弹缓动；</p>\n<p>而每种缓动算法效果都可以分为三个缓动方式，分别是：</p>\n<p>easeIn：从0开始加速的缓动；</p>\n<p>easeOut：减速到0的缓动；</p>\n<p>easeInOut：前半段从0开始加速，后半段减速到0的缓动；</p>\n<p>具体的缓动函数曲线如下所示：</p>\n<p><img src=\"http://www.dengzhr.com/wp-content/uploads/2015/09/easing.png\" alt=\"此处输入图片的描述\"></p>\n<p>【备注：图片截取自<a href=\"https://msdn.microsoft.com/zh-cn/library/ee308751%28v=vs.110%29.aspx\">https://msdn.microsoft.com/zh-cn/library/ee308751(v=vs.110).aspx</a>】</p>\n<p>更多直观生动的缓动函数的种类和实现效果，可以参考《<a href=\"http://easings.net/zh-cn\">缓动函数速查表</a>》。</p>\n<h2><a id=\"_5\"></a>二. 缓动算法</h2>\n<p>缓动算法的原理：x轴代表时间，y轴代表当前值。当t（x轴）逐渐增加到d时，当前值（y轴）会到达目标值（b + c）。</p>\n<p>其中，下面缓动算法的疯传函数的四个参数分别为：</p>\n<p>t: current time，当前时间；</p>\n<p>b: beginning value，初始值；</p>\n<p>c: change in value，变化量；</p>\n<p>d: duration，持续时间；</p>\n<p>【备注：Elastic和Back有其他可选的参数】</p>\n<pre><code class=\"lang-javascript\">var Tween = {\n    Linear: function(t, b, c, d) { return c*t/d + b; },\n    Quad: {\n        easeIn: function(t, b, c, d) {\n            return c * (t /= d) * t + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return -c *(t /= d)*(t-2) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t + b;\n            return -c / 2 * ((--t) * (t-2) - 1) + b;\n        }\n    },\n    Cubic: {\n        easeIn: function(t, b, c, d) {\n            return c * (t /= d) * t * t + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return c * ((t = t/d - 1) * t * t + 1) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t*t + b;\n            return c / 2*((t -= 2) * t * t + 2) + b;\n        }\n    },\n    Quart: {\n        easeIn: function(t, b, c, d) {\n            return c * (t /= d) * t * t*t + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return -c * ((t = t/d - 1) * t * t*t - 1) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\n            return -c / 2 * ((t -= 2) * t * t*t - 2) + b;\n        }\n    },\n    Quint: {\n        easeIn: function(t, b, c, d) {\n            return c * (t /= d) * t * t * t * t + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return c * ((t = t/d - 1) * t * t * t * t + 1) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b;\n            return c / 2*((t -= 2) * t * t * t * t + 2) + b;\n        }\n    },\n    Sine: {\n        easeIn: function(t, b, c, d) {\n            return -c * Math.cos(t/d * (Math.PI/2)) + c + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return c * Math.sin(t/d * (Math.PI/2)) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            return -c / 2 * (Math.cos(Math.PI * t/d) - 1) + b;\n        }\n    },\n    Expo: {\n        easeIn: function(t, b, c, d) {\n            return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return (t==d) ? b + c : c * (-Math.pow(2, -10 * t/d) + 1) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if (t==0) return b;\n            if (t==d) return b+c;\n            if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n            return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n        }\n    },\n    Circ: {\n        easeIn: function(t, b, c, d) {\n            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n        },\n        easeOut: function(t, b, c, d) {\n            return c * Math.sqrt(1 - (t = t/d - 1) * t) + b;\n        },\n        easeInOut: function(t, b, c, d) {\n            if ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n            return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n        }\n    },\n    Elastic: {\n        easeIn: function(t, b, c, d, a, p) {\n            var s;\n            if (t==0) return b;\n            if ((t /= d) == 1) return b + c;\n            if (typeof p == \"undefined\") p = d * .3;\n            if (!a || a < Math.abs(c)) {\n                s = p / 4;\n                a = c;\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(c / a);\n            }\n            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n        },\n        easeOut: function(t, b, c, d, a, p) {\n            var s;\n            if (t==0) return b;\n            if ((t /= d) == 1) return b + c;\n            if (typeof p == \"undefined\") p = d * .3;\n            if (!a || a < Math.abs(c)) {\n                a = c; \n                s = p / 4;\n            } else {\n                s = p/(2*Math.PI) * Math.asin(c/a);\n            }\n            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);\n        },\n        easeInOut: function(t, b, c, d, a, p) {\n            var s;\n            if (t==0) return b;\n            if ((t /= d / 2) == 2) return b+c;\n            if (typeof p == \"undefined\") p = d * (.3 * 1.5);\n            if (!a || a < Math.abs(c)) {\n                a = c; \n                s = p / 4;\n            } else {\n                s = p / (2  *Math.PI) * Math.asin(c / a);\n            }\n            if (t < 1) return -.5 * (a * Math.pow(2, 10* (t -=1 )) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p ) * .5 + c + b;\n        }\n    },\n    Back: {\n        easeIn: function(t, b, c, d, s) {\n            if (typeof s == \"undefined\") s = 1.70158;\n            return c * (t /= d) * t * ((s + 1) * t - s) + b;\n        },\n        easeOut: function(t, b, c, d, s) {\n            if (typeof s == \"undefined\") s = 1.70158;\n            return c * ((t = t/d - 1) * t * ((s + 1) * t + s) + 1) + b;\n        },\n        easeInOut: function(t, b, c, d, s) {\n            if (typeof s == \"undefined\") s = 1.70158; \n            if ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\n            return c / 2*((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\n        }\n    },\n    Bounce: {\n        easeIn: function(t, b, c, d) {\n            return c - Tween.Bounce.easeOut(d-t, 0, c, d) + b;\n        },\n        easeOut: function(t, b, c, d) {\n            if ((t /= d) < (1 / 2.75)) {\n                return c * (7.5625 * t * t) + b;\n            } else if (t < (2 / 2.75)) {\n                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;\n            } else if (t < (2.5 / 2.75)) {\n                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;\n            } else {\n                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;\n            }\n        },\n        easeInOut: function(t, b, c, d) {\n            if (t < d / 2) {\n                return Tween.Bounce.easeIn(t * 2, 0, c, d) * .5 + b;\n            } else {\n                return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;\n            }\n        }\n    }\n}\n</code></pre>\n<p>【备注：以上Tween算法转载自<a href=\"https://github.com/zhangxinxu/Tween/blob/master/tween.js\">https://github.com/zhangxinxu/Tween/blob/master/tween.js</a>】</p>\n<p>演示效果请点击<a href=\"http://www.cnblogs.com/bluedream2009/archive/2010/06/19/1760909.html\">《Tween算法》——Cauma</a>。</p>\n<h2><a id=\"_6\"></a>三. Demo</h2>\n<p>这里以四次方的缓动效果中的easeOut效果为例：</p>\n<p>HTML代码：</p>\n<pre><code class=\"lang-html\"><div id=\"box\" style=\"width: 100px; height: 100px; background: #f85455;position: absolute;\"></div>\n</code></pre>\n<p>JavaScript代码：</p>\n<pre><code class=\"lang-javascript\">var Tween = {\n    Quad: {        easeOut: function(t, b, c, d) {\n            return -c *(t /= d)*(t-2) + b;\n        }\n    }\n};\n\nvar box = document.getElementById(\"box\");\n// t: 当前时间； b: 初始值；c: 变化量； d: 持续时间\nvar b = 50, c = 100, d = 100, t = 0;\n// 定时器\nvar timer = null;\nrun();\nfunction run() {\n    box.style.left = Math.ceil(Tween.Quad.easeOut(t, b, c, d)) + \"px\";\n    t++;\n    timer = setTimeout(run, 1000 / 60);\n    if(t >= d) {\n        clearTimeout(timer);\n    }\n}\n</code></pre>\n<p>效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/NGbLdQ/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/NGbLdQ/\'>NGbLdQ</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p>【备注：请按F5，或者点击“Result”面板上悬浮的“RETURN”刷新后查看~】</p>\n<p>其他缓动效果的使用方法类似，只是公式不同而已。</p>\n<h2><a id=\"_7\"></a>四. 总结</h2>\n<p>对缓动算法的计算公式依旧感到深奥。项目需要的时候，拿去用便是了。直观的缓动效果可以查看《<a href=\"http://easings.net/zh-cn\">缓动函数速查表</a>》。当然，我们也可以自定义公式创建缓动效果。</p>\n<p>目前，使用缓动算法的比较著名的jQuery库有<a href=\"https://github.com/gdsmith/jquery.easing\">jquery.easing.js</a>和<a href=\"https://github.com/tweenjs/tween.js\">Tween.js</a>等，有兴趣的可以玩一玩。</p>\n<p>就酱纸。</p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/516\">http://www.dengzhr.com/js/516</a></div>\n\n        ','2','1'),(278,'JavaScript阻止表单提交','\n\n            <p>在JavaScript中，阻止表单默认提交行为的方法有两种，分别是：</p>\n<h2>（1） return false</h2>\n<pre><code class=\"lang-javascript\"><form name=\"loginForm\" action=\"login.aspx\" method=\"post\">\n    <button type=\"submit\" value=\"Submit\" id=\"submit\">Submit</button></code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>在JavaScript中，阻止表单默认提交行为的方法有两种，分别是：</p>\n<h2><a id=\"_4\"></a>（1） return false</h2>\n<pre><code class=\"lang-javascript\"><form name=\"loginForm\" action=\"login.aspx\" method=\"post\">\n    <button type=\"submit\" value=\"Submit\" id=\"submit\">Submit</button>\n</form>\n\n<script>\n    var submitBtn = document.getElementById(\"submit\");\n\n    submitBtn.onclick = function (event) {\n        alert(\"preventDefault!\");\n        return false;\n    };\n</script>\n</code></pre>\n<h2><a id=\"_5\"></a>（2） 使用preventDefault()</h2>\n<p>在标准浏览器中，阻止浏览器默认行为使用event.preventDefault()，而在IE6~8中，使用returnValue属性来实现。</p>\n<pre><code class=\"lang-javascript\"><form name=\"loginForm\" action=\"login.aspx\" method=\"post\">\n    <button type=\"submit\" value=\"Submit\" id=\"submit\">Submit</button>\n</form>\n\n<script>\n    var submitBtn = document.getElementById(\"submit\");\n\n    submitBtn.onclick = function (event) {\n        alert(\"preventDefault!\");\n        var event = event || window.event;\n        event.preventDefault(); // 兼容标准浏览器\n        window.event.returnValue = false; // 兼容IE6~8\n    };\n</script>\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/576\">http://www.dengzhr.com/js/576</a></div>\n\n        ','2','1'),(279,'学习笔记：Blob对象','\n\n            <p>Blob表示二进制原始数据，一个Blob对象就是一个包含有只读原始数据的类文件对象。</p>\n<p>继承Blob功能的API有：</p>\n<blockquote>\n<ul>\n<li>File对象：负责处理那些以文件形式存在的二进制数据，也就是操作本地文件；</li>\n<li>FileList对象：File对象的网页表单接口；</li>\n<li>FileReader对象：负责将二进制数据读入内存内容；</li>\n<li>URL对象：用于对二进制数据生成URL。</li>\n</ul>\n</blockquote>\n<h2>一. 创建Blob对象的方法</h2>\n<p>创建Blob对象的方法有三种，如下：</p>\n<ul>\n<li>1）可以调�</li></ul>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>Blob表示二进制原始数据，一个Blob对象就是一个包含有只读原始数据的类文件对象。</p>\n<p>继承Blob功能的API有：</p>\n<blockquote>\n<ul>\n<li>File对象：负责处理那些以文件形式存在的二进制数据，也就是操作本地文件；</li>\n<li>FileList对象：File对象的网页表单接口；</li>\n<li>FileReader对象：负责将二进制数据读入内存内容；</li>\n<li>URL对象：用于对二进制数据生成URL。</li>\n</ul>\n</blockquote>\n<h2><a id=\"_4\"></a>一. 创建Blob对象的方法</h2>\n<p>创建Blob对象的方法有三种，如下：</p>\n<ul>\n<li>1）可以调用Blob构造函数。</li>\n<li>2）还可以使用一个已有Blob对象上的<code>slice()</code>方法切出另一个Blob对象。</li>\n<li>3）还可以调用canvas对象上的<code>toBlob()</code>方法。</li>\n</ul>\n<h3><a id=\"_5\"></a>1.1 使用Blob构造函数创建：</h3>\n<p>Blob构造函数接受两个参数。第一个参数是一个包含实际数据的数组，第二个参数是数据的类型，这两个参数都不是必需的。</p>\n<pre><code>var myBlob = new Blob([\"Hello World\"], \"text/xml\");\n</code></pre>\n<h3><a id=\"_6\"></a>1.2 使用slice()方法创建：</h3>\n<p>Blob对象的slice()方法，将二进制数据按照字节分块，返回一个新的Blob对象。</p>\n<pre><code>var newBlob = oldBlob.slice(startingByte, endindByte);\n</code></pre>\n<h3><a id=\"_7\"></a>1.3 调用canvas对象上的<code>toBlob()</code>方法来创建：</h3>\n<p>语法：</p>\n<pre><code>void canvas.toBlob(callback, type, encoderOptions)\n</code></pre>\n<p>canvas.toBlob()方法的参数如下：</p>\n<ul>\n<li><strong>callback</strong>： 回调函数，可获得一个单独的Blob对象参数。</li>\n<li><strong>type</strong>： [可选] DOMString类型，指定图片格式，默认格式为image/png。</li>\n<li><strong>encoderOptions</strong>： [可选] Number类型，值在0与1之间，当请求图片格式为image/jpeg或者image/webp时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略。</li>\n</ul>\n<p>例子：</p>\n<pre><code>var canvas = document.getElementById(\"canvas\");\n\ncanvas.toBlob(function(blob) {\n  var newImg = document.createElement(\"img\"),\n      url = URL.createObjectURL(blob);\n\n  newImg.onload = function() {\n    // no longer need to read the blob so it\'s revoked\n    URL.revokeObjectURL(url);\n  };\n\n  newImg.src = url;\n  document.body.appendChild(newImg);\n});\n</code></pre>\n<h2><a id=\"_8\"></a>二. Blob对象的属性：</h2>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>size</td>\n<td>Long</td>\n<td>Blob对象的字节长度。只读。</td>\n</tr>\n<tr>\n<td>type</td>\n<td>DOMString</td>\n<td>Blob对象的MIME类型。如果是未知类型，则返回一个空字符串。只读。</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"_9\"></a>三. Blob对象的方法：</h2>\n<p><strong>slice()</strong>：返回一个新的Blob对象，包含了源Blob对象中指定范围内的数据。</p>\n<p><strong><code>slice()</code>方法的参数如下：</strong></p>\n<ul>\n<li><strong>start</strong> [可选] 开始索引，可以为负数，语法类似于数组的slice方法。默认值为0。</li>\n<li><strong>end</strong> [可选] 结束索引，可以为负数，语法类似于数组的slice方法。默认值为最后一个索引。</li>\n<li><strong>contentType</strong> [可选] 新的Blob对象的MIME类型，这个值将会成为新的Blob对象的type属性的值，默认为一个空字符串。</li>\n</ul>\n<h2><a id=\"_10\"></a>四. Blob兼容性：</h2>\n<p>Blob对象的兼容性详情可查看：<a href=\"http://caniuse.com/#search=blob\">http://caniuse.com/#search=blob</a>。</p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/lhdaiu4jq2ugtwai7avcrc85/image_1at1sc3qe3dm1bi62ep1g9f9al9.png\" alt=\"image_1at1sc3qe3dm1bi62ep1g9f9al9.png-63kB\"></p>\n<p>备注：图片截取自 <a href=\"http://caniuse.com/#search=blob\">http://caniuse.com/#search=blob</a></p>\n<h2><a id=\"_11\"></a>五. 参考：</h2>\n<p><a href=\"http://javascript.ruanyifeng.com/htmlapi/file.html\">文件和二进制数据的操作– JavaScript 标准参考教程（alpha）</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\">Blob —— MDN</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toBlob\">HTMLCanvasElement.toBlob() —— MDN</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/1017\">http://www.dengzhr.com/js/1017</a></div>\n\n        ','2','1'),(280,'JavaScript滚轮事件兼容性写法','\n\n            <p>研究滚轮事件是因为在做一个翻版的fullpage.js，需要通过监听滚轮事件进行翻页。在实现过程中遇到了一些兼容性问题处理。所以顺便封装了个方法wheel(upFn, downFn)，方便日后调用。</p>\n<p>但W3C并没有对鼠标滚轮事件进行规范，各浏览器厂商封装了不同的实现方法，事件属性也不�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>研究滚轮事件是因为在做一个翻版的fullpage.js，需要通过监听滚轮事件进行翻页。在实现过程中遇到了一些兼容性问题处理。所以顺便封装了个方法wheel(upFn, downFn)，方便日后调用。</p>\n<p>但W3C并没有对鼠标滚轮事件进行规范，各浏览器厂商封装了不同的实现方法，事件属性也不一样，号称最标准的FireFox，用了一个私有实现DOMMouseScroll。不过，其他浏览器都是用onmousewheel实现，所以做兼容处理的难度也不大。</p>\n<table>\n<thead>\n<tr>\n<th>浏览器</th>\n<th>实现方法</th>\n<th>事件属性</th>\n<th>向上滚动</th>\n<th>向下滚动</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FireFox</td>\n<td>DOMMouseScroll</td>\n<td>detail</td>\n<td>-3的倍数</td>\n<td>3的倍数</td>\n</tr>\n<tr>\n<td>非FireFox</td>\n<td>onmousewheel</td>\n<td>wheelDelta</td>\n<td>120的倍数</td>\n<td>-120的倍数</td>\n</tr>\n</tbody>\n</table>\n<p>在FireFox下，DOMMouseScroll必须通过addEventListener来绑定，如：<br>\nelement.addEventListener(\"DOMMouseScroll\",func,false) ；</p>\n<p>在非FireFox下，就没有限制了，除了addEventListener方法，还可用下边的代码：<br>\nelement.onmousewheel=function(){}；</p>\n<p>封装代码如下：</p>\n<pre><code class=\"lang-javascript\">// 滚轮响应事件\n// 参数：type有两个属性值，分别为\"up\"（滚轮向上）和\"down\"（滚轮向下）\nfunction wheel(upFn, downFn) {\n    // IE6\n    window.onmousewheel = getWheelDalta;\n    // Firefox\n    if(window.addEventListener) {\n        window.addEventListener(\"DOMMouseScroll\", getWheelDalta, false);\n    }\n    // 获得鼠标滚轮事件\n    function getWheelDalta(event) {\n        var event = event || window.event;\n        var delta = 0;\n        // delta的返回值为正时，表示向前滚动；delta的返回值为负时，表示向后滚动；\n        if (event.wheelDelta) {\n            // IE中，鼠标滚轮信息存放在wheelDelta属性中；向前滚动时，wheelDelta的值是120的倍数；向后滚动时，wheelDelta的值是-120的倍数；\n            delta = event.wheelDelta/120; \n            if (window.opera) delta = -delta;\n        } else if (event.detail) {\n            // Firefox的鼠标滚轮信息存放在detail属性中；向前滚动，detail的值是-3的倍数；向后滚动，detail的值是3的倍数；\n            delta = -event.detail/3;\n        }\n        // 执行滚轮事件函数\n        if(delta > 0) {\n            upFn();\n        }else {\n            downFn();\n        }\n\n        // 阻止默认行为，防止当页面本身就存在滚动条时出现的异常\n        prevent(event);\n        function prevent(evt){\n            if(evt.preventDefault){\n                evt.preventDefault();\n            }else{\n                evt.returnValue = false;\n            }\n        }\n    }   \n}\n</code></pre>\n<p>测试调用：</p>\n<pre><code class=\"lang-javascript\">function wheelUp() {\n    alert(\"wheelUp\");\n}\nfunction wheelDown() {\n    alert(\"wheelDown\");\n}\nwheel(wheelUp, wheelDown);\n</code></pre>\n<p>具体见下示例：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/VvmaaJ/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/VvmaaJ/\'>VvmaaJ</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/440\">http://www.dengzhr.com/js/440</a></div>\n\n        ','2','1'),(281,'将字符串转换为驼峰的方法','\n\n            <p>方法1. 将字符串转换成数组</p>\n<pre>var str = \"border-bottom-color-border\";\nfunction test() {\nvar arr = str.split(\"-\");\nfor(var i = 1; i < arr.length; i++) {\narr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1);\n}\nreturn arr.join(\"\");\n}\nalert(</pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>方法1. 将字符串转换成数组</p>\n<pre>var str = \"border-bottom-color-border\";\nfunction test() {\nvar arr = str.split(\"-\");\nfor(var i = 1; i < arr.length; i++) {\narr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1);\n}\nreturn arr.join(\"\");\n}\nalert( test(str) );</pre>\n<p>方法二. 用正则表达式匹配，再进行修改</p>\n<pre>var str = \"border-bottom-color-border\";\nfunction test(str) {\nvar re = /-(\\w)/g;\nreturn str.replace(re, function(strFull, strWant) {\nreturn strWant.toUpperCase();\n});\n}\nalert(test(str));</pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/100\">http://www.dengzhr.com/js/100</a></div>\n\n        ','2','1'),(282,'JS 数组求和的方法','\n\n            <p>faceshow遇到一个问题：JS数组求和函数。我第一想到的就是数组循环。然而我觉得面试官问这个问题一定不是想考这个人人皆知的方法。当时机智的我竟然想到了递归�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>faceshow遇到一个问题：JS数组求和函数。我第一想到的就是数组循环。然而我觉得面试官问这个问题一定不是想考这个人人皆知的方法。当时机智的我竟然想到了递归函数不断加和数组的项，然而折腾了好久都没调好方法，事实证明这并不是最优解。最后面试官问我有没有见过reduce()，木有哇，真木有哇。所以回来查资料，Array.reduce()是ES5新增的新属性，相似的还有Array.reduceRight()。下文来总结一下数组求和的方法。</p>\n<h2><a id=\"_4\"></a>最粗暴的方法：循环获取</h2>\n<p>通过for循环一项项地加和。看代码：</p>\n<pre><code class=\"lang-javascript\">Array.prototype.sum = function (){\n    var result = 0;\n    for(var i = 0; i < this.length; i++) {\n        result += this[i];\n    }\n    return result;\n};\n\n[1,4,7,2,10].sum(); // 24\n</code></pre>\n<h2><a id=\"_5\"></a>使用reduce方法</h2>\n<p>利用reduce方法，可以写一个数组求和的sum方法。</p>\n<p>reduce()方法接收一个函数作为累加器，数组中的每个值(从左到右)开始缩减，最终为一个值。</p>\n<p>reduce的语法：</p>\n<pre><code class=\"lang-javascript\">array.reduce(callback[, initialValue]);\n</code></pre>\n<p>callback函数接受4个参数：previousValue(上次调用回调返回的值)、currentValue(当前被处理的元素)、index(索引)以及数组本身(第一次调用 callback的第一个参数)，执行数组中每个值的函数。</p>\n<p>initialValue参数可选，表示初始值；initialValue参数若指定，则当作最初使用的previous值，如果缺省，则使用数组的第一个元素作为previous初始值，同时current往后排一位。</p>\n<pre><code class=\"lang-javascript\">Array.prototype.sum = function (){\n    return this.reduce(function (partial, value){\n        return partial + value;\n    })\n};\n[1,4,7,2,10].sum(); // 24\n</code></pre>\n<p>相比第一种方法，使用reduce()方法的效率更高。</p>\n<p>这两种方法的效率比较可以直接在函数运行前后分别调用new Date()获取即时时间，从而通过时间差比较执行时间。这里就不比较了，因为每个人的执行环境差异较大。测试结果是reduce()方法的执行时间更短。</p>\n<p>数组求和在项目需求中还是挺常见的，譬如购物车金额统计、人员的前台统计等等。</p>\n<h3><a id=\"_6\"></a>Array.prototype.reduce()的兼容性</h3>\n<p>Array.prototype.reduce()兼容主流的现代浏览器，不支持IE6~IE8。</p>\n<p>reduce的兼容性详细信息可查阅：<a href=\"http://kangax.github.io/compat-table/es5/#test-Array.prototype.reduce\">http://kangax.github.io/compat-table/es5/#test-Array.prototype.reduce</a></p>\n<p><img src=\"http://static.zybuluo.com/dengzhirong/hkw0z99uxc0k7ukog67q0l3w/image_1auom7jb0qa46k236i1tc6rc89.png\" alt=\"image_1auom7jb0qa46k236i1tc6rc89.png-101.7kB\"></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/411\">http://www.dengzhr.com/js/411</a></div>\n\n        ','2','1'),(283,'JavaScript实现点击随机变色','\n\n            <h2>事起缘由</h2>\n<p>6月21日晚，古哥给咱们科普页面渲染机制、JS的一些性能优化和MV*架构，收益匪浅。在培训现场，古哥请船长当场用原生JS实现点击盒子随机变色。船长的编程思路让人脑洞有点大开，Get到不少干货。借着这个例子，古哥不断灌输各种性能优化、浏览器兼容写法、代码整洁等概念。想不到一个如此简单的例子竟有这么大的学问。于是培训归来当晚，当即打开电脑，把这个例子自己实现了一遍。于是便有了此文。</p>\n<p>下面我来�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>事起缘由</h2>\n<p>6月21日晚，古哥给咱们科普页面渲染机制、JS的一些性能优化和MV*架构，收益匪浅。在培训现场，古哥请船长当场用原生JS实现点击盒子随机变色。船长的编程思路让人脑洞有点大开，Get到不少干货。借着这个例子，古哥不断灌输各种性能优化、浏览器兼容写法、代码整洁等概念。想不到一个如此简单的例子竟有这么大的学问。于是培训归来当晚，当即打开电脑，把这个例子自己实现了一遍。于是便有了此文。</p>\n<p>下面我来讲讲我是怎么做的。</p>\n<h2><a id=\"_5\"></a>一. 首先搭好HTML结构和CSS样式</h2>\n<pre><code class=\"lang-html\"><!DOCTYPE html>\n<html>\n<head>\n    <title>changeColor</title>\n    <style>\n        .colorBox {\n            width: 200px;\n            height: 200px;\n            margin: 20px;\n            background-color : rgb(100, 200, 100);\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<div id=\"colorBox\" class=\"colorBox\"></div>\n</body>\n</html>\n</code></pre>\n<p>接下来肯定是要用JS控制DOM元素啦。</p>\n<h2><a id=\"_6\"></a>二. 创造随机颜色生成器</h2>\n<p>首先，需要明确使用何种色彩模式。在HTML标准中，色彩模式有十六进制、RGB、HSL、RGBA、HSLA等。其中，HSL和HSLA不能兼容IE6-8。</p>\n<h3><a id=\"_7\"></a>1. 创建随机数</h3>\n<p>因为颜色是随机生成的，因此需要用到Math.random()函数。由于Math.random()生成0~1之间的随机数(包括0不包括1)，有时并不能满足我们的需求，因此可能需要乘除一个数。如果希望得到整数，需要对随机数进行取整，可用Math.ceil()【向上取整】或Math.floor()【向下取整】或Math.round()【四舍五入】，或者paseInt()。</p>\n<p>举个实用的栗子，如何获得两个数之间的随机数：</p>\n<pre><code class=\"lang-javascript\">function getRandom(min, max) {\n    return Math.round(Math.random()*(max - min) + min);\n}\n</code></pre>\n<p>Math.random()<em>(max – min) + min应该还是比较好理解的，用底数(min)加上随机偏移量(Math.random()</em>(max – min))就是随机数的大小。</p>\n<p>为了使随机数看起来更随机一些，建议使用Math.round()。因为譬如使用Math.ceil()取整的话，min能被娶到的几率非常非常小，只有Math.random()=0时才能取到。同理Math.floor()和paseInt()将永远也取不到max值。</p>\n<p>当然，JavaScript中的随机数Math.random()并非真正意义上的随机，只能算“伪随机数”，这与它的产生算法有关，这里不展开讨论。不过Math.random()应付一般的不那么精准的项目中已经够用了。</p>\n<h3><a id=\"_8\"></a>2. 创建随机颜色</h3>\n<p>其实使用哪一种色彩模式的实现方式差不多，只是字符串的拼接结果不一样而已。</p>\n<p><strong>(1) 使用十六进制色彩模式</strong></p>\n<p>直接上代码：</p>\n<pre><code class=\"lang-javascript\">function randomColor() {\n    // 这里使用十六进制颜色值\n    var colorArr = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n    var colorVal = \"#\";\n    for(i = 0; i < 6; i++) {\n        colorVal += colorArr[Math.round(15*Math.random())];\n    }\n    return colorVal;\n}\n</code></pre>\n<p><strong>(2) 使用RGB色彩模式</strong></p>\n<p>直接上代码：</p>\n<pre><code class=\"lang-javascript\">function randomColor() {\n    // 这里使用rgb颜色值\n    var colorVal = \"rgb(\";\n    for(i = 0; i < 3; i++) {\n\n        colorVal += Math.round(250*Math.random());\n        if (i < 2) {\n            colorVal += \",\";\n        }\n    }\n    colorVal += \")\";\n    return colorVal;\n}\n</code></pre>\n<p>当然，你还可以使用rgba定义它的透明度。</p>\n<p><strong>(3) 使用HSL色彩模式</strong></p>\n<p>直接上代码：</p>\n<pre><code class=\"lang-javascript\">function randomColor() {\n    // 这里使用HSL颜色值，但HSL不兼容IE6~8\n    // HSL(H, S, L)，H的取值为0-360，S为0-100%，L为0-100%\n    // 在本例子中先设定好饱和度(S)和亮度(L)，随机变化色相(H)\n    var colorVal,\n        S = \"50%\",\n        L = \"50%\";\n    colorVal = \"HSL(\" + Math.round(360*Math.random()) + \",\" + S + \",\" + L + \")\";\n    return colorVal;\n}\n</code></pre>\n<h3><a id=\"_9\"></a>3. 绑定样式修改</h3>\n<p>这里需要修改盒子的background-color。我们可以直接操作<code><style></code>标签中的元素，不过最简单的当然是直接在html中标签的style属性啦。</p>\n<pre><code class=\"lang-javascript\">this.style.backgroundColor = randomColor();\n</code></pre>\n<h3><a id=\"_10\"></a>4. 将使盒子变色的函数封装</h3>\n<pre><code class=\"lang-javascript\">function changeColor() {\n    // 创造随机颜色\n    function randomColor() {\n        // ...\n    }\n    this.style.backgroundColor = randomColor();\n}\n</code></pre>\n<h2><a id=\"_11\"></a>三. 给盒子绑定changeColor()事件</h2>\n<h3><a id=\"_12\"></a>1. 获取DOM元素</h3>\n<p>获取DOM元素的几种方法可以用document.getElementById()、document.getElementByName()、document.getElementsByTagName()。当然还有高性能的document.querySelector()，并能兼容IE8及其以上浏览器。</p>\n<p>在这里，我使用原始的document.getElementById()。在一个页面中经常需要获取元素id的方法，所以可以考虑将其封装成函数。见下：</p>\n<pre><code class=\"lang-javascript\">// 获取元素的id值\nfunction getId(id) {\n    return document.getElementById(id);\n}\n</code></pre>\n<h3><a id=\"_13\"></a>2. 对事件进行绑定</h3>\n<p><strong>(1) 使用基于DOM对象的属性方式</strong></p>\n<p>最让人容易想到的时间绑定方式就是ele.onclick = function(){}，并且这种基于DOM对象的属性方式能轻易地兼容IE6及其以上浏览器，非常好用。</p>\n<pre><code class=\"lang-javascript\">colorBox.onclick = function() {\n    changeColor();\n}\n</code></pre>\n<p><strong>(2) 使用基于DOM对象的方法方式</strong><br>\n绑定事件，addEventListener不能兼容IE6-8，因此IE6-8需要使用attachEvent，除了函数名、参数的不同，还有个关于this指针的差异。在其它高版本浏览器中，绑定的事件处理函数被调用时，this指向事件绑定的object。而IE中，this指向window对象，通过使用call或apply可以改变this指针的指向。</p>\n<p>addEventListener语法：target.addEventListener(event, callback, useCapture);</p>\n<p>attachEvent语法：target.attachEvent(event, fn);</p>\n<p>另外，再来掰一掰addEventListener的事件流：</p>\n<p>当一个事件发生时，分为三个阶段：</p>\n<p>a.捕获阶段： 从根节点开始顺序而下，检测每个节点是否注册了事件处理程序。如果注册了事件处理程序，并且 useCapture 为 true，则调用该事件处理程序；（IE 中无此阶段）；</p>\n<p>b.目标阶段： 触发在目标对象本身注册的事件处理程序，也称正常事件派发阶段；</p>\n<p>c.冒泡阶段： 从目标节点到根节点，检测每个节点是否注册了事件处理程序，如果注册了事件处理程序，并且 useCapture 为false，则调用该事件处理程序；</p>\n<p>一般地，先判断使用addEventListener，后判断attachEvent。这是因为addEventListener能兼容IE9以上和其他绝大多数浏览器，而attachEvent只适用于IE，一般用之兼容IE6~8，而IE6~8的用户较少，因此，应优先考虑先判断addEventListener以减短JS的渲染路径，以达到绝大多数用户的更好体验。</p>\n<pre><code class=\"lang-javascript\">// 事件绑定器\n// 参数：target为DOM对象，event为事件名称(不带\"on\")，callback为接收事件处理的函数\nfunction bindEvent(target, event, callback) {\n    if(window.addEventListener) {\n        return target.addEventListener(event, callback, false);\n    }else if(target.attachEvent) {\n        return target.attachEvent(\"on\"+event, function() {\n            callback.apply(target);\n        });\n    }\n}\n</code></pre>\n<h2><a id=\"_14\"></a>四. 调用</h2>\n<p>在这之前，我已将使盒子变色的方法用changeColor()封装，并将构建了一个事件绑定器bindEvent()。</p>\n<p>上面折腾了辣么多都还木有见到效果，别急~</p>\n<p>最后当然是优雅的一键调用啦。哈哈哈哈~o(^▽^)o~</p>\n<pre><code class=\"lang-javascript\">    var colorBox = getId(\"colorBox\");\n    bindEvent(colorBox, \"click\", changeColor, false);\n</code></pre>\n<p>如果页面中还有其他盒子需要变色，只需要优雅地调用一下bindEvent()即可完成扩展。</p>\n<h2><a id=\"_15\"></a>五. 性能优化</h2>\n<p>1 . 可以使用自执行函数将代码块进行封装并创建伪命名空间，只要把自己所有的函数、对象和变量都写在这个闭包函数内，那么外部就不能访问，除非你允许。</p>\n<p>2 . 在事件绑定中，古哥建议将事件绑定器用变量存储，那样每次调用事件绑定器时就不再需要重复判断。古哥写的事件绑定器代码如下：</p>\n<pre><code class=\"lang-javascript\">var w3c = document.dispatchEvent;\nvar bind = w3c?function(target,type,handler,phrase){\n    target.addEventListener(type,handler,!!phrase);\n} : function(target,type,handler){\n    target.attachEvent && target.attachEvent(\"on\"+type,function(){\n        handler.apply(target);\n    })\n}\nbind(box,\"click\",handleClick);\n</code></pre>\n<h2><a id=\"_16\"></a>效果</h2>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/LVOGKr/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/LVOGKr/\'>LVOGKr</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/424\">http://www.dengzhr.com/js/424</a></div>\n\n        ','2','1'),(284,'JavaScript事件处理兼容性总结（更新至2015-09-12）','\n\n            <h2>事件监听绑定函数</h2>\n<pre><code class=\"lang-javascript\">// eventType为不含\"on\"的事件类型\nvar bind = function(ele, eventType, callback) {\n    if(ele.addEventListener) {\n        // W3C标准写法\n        return ele.addEventListener(eventType, callback, false);\n    }else if(ele.attachEvent) {\n        // 兼容I</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>事件监听绑定函数</h2>\n<pre><code class=\"lang-javascript\">// eventType为不含\"on\"的事件类型\nvar bind = function(ele, eventType, callback) {\n    if(ele.addEventListener) {\n        // W3C标准写法\n        return ele.addEventListener(eventType, callback, false);\n    }else if(ele.attachEvent) {\n        // 兼容IE6~8\n        return ele.attachEvent(eventType, callback);\n    }else {\n        // 兼容IE5-\n        return ele[\"on\" + eventType] = callback;\n    }\n}\n</code></pre>\n<h2><a id=\"_5\"></a>事件监听解绑函数</h2>\n<pre><code class=\"lang-javascript\">// eventType为不含\"on\"的事件类型\nvar unbind = function(ele, eventType, callback) {\n    if(ele.removeEventListener) {\n        // W3C标准写法\n        return ele.removeEventListener(eventType, callback, false);\n    }else if(ele.detachEvent) {\n        // 兼容IE6~8\n        return ele.detachEvent(eventType, callback);\n    }else {\n        // 兼容IE5-\n        return ele[\"on\" + eventType] = null;\n    }\n}\n</code></pre>\n<h2><a id=\"_6\"></a>重写window.onload为可多次追加的函数</h2>\n<pre><code class=\"lang-javascript\">var addLoadEvent = function(callback) {\n    var oldOnLoad = window.onload;\n    if(type window.onload != \"function\") {\n        window.onload = callback;\n    }else {\n        window.onload = function() {\n            if(oldOnLoad) {\n                oldOnLoad();\n            }\n            callback();\n        }\n    }\n}\n</code></pre>\n<h2><a id=\"_7\"></a>获取鼠标点击事件的坐标位置</h2>\n<p>screenX: 鼠标位置相对于用户屏幕水平偏移量，参照点也就是原点是屏幕的左上角；</p>\n<p>PageX:鼠标在页面上的位置,从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化；</p>\n<p>clientX:鼠标在页面上可视区域的位置,从浏览器可视区域左上角开始,即是以浏览器滑动条此刻的滑动到的位置为参考点,随滑动条移动 而变化.</p>\n<p>常见的JavaScript获取元素位置的API：</p>\n<pre><code class=\"lang-javascript\">function getPosition(e) {\n    // 访问事件对象\n    var e = e || window.event;\n\n    // 声明x、y分别为鼠标相对于文档的位置\n    var x = 0, y = 0;\n\n    // 针对W3C标准浏览器具有pageX/Y属性\n    if(e.pageX) {\n        x = e.pageX;\n        y = e.pageY;\n    }else if(e.clientX) {\n        // 在IE6~8中不支持pageX，而是用clientX；但clientX只是相对屏幕视口的横坐标，不包含滚动宽度；\n        var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n        // pageX = clientX + scrollX\n        x = e.clientX + scrollLeft;\n        y = e.clientY + scrollTop;\n    }\n    return [x, y];\n}\n</code></pre>\n<h2><a id=\"_8\"></a>取消默认事件发生</h2>\n<pre><code class=\"lang-javascript\">function cancelEvent(event) {\n    if(event.preventDefault) {\n        e.preventDefault();\n    }else {\n        // 兼容IE6~8\n        event.returnValue = false;\n    }\n}\n</code></pre>\n<h2><a id=\"_9\"></a>防止事件在嵌套元素中传播</h2>\n<p>有一个元素嵌套在另一个元素中，他们都捕获点击事件。如果想阻止事件传播，可以使用stopPropagation()函数，在IE6~8中则可以使用cancelBubble = boolean来实现。</p>\n<pre><code class=\"lang-javascript\">function stopPropagation(event) {\n    if(event.stopPropagation) {\n        event.stopPropagation();\n    }else {\n        event.cancelBubble = true;\n    }\n}\n</code></pre>\n<h2><a id=\"_10\"></a>获取键盘事件</h2>\n<pre><code class=\"lang-javascript\">function keyCode(e) {\n    // 访问事件对象\n    var e = e || window.event;\n    var key = e.keyCode || e.charCode;\n    return key;\n}\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/366\">http://www.dengzhr.com/js/366</a></div>\n\n        ','2','1'),(285,'原生JS实现自动生成文章标题树','\n\n            <h2>缘由：</h2>\n<p>缘由很简单，因为我的博客文章希望有文章标题树，但是wordpress自动生成文档树比较麻烦，恰好也想用JavaScript实现试试。用了一个下午的时间，还是没能保留获取的h2、h3的文档顺序，最后只好用了个障眼法——通过修改分别修改title树的h2、h3的class样式来实现区分。其实最希望能自动分配序号，但目前还没实现。等过些日子再想想吧。</p>\n<p>实现原理很简单，就是循环文章模块�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>缘由：</h2>\n<p>缘由很简单，因为我的博客文章希望有文章标题树，但是wordpress自动生成文档树比较麻烦，恰好也想用JavaScript实现试试。用了一个下午的时间，还是没能保留获取的h2、h3的文档顺序，最后只好用了个障眼法——通过修改分别修改title树的h2、h3的class样式来实现区分。其实最希望能自动分配序号，但目前还没实现。等过些日子再想想吧。</p>\n<p>实现原理很简单，就是循环文章模块，并抽取其中的h2、h3标签，将其中的内容赋予给新建的title树。</p>\n<p>我的博客使用的是客户端生成title树的方法。</p>\n<h2><a id=\"_5\"></a>代码如下：</h2>\n<h3><a id=\"_6\"></a>HTML代码：</h3>\n<pre><code class=\"lang-html\"><div class=\"contextBox\">\n    <div id=\"article\">\n        <h2>二级标题</h2>\n        <h3>三级标题</h3>\n        <p>hello hello hello hello hello hello hello hello hello hello hello hello</p>\n        <h3>三级标题</h3>\n        <h3>三级标题</h3>\n        <h3>三级标题</h3>\n        <h3>三级标题</h3>\n        <p>hello hello hello hello hello hello hello hello hello hello hello</p>\n        <h2>二级标题</h2>\n        <h3>三级标题</h3>\n        <h3>三级标题</h3>\n        <p>world world world world world world world world world world world world world world world world world world world world world world world world world world world world world world world </p>\n        <h3>三级标题</h3>\n        <h3>三级标题</h3>\n        <h2>二级标题</h2>\n        <h3>三级标题</h3>\n        <h3>三级标题</h3>\n        <h2>二级标题</h2>\n        <h3>三级标题</h3>\n        <h3>三级标题</h3>\n        <h2>二级标题</h2>\n        <h3>三级标题</h3>\n        <h3>三级标题</h3>\n    </div>\n    <div class=\"articleMenu-box\" id=\"articleMenu_box\">\n        <span class=\"articleMenu-open\" id=\"articleMenu_open\"></span>\n        <ul class=\"articleMenu hello\" id=\"articleMenu\">\n            <span class=\"articleMenu-close\" id=\"articleMenu_close\"></span>\n        </ul>\n    </div>\n</div>\n</code></pre>\n<h3><a id=\"_7\"></a>CSS代码：</h3>\n<pre><code class=\"lang-css\">* {\n    margin: 0;\n    padding: 0;\n    border: 0;\n}\nbody {\n    font: 16px/1.5;\n}\nul li, ol li {\n    list-style: none;\n}\n.contextBox {\n    position: relative;\n    width: 960px;\n    margin: 0 auto;\n}\n#article {\n    margin-left: 200px;\n    border: 1px #eee solid;\n    padding: 15px;\n}\n.articleMenu a {\n    text-decoration: none;\n    color: #333;\n}\n.articleMenu a:hover {\n    color: #f85455;\n}\n.articleMenu-box {\n    width: 170px;\n    position: absolute;\n    left: 10px;\n    top: 10px;\n}\n.articleMenu {\n    padding: 10px;\n    border: 1px solid #ccc;\n    box-shadow: 2px 2px 2px #eee;\n}\n.titleH2, .titleH3 {\n    line-height: 1.5em;\n}\n.titleH2 {\n    font-weight: bold;\n}\n.titleH3 {\n    margin-left: 20px;\n}\n.articleMenu .articleMenu-close, .articleMenu-open {\n    display: inline-block;\n    position: absolute;\n    right: 0;\n    top: 0;\n    height: 44px;\n    width: 44px;\n    cursor: pointer;\n}\n.articleMenu-open {\n    background: url(\"http://www.dengzhr.com/wp-content/themes/dengzhr/images/icon_articleMenu_open.png\") no-repeat 50% 50%;\n    display: none;\n}\n.articleMenu .articleMenu-close {\n    background: url(\"http://www.dengzhr.com/wp-content/themes/dengzhr/images/icon_articleMenu_close.png\") no-repeat 50% 50%;\n}\n</code></pre>\n<h3><a id=\"_8\"></a>JavaScript代码：</h3>\n<pre><code class=\"lang-javascript\">var article = document.getElementById(\"article\");\nvar articleHgroupMenu = document.getElementById(\"articleMenu\");\n\n// 关闭和展开文档树\nvar articleMenu_open = document.getElementById(\"articleMenu_open\");\nvar articleMenu_close = document.getElementById(\"articleMenu_close\");\narticleMenu_close.onclick = function() {\n    articleHgroupMenu.style.display = \"none\";\n    articleMenu_open.style.display = \"block\";\n};\narticleMenu_open.onclick = function() {\n    articleHgroupMenu.style.display = \"block\";\n    articleMenu_open.style.display = \"none\";\n};\n\n//\ntitleHgroup(article, articleHgroupMenu, \"titleH2\", \"titleH3\");\n\n// 获得obj下的直接子元素中为标题h2~h3的标题元素\n// 参数说明：hgroupParent为包含h2和h3的直接父元素；MenuList为承载新建文章列表的ul元素；\n// h2ClassName、h3ClassName分别为新建文章列表中对应h2、h3的li自列表的Class属性；\nfunction titleHgroup(hgroupParent, MenuList, h2ClassName, h3ClassName) {\n    var hgroup = hgroupParent.children;\n\n    // 创建文档片段，来包裹自动生成的h2、h3对应生成的li列表\n    var fragment = document.createDocumentFragment();\n    for(i = 0; i < hgroup.length && hgroup[i].nodeType === 1; i++) {\n\n        // 为对应类型的标题生成li列表\n        // 参数说明：hType为标题的类型如h1~h6；className为标题对应的li列表的class属性值；\n        function titleToList(hType, className) {\n            var li = document.createElement(\"li\");\n            li.className = className;\n\n            // 为li标签内部添加a标签，用锚点进行定位；\n            hgroup[i].id= hType + i;\n            li.innerHTML = (\"<a href=\'#\" + hType + i + \"\'>\" + hgroup[i].innerHTML +\"</a>\");\n            fragment.appendChild(li);\n        }\n\n        // 当遍历中标题元素为h2时，调用titleToList(hType, className)新增对应的li列表；\n        if(hgroup[i].nodeName.toLowerCase() == \"h2\") {\n            titleToList(\"h2\", h2ClassName);\n        }\n\n        // 当遍历中标题元素为h3时，调用titleToList(hType, className)新增对应的li列表；\n        if(hgroup[i].nodeName.toLowerCase() == \"h3\") {\n            titleToList(\"h3\", h3ClassName);\n        }\n    }\n    // 将承载好对应li元素集合的文档片段fragment添加到DOM(即在DOM中包裹li列表的父元素)中去；\n    MenuList.appendChild(fragment);\n}\n</code></pre>\n<h2><a id=\"_9\"></a>效果如下：</h2>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/BozmWv/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/BozmWv/\'>BozmWv</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/428\">http://www.dengzhr.com/js/428</a></div>\n\n        ','2','1'),(286,'JavaScript：查找字符串中出现最多的字符','\n\n            <h2>方法一. 用对象集合存储不同字符集合，再比较字符集合的长度</h2>\n<pre><code>var string = \"dhsjakaaaaaaaaaaaaaaaaaaaaaaaaaFHDSJAKLFHKADSdhsjahdueiyfjshfjxbczkfh\";\n\nfunction max(str) {\n    var obj = {};\n    // 将字符串中的相同字符写入同一个obj下的属性中，并用str[]数组存储\n    for(var i = 0; i < str.length;</code></pre>…\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>方法一. 用对象集合存储不同字符集合，再比较字符集合的长度</h2>\n<pre><code>var string = \"dhsjakaaaaaaaaaaaaaaaaaaaaaaaaaFHDSJAKLFHKADSdhsjahdueiyfjshfjxbczkfh\";\n\nfunction max(str) {\n    var obj = {};\n    // 将字符串中的相同字符写入同一个obj下的属性中，并用str[]数组存储\n    for(var i = 0; i < str.length; i++) {\n        if( !obj[str[i]] ) {\n            obj[str[i]] = [];\n        }\n        obj[str[i]].push( str[i] );\n    }\n    // 声明obj的长度\n    var num = 0;\n    var value = \"\";\n        // 获取最大长度相同字符集合\n    for(var attr in obj) {\n        if(num < obj[attr].length) {\n            num = obj[attr].length;\n            value = obj[attr][0];\n        }\n    }\n    var info = \"出现次数最多的字符为 : \" + value + \", 出现次数为 ：\" + num;\n    return info;\n}\n\nalert(max(string)); // 出现次数最多的字符为 : a, 出现次数为 ：27\n</code></pre>\n<h2><a id=\"_5\"></a>方法二. 使用正则表达式匹配</h2>\n<pre><code>var string = \"dhsjakaaaaaaaaaaaaaaaaaaaaaaaaaFHDSJAKLFHKADSdhsjahdueiyfjshfjxbczkfh\";\n\nfunction max(str) {\n    var num = 0;//出现次数 \n    var value = \"\"// 出现最多次数的值 \n    var re = /(\\w)\\1+/g;\n    var new_str = str.split(\"\").sort().join(\"\"); \n    new_str.replace(re, function($0, $1){\n        if(num<$0.length){ \n           num = $0.length; \n           value = $1;\n        } \n    }) \n\n    var info = \"出现次数最多的字符为 : \" + value + \", 出现次数为 ：\" + num;\n    return info;\n}\n\nalert(max(string)); // 出现次数最多的字符为 : a, 出现次数为 ：27\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/104\">http://www.dengzhr.com/js/104</a></div>\n\n        ','2','1'),(287,'联动的小球——Canvas实现','\n\n            <p>一天上午起床，脑子里满是联动小球的模拟实验，然后灵光一闪，就想到了用canvas实现之的原理，( ╯□╰ )。然后赶紧下床开始用纸笔理清实现逻辑和定位计算，然后打开电脑coding，一气呵成就是这么嗨森。</p>\n<p>实现的基本思路是将小球的当前坐标用小球位置数组记录。每一次位置变动都将小球的新位置重新写入�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>一天上午起床，脑子里满是联动小球的模拟实验，然后灵光一闪，就想到了用canvas实现之的原理，( ╯□╰ )。然后赶紧下床开始用纸笔理清实现逻辑和定位计算，然后打开电脑coding，一气呵成就是这么嗨森。</p>\n<p>实现的基本思路是将小球的当前坐标用小球位置数组记录。每一次位置变动都将小球的新位置重新写入这个小球位置数组，然后通过新数组中的位置坐标两两连线。注意的是canvas是一次次的绘图叠加的，所以我们需要在每一次绘制新图形前清空画布再进行绘制。除此之外基本就剩下拖拽事件的实现了。</p>\n<p>Talk is a cheat, 还是来段代码实际点，如下：</p>\n<h2><a id=\"_4\"></a>HTML代码：</h2>\n<pre><code class=\"lang-html\"><canvas id=\"myCanvas\" width=\"500\" height=\"500\"></canvas>\n</code></pre>\n<h2><a id=\"_5\"></a>JavaScript代码：</h2>\n<pre><code class=\"lang-javascript\">// 获得Canvas元素的引用和绘图上下文\nvar myCanvas = document.getElementById(\"myCanvas\");\nvar ctx = myCanvas.getContext(\"2d\");\nctx.fillStyle = \"rgba(200, 200, 100, .6)\";\n\n// 创建圆的构造函数\nfunction Circle(x, y, radius) {\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n}\n\n// 创建直线的构造函数\nfunction Line(startPoint, endPoint, thickness) {\n    this.startPoint = startPoint;\n    this.endPoint = endPoint;\n    this.thickness = thickness;\n}\n\nvar circleRadius = 10;\nvar width = myCanvas.width;\nvar height = myCanvas.height;\nvar circlesCount = 5;\n\n// 创建用于存储位置的数组\nvar untangleGame = {\n    circle: [],\n    thinLineThickness: 1,\n    lines: []\n};\n\n// 绘画圆形的函数\nfunction drawCircle(ctx, x, y, radius) {\n    ctx.fillStyle = \"rgba(200, 200, 100, 1)\";\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n}\n\n// 绘制直线的函数\nfunction drawLine(ctx, x1, y1, x2, y2, lineThickness) {\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.width = lineThickness;\n    ctx.closePath();\n    ctx.stroke();\n}\n\nfunction circleCreate() {\n    // 随机放置几个圆\n    for(var i = 0; i < circlesCount; i++) {\n        var x = Math.random() * width;\n        var y = Math.random() * height;\n        drawCircle(ctx, x, y, circleRadius);\n        untangleGame.circle.push(new Circle(x, y, circleRadius));\n    }    \n}\ncircleCreate();\n// 生成圆之间的连线，并保存所有连线\nfunction connectCircles() {\n    untangleGame.lines.length = 0;\n    for(var i = 0; i < untangleGame.circle.length; i++) {\n        var startPoint = untangleGame.circle[i];\n        for(var j = 0; j < i; j++) {\n            var endPoint = untangleGame.circle[j];\n            drawLine(ctx, startPoint.x, startPoint.y, endPoint.x, endPoint.y, 1);\n            untangleGame.lines.push(new Line(startPoint, endPoint, untangleGame.thinLineThickness));\n        }\n    }\n}\nconnectCircles();\n\n// 添加鼠标事件监听器\n// 鼠标按下事件\nmyCanvas.onmousedown = function(e) {\n    var e = e || window.event;\n    var mouseX = (e.pageX  - this.offsetLeft) || (e.clientX + document.documentElement.scrollLeft || document.body.scrollLeft);\n    var mouseY = (e.pageY  - this.offsetLeft) || (e.clientY + document.documentElement.scrollTop || document.body.scrollTop);\n\n    for(var i = 0; i < untangleGame.circle.length; i++) {\n        var circleX = untangleGame.circle[i].x;\n        var circleY = untangleGame.circle[i].y;\n        var radius = untangleGame.circle[i].radius;\n        if(Math.pow(mouseX - circleX, 2) + Math.pow(mouseY - circleY, 2) < Math.pow(radius, 2)) {\n            untangleGame.targetCircle = i;\n            console.log(untangleGame.targetCircle);\n            break;\n        }\n    }\n}\n\n// 鼠标移动事件\nmyCanvas.onmousemove = function(e) {    \n    gameloop();    \n    if(untangleGame.targetCircle != undefined) {\n        var e = e || window.event;\n        var mouseX = (e.pageX  - this.offsetLeft) || (e.clientX + document.documentElement.scrollLeft || document.body.scrollLeft);\n        var mouseY = (e.pageY  - this.offsetLeft) || (e.clientY + document.documentElement.scrollTop || document.body.scrollTop);\n        var radius = untangleGame.circle[untangleGame.targetCircle].radius;\n        untangleGame.circle[untangleGame.targetCircle] = new Circle(mouseX, mouseY, radius);\n    }\n    connectCircles();\n\n}\nmyCanvas.onmouseup = function(e) {\n    var e = e || window.event;\n    untangleGame.targetCircle = undefined;\n}\n\n// 当鼠标移动小球时，修改当前圆和相连直线的存档，并清空画布；\nfunction gameloop() {\n    // 重绘前清空Canvas\n    ctx.clearRect(0, 0, myCanvas.width, myCanvas.height);\n\n    // 绘制所有保存的圆\n    for(var i = 0; i < untangleGame.circle.length; i++) {\n        var circle = untangleGame.circle[i];\n        drawCircle(ctx, circle.x, circle.y, circle.radius);\n    }\n}\n</code></pre>\n<h2><a id=\"_6\"></a>效果如下：</h2>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/zvBdNW/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/zvBdNW/\'>zvBdNW</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p><a href=\"http://dengzhr.com/demo/HTML5/connect-ball/balls.html\">在线演示请戳这里~</a></p>\n<p><a href=\"http://dengzhr.com/demo/HTML5/connect-ball/balls.rar\">源码下载请戳这里~</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/html/415\">http://www.dengzhr.com/frontend/html/415</a></div>\n\n        ','2','1'),(288,'瀑布流布局的实现步步升级（原生JS）','\n\n            <p>瀑布流实现其实已经不是什么新鲜的玩意了，国内外多个展示性网站如<a href=\"http://huaban.com/\">花瓣网</a>、<a href=\"http://image.baidu.com/channel?c=%E6%91%84%E5%BD%B1&t=%E5%85%A8%E9%83%A8&s=0\">百度图片</a>等都早已采用了瀑布流的页面布局方式。瀑布流布局巧妙地重排元素并填补了容器的所有空间，适合小数据块，每个数据块内容相近且没有侧重。通常，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。所以，我们给这样的布局起了一个形象的名字 — 瀑布流布局。</p>\n<p>今天心血来潮，决定自己开发一个瀑布流布局，希望能�…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>瀑布流实现其实已经不是什么新鲜的玩意了，国内外多个展示性网站如<a href=\"http://huaban.com/\">花瓣网</a>、<a href=\"http://image.baidu.com/channel?c=%E6%91%84%E5%BD%B1&t=%E5%85%A8%E9%83%A8&s=0\">百度图片</a>等都早已采用了瀑布流的页面布局方式。瀑布流布局巧妙地重排元素并填补了容器的所有空间，适合小数据块，每个数据块内容相近且没有侧重。通常，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。所以，我们给这样的布局起了一个形象的名字 — 瀑布流布局。</p>\n<p>今天心血来潮，决定自己开发一个瀑布流布局，希望能兼容IE6+，而且能实现响应式布局，便在纸上构思其实现逻辑和思路。折腾了一个下午，于是，便有了下文。</p>\n<h2><a id=\"_4\"></a>HTML和CSS布局</h2>\n<p>一看到这种不规则的布局，第一时间蹦入脑中的就是父容器相对定位和子元素绝对定位，通过动态定义left和top的值来实现排版。</p>\n<p>以下是我的HTML和CSS代码（）：</p>\n<pre><code class=\"lang-css\">/* 这里用了通配选择器一键清除默认样式，大家不要学我，一般不建议这样使用，建议使用Normalize.css完成样式初始化 */\n* {\n    margin: 0;\n    padding: 0;\n    border: 0;\n}\n.waterfall {\n    width: 960px;\n    margin: 10px auto;\n    position: relative;\n}\n.waterfall:after, .waterfall:before {\n    content: \" \";\n    display: table;\n}\n.flow {\n    width: 310px;\n    background: #333;\n    position: absolute;\n    border: 1px solid #ccc;\n    box-shadow: #cccccc 2px 3px 3px;\n    transition: left .5s linear;\n    -webkit-transition: left .5s linear;\n    -moz-transition: left .5s linear;\n    -o-transition: left .5s linear;\n}\n.flow .flowItem {\n    width: 100%;\n    font-size: 42pt;\n    color: #fff;\n    text-align: center;\n}\n</code></pre>\n<pre><code class=\"lang-html\"><div class=\"waterfall\" id=\"waterfall\">\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 100px;\">1</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 200px;\">2</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 150px;\">3</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 400px;\">4</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 180px;\">5</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 120px;\">6</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 300px;>7</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 100px;\">8</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 120px;\">9</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 105px;\">10</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 180px;11</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 120px;\">12</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 300px;\">13</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 100px;\">14</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 120px;\">15</div></div>\n    <div class=\"flow\"><div class=\"flowItem\" style=\"height: 105px;\">16</div></div>\n</div>\n</code></pre>\n<p>快掩住我的眼，亮瞎了，什么鬼东西哇，丑死咧！！!</p>\n<p>莫急，下面我们好好来分析一下用JS动态分配定位元素的left和top值，重新排版一下。</p>\n<h2><a id=\"_5\"></a>JS实现一：测试版，仅为了实现而实现</h2>\n<p>为了测试，我先拟定了3列布局，每一个瀑布流元素块的宽度为310px，元素块之间的垂直和水平间距均为15px，经过我的人工计算，包裹容器的宽度刚好960px。</p>\n<p>首先，我要思考的是，要如何实现定位呢？一开始的时候，我想着，要不比较当前的块元素的前三个元素的offsetTop和offsetHeight得到最矮的一列，然后根据这一列定位当前元素。很快，这个想法实现起来漏洞百出，而且不合逻辑，deny掉啦。</p>\n<p>这种局部的过程是什么？就是当前元素排布在最矮的列上啊。如果我们能动态获取当前最矮的列高以及第几列，不就能准确定位当前元素了吗？那么问题来了，怎么获取当前最矮的列高和列序号呢？把每一列的高度存在一个数组里面，每次定位完当前元素，都实时修改当前定位的列高，那样每一次比较都能获得准确的最矮列了。原理就这么简单。</p>\n<p>那么如何快速获取一个数组中最小的值呢？最简单的方法之直接调用Math.min()方法<code>Math.min.apply(null, myArray)</code>。当然也可以用循环递归来实现判断，但是使用原生的Math方法性能会更高一些。</p>\n<p>直接上代码（因为用到querySelectorAll()和indexOf()，所以不能兼容IE6~8）：</p>\n<pre><code class=\"lang-javascript\"> var waterfall = document.getElementById(\"waterfall\");\n var flowItems = waterfall.querySelectorAll(\".flow\");\n\n // 简单版（只兼容至IE9，宽度、列数固定）\n // 共3列，每一列的宽度固定为310px，元素块之间的水平和垂直间距均为15px；瀑布流包含块的宽度为960px；\n\n // 声明瀑布流中每一列高度的数组pin[]\n var pin = [];\n pin[0] = flowItems[0].offsetTop + flowItems[0].offsetHeight;\n pin[1] = flowItems[1].offsetTop + flowItems[1].offsetHeight;\n pin[2] = flowItems[2].offsetTop + flowItems[2].offsetHeight;\n // 循环瀑布流元素的高度\n for(var i = 0, len = flowItems.length; i < len; i++) {\n     if(i >= 3) {\n         // 获取三个数中的最小值\n         var minH = Math.min.apply(null, pin);\n         // 获取高度数组中最小高度的索引\n         var minHItem = pin.indexOf(minH);\n         // 把当前元素在视觉上置于最小高度的一列\n         flowItems[i].style.left = minHItem * (310 + 15) + \"px\";\n         flowItems[i].style.top = minH + 15 + \"px\";\n         // 重置列的高度\n         pin[minHItem] += flowItems[i].offsetHeight + 15;\n         }else if(i < 3){\n         flowItems[i].style.top = 0;\n         flowItems[i].style.left = (i % 3) * (310 + 15) + \"px\";\n     }\n }\n</code></pre>\n<p>效果图如下：<br>\n<img src=\"http://dengzhr.com/demo/JavaScript/flow/source/autofixed.png\" alt></p>\n<p><a href=\"http://dengzhr.com/demo/JavaScript/flow/source/flow-valueFixed.html\">在线DEMO请戳这里~</a></p>\n<p>无疑，如你所见，耦合度高得无法直视，因为一些参数都是写死的，复用性较差。我们可以把一些参数抽离出来，把函数封装成独立的模块。见下面升级版的方法。</p>\n<h2><a id=\"_6\"></a>升级版：参数抽离和解决低版本IE的兼容性</h2>\n<p>重新对瀑布流定位函数进行了封装。并且把一些可自定义的参数抽离出来，由于参数数量较多，所以使用对象来存储数据。这样，我们就能自定义修改参数获得多种布局方式啦。</p>\n<p>由于上面的实现方法中因为使用了querySelectorAll()和indexOf()函数而导致不能兼容IE6~8。在这里，我重写了这两个函数实现，让低版本浏览器也能愉快地打开网站。</p>\n<p>JS代码见下：</p>\n<pre><code class=\"lang-javascript\"> var waterfallParent = document.getElementById(\"waterfall\");\n var flowItems = getClassName(waterfallParent, \"flow\");\n // 定义瀑布流布局参数，如下：\n // parent：瀑布流包裹容器，类型为DOM对象；floowItems：瀑布流布局子元素组，类型为DOM对象数组；pin：列数，类型为int；\n // width：每个瀑布流布局元素的宽度，类型为int；horizontalMargin：元素块之间的水平间距，类型为int；\n // verticalMargin：元素块之间的垂直间距，类型为int；\n var currentFlow = {\n parent: waterfallParent,\n flowItems: flowItems,\n pin: 4,\n width: 310,\n horizontalMargin: 15,\n verticalMargin: 15\n };\n\n waterfall(currentFlow);\n\n // 其中flow是一个对象，分别包含如下键值：\n // parent：瀑布流包裹容器，类型为DOM对象；floowItems：瀑布流布局子元素组，类型为DOM对象数组；pin：列数，类型为int；\n // width：每个瀑布流布局元素的宽度，类型为int；horizontalMargin：元素块之间的水平间距，类型为int；\n // verticalMargin：元素块之间的垂直间距，类型为int；\n function waterfall(flow) {\n     // 声明瀑布流中每一列高度的数组pin[]\n     var pin = new Array(flow.pin);\n     // 瀑布流框块数组\n     var flowItems = flow.flowItems;\n     // 声明每一列高度的初始值\n     for(var i = 0, pinLen = pin.length; i < pinLen; i++) {\n         pin[i] = flowItems[i].offsetTop + flowItems[i].offsetHeight;\n     }\n     // 循环瀑布流元素的高度\n     for(var i = 0, len = flowItems.length; i < len; i++) {\n         if(flow.width) {\n             flowItems[i].style.width = flow.width + \"px\";\n         }\n\n         if(i >= flow.pin) {\n             // 获取pin数组中的最小值\n             var minH = Math.min.apply(null, pin);\n             // 获取高度数组中最小高度的索引\n             var minHItem = pin.indexOf(minH);\n             // 把当前元素在视觉上置于最小高度的一列\n             flowItems[i].style.left = minHItem * (flow.width + flow.horizontalMargin) + \"px\";\n             flowItems[i].style.top = minH + flow.verticalMargin + \"px\";\n             // 重置列的高度\n             pin[minHItem] += flowItems[i].offsetHeight + flow.verticalMargin;\n         }else if(i < flow.pin){\n             flowItems[i].style.top = 0;\n             flowItems[i].style.left = (i % flow.pin) * (flow.width + flow.horizontalMargin) + \"px\";\n         }\n     }\n     // 计算瀑布流容器的宽度\n     flow.parent.style.width = flow.pin * flow.width + (flow.pin - 1) * flow.horizontalMargin + \"px\";\n\n }\n\n // 获取className的元素集合\n // 参数：obj指父元素；oClassName为元素的class属性值\n function getClassName(obj, oClassName) {\n     // IE9+及标准浏览器可以直接使用getElementsByClassName()获取className元素集合\n     if(document.getElementsByClassName) {\n        return obj.getElementsByClassName(oClassName);\n     }else {\n         // classNameArr用来装载class属性值为oClassName的元素；\n         var classNameArr = [];\n         // 获取obj的直接子元素\n         var objChild = obj.children || obj.childNodes;\n         // 遍历obj元素，获取class属性值为oClassName的元素列表\n         for(var i = 0; i < objChild.length; i++) {\n         // 判断obj子元素的class属性值中是否含有oClassName\n         if( hasClassName(objChild[i], oClassName) ) {\n         classNameArr.push(objChild[i]);\n         }\n     }\n     return classNameArr;\n     }\n }\n\n // Array.indexOf()函数的兼容性重写\n if (!Array.prototype.indexOf) {\n     Array.prototype.indexOf = function(ele) {\n         // 获取数组长度\n         var len = this.length;\n         // 检查值为数字的第二个参数是否存在，默认值为0\n         var fromIndex = Number(arguments[1]) || 0;\n         // 当第二个参数小于0时，为倒序查找，相当于查找索引值为该索引加上数组长度后的值\n         if(fromIndex < 0) {\n            fromIndex += len;\n         }\n        // 从fromIndex起循环数组\n         while(fromIndex < len) {\n             // 检查fromIndex是否存在且对应的数组元素是否等于ele\n             if(fromIndex in this && this[fromIndex] === ele) {\n                 return fromIndex;\n             }\n             fromIndex++;\n         }\n         // 当数组长度为0时返回不存在的信号：-1\n         if (len === 0) {\n            return -1;\n         }\n     }\n }\n</code></pre>\n<p><a href=\"http://dengzhr.com/demo/JavaScript/flow/source/flow-valueAuto.html\">在线DEMO请戳这里~</a></p>\n<p>这种实现似乎很完美了，至少现在的我觉得还算OK。但是由于我们现在做的网站大多都是响应式布局的，而以上的JS实现都是固定瀑布流容器宽度和列数的，显然并不能满足需求。</p>\n<h2><a id=\"_7\"></a>响应式版</h2>\n<p>有了上面封装好的可自定义列数的瀑布流布局函数，下面的实现就轻松多啦。我们可以检测当前设备的宽度，并根据探测的设备宽度决定当前排布的列数以及瀑布流包裹容器的宽度。</p>\n<p>在这里，我声明的响应断点是1200px, 960px, 767px 和320px。</p>\n<p>具体代码见下：</p>\n<pre><code class=\"lang-javascript\">// 超升级版（列数和每一列的宽度、元素块之间的边距为不定值，兼容IE6~8，实现响应式布局）\nvar waterfallParent = document.getElementById(\"waterfall\");\nvar flowItems = getClassName(waterfallParent, \"flow\");\n// 声明瀑布流浮动参数\n// parent：瀑布流包裹容器，类型为DOM对象；floowItems：瀑布流布局子元素组，类型为DOM对象数组；pin：列数，类型为int；\n// width：每个瀑布流布局元素的宽度，类型为int；horizontalMargin：元素块之间的水平间距，类型为int；\n// verticalMargin：元素块之间的垂直间距，类型为int；\nvar currentFlow = {\n    parent: waterfallParent,\n    flowItems: flowItems,\n    pin: 4,\n    width: 310,\n    horizontalMargin: 15,\n    verticalMargin: 15\n};\n\n// 声明响应式的响应断点\nvar deviceWidth = {\n    D: 1200,\n    C: 960,\n    B: 767,\n    A: 320\n};\n\n// 响应式瀑布流布局绘制\nwindow.onresize = responseFlow;\nresponseFlow();\nfunction responseFlow() {\n    var deviceW;\n    // 判断当前的设备屏幕宽度\n    function checkDeviceW() {\n        var screenW = document.documentElement.offsetWidth || document.body.offsetWidth;\n        if(screenW >= deviceWidth.A && screenW < deviceWidth.B) {\n            deviceW = \"A\";\n        }else if(screenW >= deviceWidth.B && screenW < deviceWidth.C) {\n            deviceW = \"B\";\n        }else if(screenW >= deviceWidth.C && screenW < deviceWidth.D) {\n            deviceW = \"C\";\n        }else if(screenW >= deviceWidth.D) {\n            deviceW = \"D\";\n        }\n    }\n    checkDeviceW();\n\n    // 修改不同响应下瀑布流布局的列数\n    switch(deviceW) {\n        case \"A\":\n            currentFlow.pin = 1;\n            break;\n        case \"B\":\n            currentFlow.pin = 2;\n            break;\n        case \"C\":\n            currentFlow.pin = 3;\n            break;\n        case \"D\":\n            currentFlow.pin = Math.floor(currentFlow.parent.offsetWidth / currentFlow.width);\n            break;\n    }\n    // 瀑布流重绘\n    waterfall(currentFlow);\n}\n\n// 其中flow是一个对象，分别包含如下键值：\n// pin：列数，类型为int；\nfunction waterfall(flow) {\n    // 声明瀑布流中每一列高度的数组pin[]\n    var pin = new Array(flow.pin);\n    // 瀑布流框块数组\n    var flowItems = flow.flowItems;\n    // 声明每一列高度的初始值\n    for(var i = 0, pinLen = pin.length; i < pinLen; i++) {\n        pin[i] = flowItems[i].offsetTop + flowItems[i].offsetHeight;\n    }\n    // 循环瀑布流元素的高度\n    for(var i = 0, len = flowItems.length; i < len; i++) {\n        if(flow.width) {\n            flowItems[i].style.width = flow.width + \"px\";\n        }\n\n        if(i >= flow.pin) {\n            // 获取pin数组中的最小值\n            var minH = Math.min.apply(null, pin);\n            // 获取高度数组中最小高度的索引\n            var minHItem = pin.indexOf(minH);\n            // 把当前元素在视觉上置于最小高度的一列\n            flowItems[i].style.left = minHItem * (flow.width + flow.horizontalMargin) + \"px\";\n            flowItems[i].style.top = minH + flow.verticalMargin + \"px\";\n            // 重置列的高度\n            pin[minHItem] += flowItems[i].offsetHeight + flow.verticalMargin;\n        }else if(i < flow.pin){\n            flowItems[i].style.top = 0;\n            flowItems[i].style.left = (i % flow.pin) * (flow.width + flow.horizontalMargin) + \"px\";\n        }\n    }\n    // 计算瀑布流容器的宽度\n    flow.parent.style.width = flow.pin * flow.width + (flow.pin - 1) * flow.horizontalMargin + \"px\";\n}\n\n// 获取className的元素集合\n// 参数：obj指父元素；oClassName为元素的class属性值\nfunction getClassName(obj, oClassName) {\n    // IE9+及标准浏览器可以直接使用getElementsByClassName()获取className元素集合\n    if(document.getElementsByClassName) {\n        return obj.getElementsByClassName(oClassName);\n    }else {\n        // classNameArr用来装载class属性值为oClassName的元素；\n        var classNameArr = [];\n        // 获取obj的直接子元素\n        var objChild = obj.children || obj.childNodes;\n        // 遍历obj元素，获取class属性值为oClassName的元素列表\n        for(var i = 0; i < objChild.length; i++) {\n            // 判断obj子元素的class属性值中是否含有oClassName\n            if( hasClassName(objChild[i], oClassName) ) {\n                classNameArr.push(objChild[i]);\n            }\n        }\n        return classNameArr;\n    }\n}\n\n// Array.indexOf()函数的兼容性重写\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(ele) {\n        // 获取数组长度\n        var len = this.length;\n        // 检查值为数字的第二个参数是否存在，默认值为0\n        var fromIndex = Number(arguments[1]) || 0;\n        // 当第二个参数小于0时，为倒序查找，相当于查找索引值为该索引加上数组长度后的值\n        if(fromIndex < 0) {\n            fromIndex += len;\n        }\n        // 从fromIndex起循环数组\n        while(fromIndex < len) {\n            // 检查fromIndex是否存在且对应的数组元素是否等于ele\n            if(fromIndex in this && this[fromIndex] === ele) {\n                return fromIndex;\n            }\n            fromIndex++;\n        }\n        // 当数组长度为0时返回不存在的信号：-1\n        if (len === 0) {\n            return -1;\n        }\n    }\n}\n</code></pre>\n<p>效果如下：<br>\n<img src=\"http://dengzhr.com/demo/JavaScript/flow/source/flow-response.gif\" alt></p>\n<p><a href=\"http://dengzhr.com/demo/JavaScript/flow/source/flow-response.html\">在线DEMO请戳这里~</a></p>\n<h2><a id=\"_8\"></a>总结</h2>\n<p>还可以用Ajax动态加载数据，以实现数据源源不断加载的效果，篇幅太长，分下一篇文章写，就酱纸。</p>\n<p>这种实现方法有一个十分不好的地方就是：一旦用户禁止了JavaScript或者JavaScript未加载完成，就不能正常显示页面内容。另外，由于布局采用父容器相对定位和子元素绝对定位，而绝对定位会使元素脱离文档流，从而导致父容器高度塌陷。所以，一般常见的处理办法是将瀑布流布局置于页面的尾部，或者动态获取父容器的高度。</p>\n<p>总的来说，虽然网上有很多瀑布流布局的插件和实现方法，而且实现原理也比较简单。但是亲自实践就会发现一些技巧和难点譬如如何获取数组中的最小值、动态判断屏幕宽度等都是很值得思考和优化的。</p>\n<p>喜欢就拿去用吧。<a href=\"http://dengzhr.com/demo/JavaScript/flow/source/flow.rar\">源码在此~</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/405\">http://www.dengzhr.com/js/405</a></div>\n\n        ','2','1'),(289,'环形进度条的实现方法总结和动态时钟绘制（CSS3、SVG、Canvas）','\n\n            <h2>缘由：</h2>\n<p>在某一个游戏公司的笔试中，最后一道大题是，“用CSS3实现根据动态显示时间和环形进度【效果如下图所示】，且每个圆环的颜色不一样，不需要考虑IE6~8的兼容性”。当时第一…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <h2><a id=\"_4\"></a>缘由：</h2>\n<p>在某一个游戏公司的笔试中，最后一道大题是，“用CSS3实现根据动态显示时间和环形进度【效果如下图所示】，且每个圆环的颜色不一样，不需要考虑IE6~8的兼容性”。当时第一想法是用SVG，因为SVG在画弧线方面是行家呀，另外Canvas也是极好的选择。但是规定了不能用SVG和Canvas，我想还可以使用CSS3的clip和rotate属性，但当时脑抽的我竟记不起clip的语法袅(囧~)。笔试结束后，便去查clip属性的使用，总结了实现环形进度条的方法，于是便有了下文。</p>\n<p><img src=\"http://dengzhr.com/demo/JavaScript/clock-circle-process/clock.png\" alt=\"clock\"></p>\n<p>图1：动态时钟样式</p>\n<h2><a id=\"_5\"></a>一. CSS3实现 + JS判断</h2>\n<p>看到圆环，而且不允许使用Canvas和SVG的话，大概都会想到用图片或者border-radius。但是可惜border属性并不能实现百分比边框。比较常见的做法是把标示进度的圆环切分成两半，并通过旋转半圆环和遮罩效果实现百分比进度效果。</p>\n<p>我实现的思路：</p>\n<p>1 . 把标示进度的圆环分成视觉上的左右两半(用CSS3的clip属性或者border-color:transparent)；并用非标示进度色的半圆环遮罩住标示进度色的左半圆环。</p>\n<p>2 . 在0~50%阶段，先把标示进度的右半圆环隐藏掉(display:none或opacity:0)；左半圆环先被用非标示进度色的半圆环遮罩，当左半圆环顺时针旋转时即可视觉上显示进度色的逐数改变；</p>\n<p>3 . 在50%~100%阶段，左半圆环停止旋转，右半圆环开始旋转，这样就能实现连贯的圆环旋转效果。另外，原本在左半圆环上方的遮罩层应隐藏，否则会遮盖住右半圆环的旋转效果；</p>\n<p>首先实现圆环效果，代码如下：<br>\nHTML代码：</p>\n<pre><code class=\"lang-html\"><div class=\"circle\">\n    <div class=\"track\"></div>\n    <div class=\"left transition-rotate\"></div>\n    <div class=\"right transition-rotate\"></div>\n    <div class=\"mask\"></div>\n    <span id=\"hour\">0</span><span class=\"percent\">%</span>\n</div>\n\n<input id=\"range\" type=\"range\" min=\"0\" max=\"100\" step=\"1\" value=\"0\">\n</code></pre>\n<p>CSS代码：</p>\n<pre><code class=\"lang-css\">/* 进度条样式 */\n.circle {\n    position: relative;\n    width: 130px;\n    height: 130px;\n    text-align: center;\n}\n.circle .track, .circle .mask, .circle .left, .circle .right {\n    width: 130px;\n    height: 130px;\n    position: absolute;\n    top: 0;\n    left: 0;\n    border-radius: 50%;\n    border: 20px #e7e7e7 solid;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n}\n.circle .mask, .circle .left, .circle .right {\n    clip: rect(0 65px 130px 0);\n}\n.circle .left, .circle .right {\n    border-color: #6FEC6F;\n}\n.circle .right {\n    opacity: 0;\n    -webkit-transform: rotate(180deg);\n    -moz-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    -o-transform: rotate(180deg);\n    transform: rotate(180deg);\n}\n/* 进度显示文字样式 */\n.circle #hour {\n    color: #666;\n    font-size: 48px;\n    line-height: 130px;\n}\n.circle .percent {\n    font-size: 20px;\n    color: #999;\n    margin-left: 5px;\n}\n.transition-rotate {\n    -webkit-transition: transform .1s ease-in-out;\n    -moz-transition: transform .1s ease-in-out;\n    -ms-transition: transform .1s ease-in-out;\n    -o-transition: transform .1s ease-in-out;\n    transition: transform .1s ease-in-out;\n}\n</code></pre>\n<p>JavaScript代码：</p>\n<pre><code class=\"lang-javascript\">var circle = document.querySelectorAll(\".circle\")[0];\nvar mask  = document.querySelectorAll(\".mask\")[0];\nvar left = document.querySelectorAll(\".left\")[0];\nvar right = document.querySelectorAll(\".right\")[0];\nvar range = document.getElementById(\"range\");\n\nvar hour = document.querySelectorAll(\"#hour\")[0];\n\nvar n;\nchangeHour();\nrange.oninput = changeHour;\nfunction changeHour() {\n    hour.innerHTML = range.value;\n    n = range.value;\n    if(n <= 50) {\n        left.style.webkitTransform=\"rotate(\" + 3.6 * n + \"deg)\";\n        right.style.opacity = 0;\n        mask.style.opacity = 1;\n    }else {\n        right.style.opacity = 1;\n        mask.style.opacity = 0;\n        left.style.webkitTransform=\"rotate(\" + 180 + \"deg)\";\n        right.style.webkitTransform=\"rotate(\" + 3.6 * n + \"deg)\";\n    }\n}\n</code></pre>\n<p>效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/dYXzKB/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/dYXzKB/\'>dYXzKB</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p><a href=\"http://dengzhr.com/demo/JavaScript/circle-process/css3.html\">在线演示请点击这里~</a></p>\n<h2><a id=\"_6\"></a>二. SVG实现</h2>\n<p>SVG中路径的动态描边一般使用stroke-dasharray和stroke-dashoffset这两个属性来创建虚线，通过虚线的实线与间隔来达到视觉上的动态描边效果。</p>\n<p>实现思路：</p>\n<p>通过使用使stroke-dasharray的长度恰好等于圆环的周长，再通过动态设置stroke-dashoffset的大小来填充透明圆环，使视觉上成进度条样式。</p>\n<p>代码如下：<br>\nHTML代码：</p>\n<pre><code class=\"lang-html\"><svg id=\"circleProcess\" xmlns=\"http://www.w3.org/2000/svg\">\n    <circle id=\"circle\" cx=\"50%\" cy=\"50%\" r=\"40%\" stroke-width=\"10%\"></circle>\n</svg>\n<input id=\"range\" type=\"range\" min=\"0\" max=\"255\" step=\"1\" value=\"0\">\n</code></pre>\n<p>CSS代码：</p>\n<pre><code class=\"lang-css\">#circleProcess {\n    position: relative;\n    top: 0;\n    left: 0;\n    width: 200px;\n    height: 200px;\n    stroke-dasharray: 255%;\n    stroke-dashoffset: 255%;\n    stroke: #6FEC6F;\n    fill: none;\n    -webkit-transform: rotate(-90deg);\n    -moz-transform: rotate(-90deg);\n    -ms-transform: rotate(-90deg);\n    -o-transform: rotate(-90deg);\n    transform: rotate(-90deg);\n}\n</code></pre>\n<p>JavaScript代码：</p>\n<pre><code class=\"lang-javascript\">var circleProcess = document.getElementById(\"circleProcess\");\nvar circle = document.getElementById(\"circle\");\nvar range = document.getElementById(\"range\");\n// 滑动条的值\nvar rangeValue;\n\nrange.oninput = function() {\n    rangeValue = Number(range.value);\n    circle.setAttribute(\"stroke-dashoffset\", (255 - rangeValue) + \"%\");\n}\n</code></pre>\n<p>效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/gaMxdP/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/gaMxdP/\'>gaMxdP</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p><a href=\"http://dengzhr.com/demo/JavaScript/circle-process/svg.html\">在线演示请戳这里~</a></p>\n<h2><a id=\"_7\"></a>三. HTML5的Canvas实现</h2>\n<p>HTML5的Canvas最擅长的技能之一就是画图表。在Canvas中，可以通过arc(x1, y1, r, beginAngle, endAngle, boolean)函数来通过定义起始角度和终点角度来画出一段弧形。</p>\n<p>HTML代码：</p>\n<pre><code class=\"lang-html\"><canvas id=\"circle\" width=\"130\" height=\"130\"></canvas>\n<input id=\"range\" type=\"range\" min=\"0\" max=\"360\" step=\"1\" value=\"0\">\n</code></pre>\n<p>JavaScript代码：</p>\n<pre><code class=\"lang-javascript\">var range = document.getElementById(\"range\");\nvar rangeValue; // 滑动条获得的是度数值\n\nvar circle = document.getElementById(\"circle\");\nvar circleWidth = circle.width;\nvar circleHeight = circle.height;\nvar circleContext = circle.getContext(\"2d\");\n\nvar circleValue = {\n    x: 65,\n    y: 65,\n    r: 45,\n    beginAngle: - Math.PI / 2,\n    endAngle: 0\n};\n\n// 样式\ncircleContext.lineWidth = 20;\ncircleContext.strokeStyle = \"#6FEC6F\";\n\n// 描绘进度圆环\nfunction drawCircle() {\n    circleContext.restore();\n    // 清空当前路径\n    circleContext.clearRect(0,0, circleWidth, circleHeight);\n    // 把range的度数值换成Math.PI值\n    rangeValue = Number(range.value); // 滑动条获得的是度数值\n    circleValue.endAngle = circleValue.beginAngle + (rangeValue / 360) * 2 * Math.PI;\n    circleContext.beginPath();\n    // 绘制圆弧\n    circleContext.arc(circleValue.x, circleValue.y, circleValue.r, circleValue.beginAngle, circleValue.endAngle, false);\n    circleContext.stroke();\n    circleContext.save();\n}\n// 滚动条滑动动画\nrange.oninput = drawCircle;\ndrawCircle();\n</code></pre>\n<p>效果如下：</p>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/rOLzZK/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/rOLzZK/\'>rOLzZK</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p><a href=\"http://dengzhr.com/demo/JavaScript/circle-process/html5.html\">在线演示请戳这里~</a></p>\n<h2><a id=\"_8\"></a>四. sprite图实现</h2>\n<p>sprite图实现的原理就是画好每一个关键帧的状态图片，然后通过动态改变每一帧中background的position值。这种方法比较原始，兼容性很好，而且可以花样设计，但是由于引入多个状态图，可能会导致下载量很大，而且比较臃肿。</p>\n<p>在这里就不详细讲解啦，这么简单的你们都懂~（真相是我真不想画那么多个状态图~( ╯□╰ )~）</p>\n<h2><a id=\"_9\"></a>动态时钟绘制（CSS3、SVG、Canvas）</h2>\n<p>来为这次缘由画上顿号。</p>\n<p>这篇教程源于笔试题中的最后一题，感觉智商被碾压了，所以归来开始思考其实现方案。题目如下：</p>\n<p>“用CSS3实现根据动态显示时间和环形进度，且每个圆环的颜色不一样。不需要考虑IE6~8的兼容性。”效果图如上图1所示。</p>\n<p>如下是我分别用CSS3、SVG、Canvas实现的动态时钟和环形进度实例。</p>\n<h3><a id=\"_10\"></a>1. CSS3实现的动态时钟和环形进度</h3>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/Gpqvwo/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/Gpqvwo/\'>Gpqvwo</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p><a href=\"http://dengzhr.com/demo/JavaScript/clock-circle-process/clock-css3.html\">在线演示请戳这里~</a></p>\n<h3><a id=\"_11\"></a>2. SVG实现的动态时钟和环形进度</h3>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/XmKayP/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/XmKayP/\'>XmKayP</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p><a href=\"http://dengzhr.com/demo/JavaScript/clock-circle-process/clock-svg.html\">在线演示请戳这里~</a></p>\n<h3><a id=\"_12\"></a>3. HTML5的canvas实现的动态时钟和环形进度</h3>\n<p><iframe height=\"268\" scrolling=\"no\" src=\"//codepen.io/dengzhirong/embed/epzEbK/?height=268&theme-id=15149&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\'http://codepen.io/dengzhirong/pen/epzEbK/\'>epzEbK</a> by dengzhirong (<a href=\'http://codepen.io/dengzhirong\'>@dengzhirong</a>) on <a href=\'http://codepen.io\'>CodePen</a>.<br />\n</iframe></p>\n<p><a href=\"http://dengzhr.com/demo/JavaScript/clock-circle-process/clock-html5.html\">在线演示请戳这里~</a></p>\n<h2><a id=\"_13\"></a>源码下载</h2>\n<p>1 . <a href=\"http://dengzhr.com/demo/JavaScript/circle-process/circle-process.rar\">环形进度条的实现(CSS3、SVG、canvas)+JS 源码包下载~</a></p>\n<p>2 . <a href=\"http://dengzhr.com/demo/JavaScript/clock-circle-process/clock-circle-process.rar\">环形动态时钟绘制(CSS3、SVG、canvas)+JS 源码包下载~</a></p>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/frontend/css/421\">http://www.dengzhr.com/frontend/css/421</a></div>\n\n        ','2','1'),(290,'JavaScript数组方法的兼容性写法 汇总：indexOf()、forEach()、map()、filter()、some()、every()','\n\n            <p>ECMA Script5中数组方法如indexOf()、forEach()、map()、filter()、some()并不支持IE6～8，但是国内依然有一大部分用户使用IE6～8，而以上数组方法又确实非常好用。在过去，我会为了兼容性尽量不用这些方法。但是…</p>\n        ','0000-00-00 00:00:00','0000-00-00 00:00:00',0,'1','\n\n            <p>ECMA Script5中数组方法如indexOf()、forEach()、map()、filter()、some()并不支持IE6～8，但是国内依然有一大部分用户使用IE6～8，而以上数组方法又确实非常好用。在过去，我会为了兼容性尽量不用这些方法。但是，总不能为了旧的丢了新的吧？！虽然说jQuery已经集成好了不少语法糖，但jQuery体积太庞大，作为一名志于体面的前端儿得知道原生的兼容性写法要怎么写。于是这几天，我开始在琢磨这些方法的兼容性写法。其实并不难，就是以前不够自信不敢写。写完以后，对数组认识更深一些了。总结见下文。</p>\n<p>备注：以下兼容性写法均可兼容至IE6；</p>\n<h2><a id=\"_4\"></a>indexOf()</h2>\n<p>indexOf()方法 返回根据给定元素找到的第一个索引值，否则返回-1。</p>\n<h3><a id=\"_5\"></a>语法：</h3>\n<p>array.indexOf(searchElement[, fromIndex = 0])</p>\n<h3><a id=\"_6\"></a>参数：</h3>\n<p>searchElement  // 位于数组中的元素；</p>\n<p>fromIndex // 开始查找指定元素的索引值，默认值为 0 (即在整个数组中查找指定元素)；</p>\n<p>fromIndex大于或等于数组长度，则停止查找并返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。</p>\n<p>兼容性：不兼容IE6～8。</p>\n<p>根据indexOf()的语法写出兼容IE6～8的写法如下：</p>\n<h3><a id=\"_7\"></a>兼容性写法：</h3>\n<pre><code class=\"lang-javascript\">if (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(ele) {\n        // 获取数组长度\n        var len = this.length;\n        // 检查值为数字的第二个参数是否存在，默认值为0\n        var fromIndex = Number(arguments[1]) || 0;\n        // 当第二个参数小于0时，为倒序查找，相当于查找索引值为该索引加上数组长度后的值\n        if(fromIndex < 0) {\n            fromIndex += len;\n        }\n        // 从fromIndex起循环数组\n        while(fromIndex < len) {\n            // 检查fromIndex是否存在且对应的数组元素是否等于ele\n            if(fromIndex in this && this[fromIndex] === ele) {\n                return fromIndex;\n            }\n            fromIndex++;\n        }\n        // 当数组长度为0时返回不存在的信号：-1\n        if (len === 0) {\n            return -1;\n        }\n    }\n}\n</code></pre>\n<p>调用示例：</p>\n<pre><code class=\"lang-javascript\">var arr = [\"a\", \"b\", \"c\"];\nalert(arr.indexOf(\"b\")); // 1\n</code></pre>\n<h2><a id=\"_8\"></a>forEach()</h2>\n<p>forEach() 方法让数组的每一项都执行一次给定的函数。forEach()方法会修改原数组。</p>\n<h2><a id=\"_9\"></a>语法：</h2>\n<p>array.forEach(callback[, thisArg])</p>\n<h2><a id=\"_10\"></a>参数：</h2>\n<p>1 . callback ：在数组每一项上执行的函数，接收三个参数：<br>\ncurrentValue（当前项的值）、index（当前项的索引）和array（数组本身）。</p>\n<p>2 . thisArg ：可选参数。用来当作callback 函数内this的值的对象，即callback 函数的执行上下文；</p>\n<p>forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者从未赋值的项将被跳过（但不包括哪些值为 undefined 的项）。</p>\n<p>兼容性：不兼容IE6～8。</p>\n<p>根据forEach()的语法写出兼容IE6～8的写法如下：</p>\n<h3><a id=\"_11\"></a>兼容性写法：</h3>\n<pre><code class=\"lang-javascript\">if ( !Array.prototype.forEach) {\n  Array.prototype.forEach = function forEach(callback) {\n      // 获取数组长度\n    var len = this.length;\n    if(typeof callback != \"function\") {\n        throw new TypeError();\n    }\n    // thisArg为callback 函数的执行上下文环境\n    var thisArg = arguments[1];\n    for(var i = 0; i < len; i++) {\n        if(i in this) {\n            // callback函数接收三个参数：当前项的值、当前项的索引和数组本身\n            callback.call(thisArg, this[i], i, this);\n        }\n    }\n  }\n}\n</code></pre>\n<p>调用示例：</p>\n<pre><code class=\"lang-javascript\">var arr = [\"a\", \"b\", \"c\", \"a\", \"d\", \"a\"];\narr.forEach(function(ele, index, array){\n    if(ele == \"a\") {\n        array[index] = \"**\";\n    }\n});\nalert(newArr); // [\"**\", \"b\", \"c\", \"**\", \"d\", \"**\"]\n</code></pre>\n<h2><a id=\"_12\"></a>map()</h2>\n<p>map() 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。</p>\n<h3><a id=\"_13\"></a>语法：</h3>\n<p>array.map(callback[, thisArg])</p>\n<h3><a id=\"_14\"></a>参数：</h3>\n<p>1 . callback ： 在数组每一项上执行的函数，接收三个参数：<br>\ncurrentValue（当前项的值）、index（当前项的索引）和array（数组本身）；</p>\n<p>2 . thisArg ：可选参数。用来当作callback 函数内this的值的对象，即callback 函数的执行上下文；</p>\n<p>兼容性：不兼容IE6～8。</p>\n<p>根据map()的语法写出兼容IE6～8的写法如下：</p>\n<h3><a id=\"_15\"></a>兼容性写法：</h3>\n<pre><code class=\"lang-javascript\">if (!Array.prototype.map) {\n  Array.prototype.map = function(callback) {\n      // 获取数组长度\n      var len = this.length;\n      if(typeof callback != \"function\") {\n          throw new TypeError();\n      }\n      // 创建跟原数组相同长度的新数组，用于承载经回调函数修改后的数组元素\n      var newArr = new Array(len);\n      // thisArg为callback 函数的执行上下文环境\n      var thisArg = arguments[1];\n      for(var i = 0; i < len; i++) {\n          if(i in this) {\n              newArr[i] = callback.call(thisArg, this[i], i, this);\n          }\n      }\n      return newArr;\n  }    \n}\n</code></pre>\n<p>调用示例：</p>\n<pre><code class=\"lang-javascript\">var arr = [\"a\", \"b\", \"c\"];\nvar newArr = arr.map(function(ele, index, array){\n    ele += \"12\";\n    return ele;\n});\nalert(newArr); // [\"a12\", \"b12\", \"c12\"]\n</code></pre>\n<h2><a id=\"_16\"></a>filter()</h2>\n<p>filter() 方法利用所有通过指定函数测试的元素创建一个新的数组，并返回。</p>\n<h2><a id=\"_17\"></a>语法：</h2>\n<p>arr.filter(callback[, thisArg])</p>\n<h2><a id=\"_18\"></a>参数：</h2>\n<p>1 . callback ： 在数组每一项上执行的函数，接收三个参数：<br>\ncurrentValue（当前项的值）、index（当前项的索引）和array（数组本身）；</p>\n<p>2 . thisArg ：可选参数。用来当作callback 函数内this的值的对象，即callback 函数的执行上下文；</p>\n<p>filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 \"true\" 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素只会被跳过，不会被包含在新数组中。filter 不会改变原数组。</p>\n<p>兼容性：不兼容IE6～8。</p>\n<p>根据filter()的语法写出兼容IE6～8的写法如下：</p>\n<h3><a id=\"_19\"></a>兼容性写法：</h3>\n<pre><code class=\"lang-javascript\">if (!Array.prototype.filter) {\n    Array.prototype.filter = function(callback) {\n      // 获取数组长度\n      var len = this.length;\n      if(typeof callback != \"function\") {\n          throw new TypeError();\n      }\n      // 创建新数组，用于承载经回调函数修改后的数组元素\n      var newArr = new Array();\n      // thisArg为callback 函数的执行上下文环境\n      var thisArg = arguments[1];\n      for(var i = 0; i < len; i++) {\n          if(i in this) {\n              if(callback.call(thisArg, this[i], i, this)) {\n                  newArr.push(val);\n              }\n          }\n      }\n      return newArr;\n  }\n}\n</code></pre>\n<p>调用示例：</p>\n<pre><code class=\"lang-javascript\">var arr = [1, 2, 3, 4, 3, 2, 5];\nvar newArr = arr.filter(function(ele, index, array){\n    if(ele < 3) {\n        return true;\n    }else {\n        return false;\n    }\n});\nalert(newArr); // [1, 2, 2]\n</code></pre>\n<h2><a id=\"_20\"></a>some()</h2>\n<p>some() 方法测试数组中的某些元素是否通过了指定函数的测试。返回布尔值。some() 被调用时不会改变数组。</p>\n<h3><a id=\"_21\"></a>语法：</h3>\n<p>arr.some(callback[, thisArg])</p>\n<h3><a id=\"_22\"></a>参数：</h3>\n<p>1 . callback ： 在数组每一项上执行的函数，接收三个参数：<br>\ncurrentValue（当前项的值）、index（当前项的索引）和array（数组本身）；</p>\n<p>2 . thisArg ：可选参数。用来当作callback 函数内this的值的对象，即callback 函数的执行上下文；</p>\n<p>some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个true 的值。如果找到了这样一个值，some() 将返回 true。否则返回 false。</p>\n<p>兼容性：不兼容IE6～8。</p>\n<p>根据some()的语法写出兼容IE6～8的写法如下：</p>\n<h3><a id=\"_23\"></a>兼容性写法：</h3>\n<pre><code class=\"lang-javascript\">if (!Array.prototype.some) {\n  Array.prototype.some = function(callback) {\n      // 获取数组长度\n      var len = this.length;\n      if(typeof callback != \"function\") {\n          throw new TypeError();\n      }\n      // thisArg为callback 函数的执行上下文环境\n      var thisArg = arguments[1];\n      for(var i = 0; i < len; i++) {\n          if(i in this && callback.call(thisArg, this[i], i, this)) {\n              return true;\n          }\n      }\n      return false;\n  }\n}\n</code></pre>\n<p>调用示例：</p>\n<pre><code class=\"lang-javascript\">var arr = [1, 2, 3, 4, 3, 2, 5];\nvar newArr = arr.some(function(ele, index, array){\n    if(ele < 2) {\n        return true;\n    }else {\n        return false;\n    }\n});\nalert(newArr); // true\n</code></pre>\n<h2><a id=\"_24\"></a>every()</h2>\n<p>every() 方法测试数组的所有元素是否都通过了指定函数的测试。every() 不会改变原数组。</p>\n<h3><a id=\"_25\"></a>语法：</h3>\n<p>arr.every(callback[, thisArg])</p>\n<h3><a id=\"_26\"></a>参数：</h3>\n<p>1 . callback ： 在数组每一项上执行的函数，接收三个参数：<br>\ncurrentValue（当前项的值）、index（当前项的索引）和array（数组本身）；</p>\n<p>2 . thisArg ：可选参数。用来当作callback 函数内this的值的对象，即callback 函数的执行上下文；</p>\n<p>every() 方法为数组中的每个元素执行一次 callback 函数。只有所有元素都在callback函数中返回true才返回true，否则返回false。</p>\n<p>兼容性：不兼容IE6～8。</p>\n<p>根据some()的语法写出兼容IE6～8的写法如下：</p>\n<h3><a id=\"_27\"></a>兼容性写法：</h3>\n<pre><code class=\"lang-javascript\">if (!Array.prototype.every) {\n  Array.prototype.every = function(callback) {\n      // 获取数组长度\n      var len = this.length;\n      if(typeof callback != \"function\") {\n          throw new TypeError();\n      }\n      // thisArg为callback 函数的执行上下文环境\n      var thisArg = arguments[1];\n      for(var i = 0; i < len; i++) {\n          if(i in this && !callback.call(thisArg, this[i], i, this)) {\n              return false;\n          }\n      }\n      return true;\n  }\n}\n</code></pre>\n<p>调用示例：</p>\n<pre><code class=\"lang-javascript\">var arr = [1, 2, 3, 4, 3, 2, 5];\nvar newArr = arr.every(function(ele, index, array){\n    if(ele < 3) {\n        return true;\n    }else {\n        return false;\n    }\n});\nalert(newArr); // false\n</code></pre>\n\n            <div class=\"article-copyright\">本文作者：<a href=\"http://www.dengzhr.com\">子匠_Zijor</a>，转载请注明出处：<a href=\"http://www.dengzhr.com/js/362\">http://www.dengzhr.com/js/362</a></div>\n\n        ','2','1');
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_path`
--

DROP TABLE IF EXISTS `article_path`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_path` (
  `id` int(5) unsigned NOT NULL AUTO_INCREMENT,
  `path` varchar(100) NOT NULL,
  `article_id` int(4) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_path`
--

LOCK TABLES `article_path` WRITE;
/*!40000 ALTER TABLE `article_path` DISABLE KEYS */;
/*!40000 ALTER TABLE `article_path` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_tag`
--

DROP TABLE IF EXISTS `article_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_tag` (
  `id` int(8) unsigned NOT NULL AUTO_INCREMENT,
  `article_id` int(4) NOT NULL,
  `tag_id` int(4) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_tag`
--

LOCK TABLES `article_tag` WRITE;
/*!40000 ALTER TABLE `article_tag` DISABLE KEYS */;
/*!40000 ALTER TABLE `article_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `classify`
--

DROP TABLE IF EXISTS `classify`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `classify` (
  `id` int(8) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  `description` varchar(100) DEFAULT NULL,
  `color` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `classify`
--

LOCK TABLES `classify` WRITE;
/*!40000 ALTER TABLE `classify` DISABLE KEYS */;
INSERT INTO `classify` VALUES (1,'js','javascript相关','#FFA2D3'),(2,'装机','瞎倒腾QAQ','error'),(3,'UI框架','iview、elementui、vant...','#f60'),(4,'后端java','为所欲为','#f60'),(5,'node','',''),(6,'ES6','好用灵活',''),(7,'react','好用灵活',''),(8,'TCP/IP','好用灵活','');
/*!40000 ALTER TABLE `classify` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `saying`
--

DROP TABLE IF EXISTS `saying`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `saying` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `content` varchar(255) NOT NULL,
  `add_date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_date` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  `author` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `saying`
--

LOCK TABLES `saying` WRITE;
/*!40000 ALTER TABLE `saying` DISABLE KEYS */;
INSERT INTO `saying` VALUES (2,'上线新功能','2019-04-28 08:52:46','0000-00-00 00:00:00','O丶Hillary'),(3,'时间没用吗？','2019-04-28 09:24:51','2019-04-28 09:24:51','O丶Hillary'),(4,'今日总结','2019-04-28 09:32:42','2019-04-28 09:32:42','O丶Hillary'),(5,'想去看电影','2019-04-28 09:33:51','2019-04-28 09:33:51','O丶Hillary'),(6,'坚持不懈','2019-04-28 09:34:16','2019-04-28 09:34:16','O丶Hillary');
/*!40000 ALTER TABLE `saying` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tag`
--

DROP TABLE IF EXISTS `tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tag` (
  `id` int(4) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  `description` varchar(100) DEFAULT NULL,
  `color` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tag`
--

LOCK TABLES `tag` WRITE;
/*!40000 ALTER TABLE `tag` DISABLE KEYS */;
INSERT INTO `tag` VALUES (1,'java','Java666','gold'),(2,'node2','node相关sss','green'),(5,'node3','node相关aaa','orange'),(6,'vue','vue特别好用6666','#ff9900'),(7,'jQuery','jQuery相关','#ed4014'),(8,'mysql','niubihonghong','purple'),(9,'es5','ecmascript2014','pink'),(10,'vue-router','全家桶之一','blue'),(11,'vuex','重点学习','yellow'),(12,'vue-form','处理表单听说很好用','red'),(13,'javascript','niubihonghong','#f60'),(14,'算法','特别牛逼的东西，谢峰是狗','#f60');
/*!40000 ALTER TABLE `tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `token`
--

DROP TABLE IF EXISTS `token`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `token` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(10) NOT NULL,
  `token` varchar(100) NOT NULL,
  `expire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `token`
--

LOCK TABLES `token` WRITE;
/*!40000 ALTER TABLE `token` DISABLE KEYS */;
INSERT INTO `token` VALUES (1,1,'f157f160-a3a3-11e9-b0db-f9f297318aad','2019-07-12 06:20:13');
/*!40000 ALTER TABLE `token` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user` (
  `password` varchar(255) NOT NULL,
  `last_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `add_time` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  `expire_time` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  `type` tinyint(2) NOT NULL,
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES ('e20faa2ad0db546208b0405557eeb6de','2019-06-24 09:16:25','2019-06-24 09:16:25','2019-06-24 09:16:25',0,1),('e10adc3949ba59abbe56e057f20f883e','2019-06-24 09:18:54','2019-06-24 09:18:54','2019-06-24 11:42:54',1,2),('fcea920f7412b5da7be0cf42b8c93759','2019-06-24 09:23:14','2019-06-24 09:23:14','2019-06-24 09:37:38',1,3);
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-08-12 19:54:24
